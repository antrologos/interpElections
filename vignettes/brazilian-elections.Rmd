---
title: "Interpolating Brazilian Electoral Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Interpolating Brazilian Electoral Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette walks through the primary use case of `interpElections`:
disaggregating Brazilian electoral data from polling locations into census
tracts. The package automates census data download, electoral data retrieval,
travel-time computation, and IDW interpolation -- all in a single function
call.

## Prerequisites

The Brazilian workflow requires several packages for census data, shapefiles,
and travel-time routing. Install them once:

```{r install-deps, eval = FALSE}
install.packages(c("sf", "geobr", "censobr", "dplyr", "tidyr",
                    "data.table", "stringr", "arrow"))
```

Travel-time computation requires Java 21+ and the r5r package:

```{r install-r5r, eval = FALSE}
install.packages("r5r")

# Install Java 21 (if not already installed)
setup_java()

# Verify Java + r5r are properly configured
check_r5r()
```

For GPU-accelerated optimization (optional, for large municipalities):

```{r install-torch, eval = FALSE}
setup_torch()
check_torch()
```

## One-Call Workflow

The simplest way to use the package is `interpolate_election_br()`, which
handles everything automatically. You only need an IBGE municipality code
and an election year:

```{r one-call, eval = FALSE}
library(interpElections)

result <- interpolate_election_br(
  code_muni = 1400100,  # Boa Vista, RR
  year = 2020
)
```

For this vignette, we load a pre-computed result instead of running the full
pipeline (which requires network access and Java):

```{r load-result}
library(interpElections)

result <- readRDS(
  system.file("extdata/example_br_result.rds", package = "interpElections")
)
```

The result is an `interpElections_result` object with a rich `summary()`:

```{r summary-result}
summary(result)
```

Plot the first interpolated variable as a choropleth map:

```{r plot-result, echo=FALSE, fig.width=7, fig.height=5}
plot(result)
```

<details>
<summary>Show plot code</summary>

```{r, ref.label="plot-result", eval=FALSE}
```

</details>

### Filtering what to interpolate

The `what` parameter controls which variables are interpolated. The
`candidates` and `parties` parameters filter specific subsets:

```{r what-examples, eval = FALSE}
# Only specific candidates (by ballot number or name)
result <- interpolate_election_br(
  code_muni = 1400100, year = 2020,
  what = "candidates",
  candidates = c(13, 22)
)

# Party-level vote totals
result <- interpolate_election_br(
  code_muni = 1400100, year = 2020,
  what = "parties",
  parties = c("PT", "PL")
)

# Turnout and abstention
result <- interpolate_election_br(
  code_muni = 1400100, year = 2020,
  what = "turnout"
)

# Voter demographics (gender + education level)
result <- interpolate_election_br(
  code_muni = 1400100, year = 2020,
  what = "demographics"
)
```

## The Municipality Crosswalk

Brazilian electoral data uses TSE 5-digit codes, while census data uses IBGE
7-digit codes. The package includes a crosswalk table mapping all 5,710
municipalities:

```{r crosswalk}
data(muni_crosswalk)
dim(muni_crosswalk)
head(muni_crosswalk)
```

Search by name or state:

```{r crosswalk-search}
# Find Boa Vista
subset(muni_crosswalk, grepl("BOA VISTA", nome))

# All municipalities in Roraima
subset(muni_crosswalk, uf == "RR")
```

When you call `interpolate_election_br()`, the TSE code and state
abbreviation are resolved automatically from the IBGE code.

## Step-by-Step Workflow

Under the hood, `interpolate_election_br()` runs five preparation steps
before calling the core interpolation engine. You can run each step
individually for more control.

### Step 1 -- Census population

`br_prepare_population()` downloads census population data (via `censobr`)
and groups ages into brackets that match the TSE voter profile data:

```{r pop-call, eval = FALSE}
pop_data <- br_prepare_population(code_muni = 1400100, year = 2022)
```

```{r pop-load}
pop_data <- readRDS(
  system.file("extdata/example_pop_data.rds", package = "interpElections")
)
head(pop_data)
str(pop_data)
```

The census year is auto-selected based on the election year:

| Election years | Census year |
|---|---|
| 2000--2004 | 2000 |
| 2008--2016 | 2010 |
| 2020+ | 2022 |

You can override this with the `census_year` parameter.

### Step 2 -- Tract geometries

`br_prepare_tracts()` downloads census tract shapefiles via `geobr`, joins
the population data, and optionally removes unpopulated tracts:

```{r tracts-call, eval = FALSE}
tracts_sf <- br_prepare_tracts(
  code_muni = 1400100,
  pop_data = pop_data
)
```

```{r tracts-load}
tracts_sf <- readRDS(
  system.file("extdata/example_tracts_sf.rds", package = "interpElections")
)
dim(tracts_sf)
names(tracts_sf)
```

```{r plot-tracts, echo=FALSE, fig.width=7, fig.height=5}
library(sf)
plot(st_geometry(tracts_sf), main = "Census tracts")
```

<details>
<summary>Show plot code</summary>

```{r, ref.label="plot-tracts", eval=FALSE}
```

</details>

Additional options:

- `remove_unpopulated = TRUE` (default): drops tracts with zero population.
- `clip_sf`: pass an `sf` polygon to clip tracts to an urban boundary,
  removing parks, forests, or water bodies.

### Step 3 -- Electoral data

`br_prepare_electoral()` downloads TSE voting data, merges geocoded polling
station coordinates, and aggregates to the polling-location level:

```{r electoral-call, eval = FALSE}
electoral_data <- br_prepare_electoral(
  code_muni_ibge = "1400100",
  code_muni_tse = "03018",
  uf = "RR",
  year = 2020
)
```

```{r electoral-load}
electoral_data <- readRDS(
  system.file("extdata/example_electoral_data.rds", package = "interpElections")
)
head(electoral_data[, 1:8])
names(electoral_data)
```

The `what`, `candidates`, and `parties` parameters work the same way as in
`interpolate_election_br()`.

### Step 4 -- Travel times

Travel-time computation requires r5r and a Java runtime. The package can
download the OSM road network automatically:

```{r travel-times, eval = FALSE}
# Download OSM road network for the municipality
r5r_data <- download_r5r_data(
  area_sf    = tracts_sf,
  output_dir = "r5r_network/boa_vista"
)

# Convert electoral data to sf points
electoral_sf <- sf::st_as_sf(electoral_data,
                              coords = c("long", "lat"), crs = 4326)

# Compute travel-time matrix (tract centroids -> polling locations)
tt_matrix <- compute_travel_times(
  zones_sf     = tracts_sf,
  points_sf    = electoral_sf,
  network_path = r5r_data$output_dir,
  mode         = "WALK",
  max_trip_duration = 300
)
```

If you already have a travel-time matrix from another source, skip this step
entirely by passing it via the `time_matrix` parameter in
`interpolate_election_br()` or `interpolate_election()`.

### Step 5 -- Optimize and interpolate

The final step finds optimal decay parameters (alpha) and applies the
IDW interpolation:

```{r optimize-interpolate, eval = FALSE}
# Find optimal alpha (one per tract)
optim_result <- optimize_alpha(
  time_matrix = tt_matrix,
  pop_matrix = pop_matrix,
  source_matrix = source_matrix
)

# Apply interpolation with the optimized alpha
interpolated <- idw_interpolate(
  time_matrix = tt_matrix,
  alpha = optim_result$alpha,
  source_matrix = electoral_matrix
)
```

## Downloading Raw TSE Data

The package provides direct access to TSE open data for custom analyses:

```{r download-tse, eval = FALSE}
# Candidate vote data (votacao por secao eleitoral)
votes <- br_download_votes(year = 2020, uf = "RR")

# Turnout/attendance data (comparecimento e abstencao)
turnout <- br_download_turnout(year = 2020, uf = "RR")

# Polling station geocodes (latitude/longitude)
geocodes <- br_download_geocode(year = 2020, uf = "RR")
```

Note: geocoding data is not available from TSE for elections before
approximately 2014.

## Supported Elections

Brazil holds elections every two years, alternating between municipal and
general (federal/state) elections:

**Municipal elections** (2000, 2004, 2008, 2012, 2016, 2020, 2024):

| Cargo | TSE code | Description |
|---|---|---|
| Prefeito | 11 | Mayor |
| Vereador | 13 | City councilor |

**General elections** (2002, 2006, 2010, 2014, 2018, 2022):

| Cargo | TSE code | Description |
|---|---|---|
| Presidente | 1 | President |
| Governador | 3 | State governor |
| Senador | 5 | Senator |
| Deputado Federal | 6 | Federal representative |
| Deputado Estadual | 7 | State representative |
| Deputado Distrital | 8 | District representative (DF only) |

Use the `turno` parameter to select the election round: `1` (first round,
always available) or `2` (runoff, only for executive offices when no
candidate wins outright).
