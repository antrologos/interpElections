---
title: "Using interpElections with Your Own Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using interpElections with Your Own Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

While `interpElections` was designed for Brazilian elections, the core
interpolation engine works with any point-to-polygon spatial disaggregation
problem. This vignette shows how to use the package with your own data.

## When to Use This Vignette

Use `interpElections` when you have:

- **Source points** (e.g., schools, hospitals, weather stations, sensors)
  with counts or measurements for one or more variables.
- **Target polygons** (e.g., districts, neighborhoods, grid cells) with
  known totals for at least one calibration variable.
- A need to **disaggregate** the source data into the target polygons,
  calibrated against the known totals.

The calibration step is what distinguishes IDW interpolation from naive
spatial allocation: the package finds per-zone decay parameters that minimize
the discrepancy between interpolated and observed totals.

## Preparing Your Data

Let us build a small synthetic example: 6 rectangular districts with known
population by two age groups, and 10 schools with enrollment counts by the
same groups plus a "budget" variable we want to interpolate.

```{r synthetic-data}
library(interpElections)
library(sf)

# -- Target zones: 6 rectangular districts in a 3x2 grid --
make_rect <- function(x0, y0, w = 1, h = 1) {
  st_polygon(list(matrix(c(
    x0, y0,
    x0 + w, y0,
    x0 + w, y0 + h,
    x0, y0 + h,
    x0, y0
  ), ncol = 2, byrow = TRUE)))
}

districts_sf <- st_sf(
  id = paste0("D", 1:6),
  pop_young = c(120, 200, 150, 180, 90, 160),
  pop_old   = c(80, 100, 130, 70, 110, 95),
  geometry  = st_sfc(
    make_rect(0, 0), make_rect(1, 0), make_rect(2, 0),
    make_rect(0, 1), make_rect(1, 1), make_rect(2, 1),
    crs = 4326
  )
)

# -- Source points: 10 schools scattered across the grid --
set.seed(42)
schools_sf <- st_sf(
  id = paste0("S", 1:10),
  enroll_young = c(55, 80, 45, 70, 60, 35, 90, 40, 65, 50),
  enroll_old   = c(30, 50, 40, 25, 45, 55, 35, 60, 20, 38),
  budget       = c(500, 800, 350, 620, 410, 290, 750, 380, 530, 440),
  geometry     = st_sfc(
    st_point(c(0.3, 0.2)), st_point(c(0.8, 0.4)),
    st_point(c(1.3, 0.3)), st_point(c(1.7, 0.8)),
    st_point(c(2.2, 0.5)), st_point(c(2.6, 0.7)),
    st_point(c(0.5, 1.3)), st_point(c(1.2, 1.6)),
    st_point(c(1.8, 1.2)), st_point(c(2.5, 1.5)),
    crs = 4326
  )
)

print(districts_sf)
print(schools_sf)
```

The key requirement is that the calibration columns must measure the **same
thing** in both layers. Here, `pop_young`/`pop_old` in districts and
`enroll_young`/`enroll_old` in schools both measure population counts by age
group. The `budget` column has no counterpart in districts -- it is the
variable we want to spatially disaggregate.

## The `interpolate_election()` Wrapper

`interpolate_election()` is the general-purpose wrapper (not specific to
Brazil). It accepts `sf` objects and handles matrix construction internally.

First, we build a simple Euclidean distance matrix. In a real application
you would use travel times (see Section 4.6), but distances work well for
demonstration:

```{r dist-matrix}
coords_zones <- st_coordinates(suppressWarnings(st_centroid(districts_sf)))
coords_pts   <- st_coordinates(schools_sf)
all_coords   <- rbind(coords_zones, coords_pts)
full_dist    <- as.matrix(dist(all_coords))
dist_matrix  <- full_dist[1:6, 7:16]

rownames(dist_matrix) <- districts_sf$id
colnames(dist_matrix) <- schools_sf$id
round(dist_matrix, 2)
```

Now call `interpolate_election()`:

```{r interp-election}
result <- interpolate_election(
  tracts_sf     = districts_sf,
  electoral_sf  = schools_sf,
  zone_id       = "id",
  point_id      = "id",
  calib_zones   = c("pop_young", "pop_old"),
  calib_sources = c("enroll_young", "enroll_old"),
  interp_sources = "budget",
  time_matrix   = dist_matrix
)

summary(result)
```

```{r plot-budget, echo=FALSE, fig.width=7, fig.height=5}
plot(result, "budget")
```

<details>
<summary>Show plot code</summary>

```{r, ref.label="plot-budget", eval=FALSE}
```

</details>

The result object contains the interpolated `sf` data frame, the optimized
alpha vector, and optimization diagnostics.

## Supplying a Pre-Computed Distance Matrix

The `time_matrix` parameter accepts any numeric matrix with dimensions
`n_zones x m_points`. Values must be positive (they represent distances or
travel times). The matrix can come from any source -- Euclidean distances,
network distances, travel times from Google Maps, or custom cost surfaces.

Requirements:

- Rows correspond to target zones (same order as `tracts_sf`).
- Columns correspond to source points (same order as `electoral_sf`).
- Values must be positive numeric (no NA, NaN, or Inf).

```{r matrix-inspect}
dim(dist_matrix)
head(dist_matrix)
```

## Step-by-Step with Core Functions

For maximum control, you can bypass the wrappers and call the core functions
directly. This section uses the bundled example data.

```{r load-bundled}
tt  <- readRDS(system.file("extdata/example_tt_matrix.rds",
                            package = "interpElections"))
pop <- readRDS(system.file("extdata/example_pop_matrix.rds",
                            package = "interpElections"))
src <- readRDS(system.file("extdata/example_source_matrix.rds",
                            package = "interpElections"))

cat("Travel time matrix:", nrow(tt), "zones x", ncol(tt), "sources\n")
cat("Population matrix: ", nrow(pop), "zones x", ncol(pop), "groups\n")
cat("Source matrix:     ", nrow(src), "sources x", ncol(src), "groups\n")
```

### Optimize alpha

`optimize_alpha()` finds per-zone decay parameters that minimize the squared
error between IDW-interpolated and observed population:

```{r optimize}
optim_result <- optimize_alpha(
  time_matrix   = tt,
  pop_matrix    = pop,
  source_matrix = src,
  use_gpu       = FALSE,
  verbose       = FALSE
)

optim_result
```

### Interpolate new data

Once you have the optimal alpha, you can interpolate any source-level data
into the target zones. The alpha vector is reusable across variables -- you
do not need to re-optimize for each one:

```{r interpolate}
# Simulate new data at the 8 source locations (3 variables)
set.seed(123)
new_data <- matrix(rpois(8 * 3, 200), nrow = 8, ncol = 3)
colnames(new_data) <- c("var_A", "var_B", "var_C")

interpolated <- idw_interpolate(tt, optim_result$alpha, new_data)
head(interpolated)
```

A key property of the column-standardized IDW weights is **total
conservation**: the column sums of the interpolated matrix equal the column
sums of the source data. This means no counts are created or destroyed
during interpolation.

```{r plot-conservation, echo=FALSE, fig.width=7, fig.height=5}
totals <- rbind(
  Source       = colSums(new_data),
  Interpolated = colSums(interpolated)
)
barplot(
  totals,
  beside = TRUE,
  legend.text = rownames(totals),
  args.legend = list(x = "topright"),
  main = "Total conservation: source vs. interpolated",
  ylab = "Total count",
  col = c("steelblue", "coral")
)
```

<details>
<summary>Show plot code</summary>

```{r, ref.label="plot-conservation", eval=FALSE}
```

</details>

## Computing Travel Times with r5r

For real-world applications, travel-time distances produce better results
than Euclidean distances because they account for road networks, terrain,
and barriers.

The package provides helpers for r5r-based travel-time computation:

```{r r5r-example, eval = FALSE}
# Download OSM road network for your study area
r5r_data <- download_r5r_data(
  area_sf    = my_study_area_sf,
  output_dir = "path/to/output"
)

# Compute travel-time matrix
tt_matrix <- compute_travel_times(
  zones_sf     = my_zones_sf,
  points_sf    = my_points_sf,
  network_path = r5r_data$output_dir,
  mode         = "WALK",
  max_trip_duration = 300
)
```

Available routing modes: `"WALK"`, `"BICYCLE"`, `"CAR"`. The
`fill_missing` parameter controls the value assigned to unreachable
origin-destination pairs (defaults to `max_trip_duration`).

The `download_r5r_data()` function downloads an OpenStreetMap extract for
your study area and clips it to the relevant bounding box. This requires
Java 21+ and the `osmium-tool` command-line utility. Run `check_r5r()` to
verify your setup.
