[{"path":"https://antrologos.github.io/interpElections/articles/get-started.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Get Started with interpElections","text":"interpElections interpolates data source points (polling stations, schools, hospitals) target polygons (census tracts, districts, neighborhoods) using travel-time-based inverse distance weighting Sinkhorn-balanced weights. decay parameter zone calibrated known demographic totals, ensuring source totals population proportions conserved. start, install optional dependencies:","code":"setup_torch()     # GPU optimization (CUDA, MPS, or CPU fallback) setup_java()      # Java 21+ for r5r travel-time routing setup_osmium()    # OSM data clipping (recommended)"},{"path":"https://antrologos.github.io/interpElections/articles/get-started.html","id":"example-1-varginha-mg","dir":"Articles","previous_headings":"","what":"Example 1: Varginha (MG)","title":"Get Started with interpElections","text":"simplest way use interpElections Brazilian data interpolate_election_br() wrapper. downloads census data, electoral results, road networks automatically. console output shows progress: Three lines downloaded data, computed travel times, optimized parameters, interpolated vote counts 279 census tracts.  Compare two candidates side side:","code":"result_vga <- interpolate_election_br(   \"Varginha\", year = 2022,   cargo = \"presidente\",   what = c(\"candidates\", \"turnout\"),   keep = c(\"weights\", \"sources_sf\") ) [1/9] Resolving municipality identifiers...   VARGINHA (MG) - IBGE: 3170701, TSE: 54135   Census year: 2022 (election 2022) [2/9] Preparing census population data... [3/9] Preparing census tract geometries... [4/9] Preparing electoral data... [5/9] Matching calibration brackets... [6/9] Downloading OSM road network... [7/9] Computing travel times... [8/9] Optimizing alpha...   PB-SGD (cpu, float32): ka=28, batch=279, sk_iter=15, 800 steps   Completed 800 steps (52.3s), objective=502,361 [9/9] Interpolating...   Interpolated 42 variables into 279 census tracts Done. result_vga interpElections result -- Brazilian election   Municipality: VARGINHA (MG)   IBGE: 3170701 | TSE: 54135 | Election: 2022 | Census: 2022   Census tracts: 279 | Sources: 37    Variables: 42     Candidates:    13 (CAND_30, CAND_44, CAND_12, CAND_13, ...)     Turnout:       1 (QT_COMPARECIMENTO)     Calibration:   28 (vot_hom_alf_18_19, vot_hom_alf_20_24, ...)    Optimizer: pb_sgd_sinkhorn_cpu (obj = 502361.44)   Alpha:     [0.010, 20.000] (mean 3.027)    Contents:     result$tracts_sf       sf with census tracts + interpolated columns     result$interpolated    numeric matrix [279 x 42]     ... plot(result_vga, variable = \"Lula\") plot(result_vga, variable = c(\"Lula\", \"Bolsonaro\"), type = \"pct_tract\")"},{"path":"https://antrologos.github.io/interpElections/articles/get-started.html","id":"example-2-igrejinha-rs","dir":"Articles","previous_headings":"","what":"Example 2: Igrejinha (RS)","title":"Get Started with interpElections","text":"smaller city, workflow:  Different city, different spatial patterns, three-line workflow.","code":"result_igr <- interpolate_election_br(   \"Igrejinha\", year = 2022,   cargo = \"presidente\",   what = c(\"candidates\", \"turnout\") ) result_igr interpElections result -- Brazilian election   Municipality: IGREJINHA (RS)   IBGE: 4310108 | TSE: 87033 | Election: 2022 | Census: 2022   Census tracts: 85 | Sources: 17    Variables: 42     Candidates:    13 (CAND_13, CAND_12, CAND_30, CAND_22, ...)     Turnout:       1 (QT_COMPARECIMENTO)     Calibration:   28 (vot_hom_alf_18_19, vot_hom_alf_20_24, ...)    Optimizer: pb_sgd_sinkhorn_cpu (obj = 248107.37)   Alpha:     [0.010, 15.682] (mean 4.089) plot(result_igr, variable = \"Lula\")"},{"path":"https://antrologos.github.io/interpElections/articles/get-started.html","id":"exploring-the-results","dir":"Articles","previous_headings":"","what":"Exploring the Results","title":"Get Started with interpElections","text":"result object several S3 methods inspection: See vignette(\"working--results\") full reference S3 methods, plot types, residual analysis, areal aggregation.","code":"# Detailed summary with per-variable statistics summary(result_vga)  # Alpha decay parameters (one per tract) head(coef(result_vga))  # Export as plain data frame (drops geometry) df <- as.data.frame(result_vga) head(df[, 1:5])  # Interactive map (opens in browser) plot_interactive(result_vga, variable = \"Lula\")"},{"path":"https://antrologos.github.io/interpElections/articles/get-started.html","id":"controlling-what-gets-interpolated","dir":"Articles","previous_headings":"","what":"Controlling What Gets Interpolated","title":"Get Started with interpElections","text":"parameter controls variables interpolated: Filter specific candidates parties: useful parameters: cargo: \"presidente\", \"governador\", \"senador\", \"deputado_federal\", \"deputado_estadual\", \"prefeito\", \"vereador\" turno: 1 (first round, default) 2 (runoff) census_year: auto-selected election year, override manually data(muni_crosswalk): lookup table 5,710 municipalities","code":"# Just candidates (default) result <- interpolate_election_br(\"Varginha\", year = 2022,   what = \"candidates\")  # Parties (aggregated by party abbreviation) result <- interpolate_election_br(\"Varginha\", year = 2022,   what = \"parties\")  # Turnout and abstention result <- interpolate_election_br(\"Varginha\", year = 2022,   what = \"turnout\")  # Voter demographics (gender, education) result <- interpolate_election_br(\"Varginha\", year = 2022,   what = \"demographics\")  # Everything at once result <- interpolate_election_br(\"Varginha\", year = 2022,   what = c(\"candidates\", \"parties\", \"turnout\", \"demographics\")) # By ballot number result <- interpolate_election_br(\"Varginha\", year = 2022,   cargo = \"presidente\", candidates = c(13, 22))  # By name (accent-insensitive substring matching) result <- interpolate_election_br(\"Varginha\", year = 2022,   cargo = \"presidente\", candidates = \"LULA\")  # Specific parties result <- interpolate_election_br(\"Varginha\", year = 2022,   what = \"parties\", parties = c(\"PT\", \"PL\"))"},{"path":"https://antrologos.github.io/interpElections/articles/get-started.html","id":"whats-happening-under-the-hood","dir":"Articles","previous_headings":"","what":"What’s Happening Under the Hood","title":"Get Started with interpElections","text":"wrapper interpolate_election_br() calls steps sequence: See vignette(\"methodology\") full technical treatment equations, visualizations, worked examples using real data.","code":"# 1. Census population by age bracket pop_data <- br_prepare_population(\"Varginha\", year = 2022)  # 2. Census tract geometries with population columns tracts_sf <- br_prepare_tracts(3170701, pop_data)  # 3. Electoral data at polling stations electoral <- br_prepare_electoral(   code_muni_ibge = \"3170701\", code_muni_tse = \"54135\",   uf = \"MG\", year = 2022, cargo = \"presidente\",   what = c(\"candidates\", \"turnout\") )  # 4. Travel times via r5r walking routes time_matrix <- compute_travel_times(tracts_sf, electoral_sf)  # 5. Optimize per-tract decay parameters optim_result <- optimize_alpha(time_matrix, pop_matrix, source_matrix)  # 6. Build Sinkhorn-balanced weight matrix and interpolate W <- sinkhorn_weights(time_matrix, optim_result$alpha,   row_targets = pop_total / sum(pop_total) * ncol(time_matrix),   pop_matrix = pop_matrix, source_matrix = source_matrix) interpolated <- W %*% electoral_data"},{"path":"https://antrologos.github.io/interpElections/articles/get-started.html","id":"custom-data-any-point-to-polygon-problem","dir":"Articles","previous_headings":"","what":"Custom Data: Any Point-to-Polygon Problem","title":"Get Started with interpElections","text":"interpElections works point--polygon disaggregation, just Brazilian elections. synthetic example: Conservation: interpolated total matches source total exactly.","code":"library(interpElections)  # Synthetic data: 5 zones, 3 sources, 2 calibration variables set.seed(42) tt <- matrix(   c(5, 15, 30, 25, 40,     20, 8, 12, 35, 45,     35, 30, 18, 10, 7),   nrow = 5, ncol = 3,   dimnames = list(paste0(\"zone_\", 1:5), paste0(\"src_\", 1:3)) )  # Calibration: population counts known at both levels pop_matrix <- matrix(   c(100, 300, 150, 200, 250,   # young population per zone     80, 250, 120, 180, 220),   # old population per zone   nrow = 5, ncol = 2,   dimnames = list(NULL, c(\"pop_young\", \"pop_old\")) )  source_matrix <- matrix(   c(250, 400, 350,    # young counts at sources     210, 350, 290),   # old counts at sources   nrow = 3, ncol = 2,   dimnames = list(NULL, c(\"count_young\", \"count_old\")) )  # Optimize alpha (uses per-bracket SGD) optim_result <- optimize_alpha(   time_matrix = tt + 1,   # offset already applied   pop_matrix = pop_matrix,   source_matrix = source_matrix,   offset = 0,             # offset already in tt   verbose = FALSE )  cat(\"Optimized alpha:\", round(optim_result$alpha, 2), \"\\n\")  # Build balanced weights and interpolate pop_total <- rowSums(pop_matrix) row_targets <- pop_total / sum(pop_total) * ncol(tt) W <- sinkhorn_weights(tt + 1, optim_result$alpha, offset = 0,                        row_targets = row_targets,                        pop_matrix = pop_matrix,                        source_matrix = source_matrix)  # Interpolate a variable measured at sources revenue <- c(5000, 8000, 6500) interpolated_revenue <- as.numeric(W %*% revenue)  cat(\"Source total:\", sum(revenue), \"\\n\") cat(\"Interpolated total:\", round(sum(interpolated_revenue)), \"\\n\") cat(\"Per-zone:\", round(interpolated_revenue), \"\\n\")"},{"path":"https://antrologos.github.io/interpElections/articles/get-started.html","id":"core-functions-maximum-flexibility","dir":"Articles","previous_headings":"","what":"Core Functions: Maximum Flexibility","title":"Get Started with interpElections","text":"full control, use core functions directly:","code":"# Load bundled example data tt  <- readRDS(system.file(\"extdata/example_tt_matrix.rds\",                             package = \"interpElections\")) pop <- readRDS(system.file(\"extdata/example_pop_matrix.rds\",                             package = \"interpElections\")) src <- readRDS(system.file(\"extdata/example_source_matrix.rds\",                             package = \"interpElections\"))  # Optimize result <- optimize_alpha(tt, pop, src, verbose = FALSE) result  # Build final weight matrix with full Sinkhorn convergence pop_total <- rowSums(pop) row_targets <- pop_total / sum(pop_total) * ncol(tt) W <- sinkhorn_weights(tt, result$alpha, offset = 1,                        row_targets = row_targets,                        pop_matrix = pop, source_matrix = src)  # Verify conservation cat(\"Column sums (should be ~1):\", round(colSums(W), 4), \"\\n\") cat(\"Row sum range:\", round(range(rowSums(W)), 4), \"\\n\")"},{"path":"https://antrologos.github.io/interpElections/articles/get-started.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next Steps","title":"Get Started with interpElections","text":"vignette(\"methodology\"): full pipeline walkthrough equations, visualizations, real-data examples Varginha (MG) vignette(\"working--results\"): S3 methods, plot types, residual analysis, areal aggregation Niteroi Belo Horizonte examples","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"why-sub-municipal-electoral-geography-matters","dir":"Articles","previous_headings":"Part I: Motivation and Pipeline Overview","what":"1. Why Sub-Municipal Electoral Geography Matters","title":"Methodology","text":"Electoral analysis Brazil faces fundamental data gap. Votes counted polling stations — points map, geographic zones. Superior Electoral Court (TSE) publishes detailed results per station: many votes candidate received, turnout statistics, age gender composition registered voters. polling stations defined geographic boundaries. voter lives tract walks past tract B may vote station located tract C. Meanwhile, Census Bureau (IBGE) organizes demographic data census tracts — small geographic polygons known population counts age, gender, education, income. tracts finest spatial unit demographic data available. question : neighborhood vote? answer , need bridge two incompatible data systems: point-level electoral data polygon-level census data. package .","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"age-structure-as-a-proxy-for-socioeconomic-status","dir":"Articles","previous_headings":"Part I: Motivation and Pipeline Overview > 1. Why Sub-Municipal Electoral Geography Matters","what":"Age structure as a proxy for socioeconomic status","title":"Methodology","text":"bridge two systems age structure population. Age brackets observed levels: census records many people age live tract, TSE records many voters age voted station. age structure useful? encodes far just demographics. Brazilian cities, age composition neighborhood strongly correlated socioeconomic profile. Consider two neighborhoods Rio de Janeiro:  Rocinha, one Brazil’s largest favelas, young population: large cohorts 18–29 age range, tapering sharply 50. Copacabana, one Rio’s wealthiest neighborhoods, shows opposite pattern: narrower base young adults large proportion residents 50. difference reflects fertility rates, life expectancy, migration patterns tightly linked income, education, living conditions. age signatures differ systematically across neighborhoods, carry information socioeconomic composition — , extension, voting behavior. method describe exploits : finds weights reproduce census age structure tract applied station-level voter data. weights correct demographics, also produce good estimates vote counts.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"the-problem-many-to-many-spatial-disaggregation","dir":"Articles","previous_headings":"Part I: Motivation and Pipeline Overview","what":"2. The Problem: Many-to-Many Spatial Disaggregation","title":"Methodology","text":"Imagine researcher wants know Copacabana voted 2022 presidential election. TSE can tell polling station area voted. several things make harder seems: One station, many neighborhoods: school Botafogo may receive voters Botafogo, Laranjeiras, even Santa Marta favela hill. station’s vote total mix populations. One neighborhood, many stations: Copacabana voters may assigned polling stations Copacabana , neighboring Ipanema, Leme. neighborhood’s voters split across multiple stations. lookup table: unlike countries, official mapping residential addresses polling stations. relationship many--many, administrative data resolve . standard areal interpolation problem. areal interpolation, source target polygons, overlap area provides natural weights. , sources points (stations), polygons. Area-weighted interpolation apply. simple point--polygon assignment: since mapping many--many, assigning tract nearest station (Voronoi) lose information produce poor estimates (demonstrate Section 17).","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"the-approach-estimating-the-association-structure","dir":"Articles","previous_headings":"Part I: Motivation and Pipeline Overview > 2. The Problem: Many-to-Many Spatial Disaggregation","what":"The approach: estimating the association structure","title":"Methodology","text":"solution estimates association structure tracts stations — weight matrix WW dimension [N×M][N \\times M] entry WijW_{ij} captures much station jj “serves” tract ii. Two fundamental properties enforced: Source conservation (column constraint): station distributes exactly 100% data. total votes municipality preserved exactly: ∑iWij=1\\sum_i W_{ij} = 1 jj. Population proportionality (row constraint): tract receives total weight proportional population share: ∑jWij∝popi\\sum_j W_{ij} \\propto \\text{pop}_i. method assume fixed assignment voters stations. Instead, estimates smooth probabilistic mapping, calibrated known demographic data.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"walking-to-vote-a-behavioral-assumption","dir":"Articles","previous_headings":"Part I: Motivation and Pipeline Overview > 2. The Problem: Many-to-Many Spatial Disaggregation","what":"Walking to vote: a behavioral assumption","title":"Methodology","text":"key behavioral assumption voters walk polling stations. grounds spatial model: closer stations receive weight voters likely walk . assumption supported empirical evidence. Pereira et al. (2023) studied effect free public transit election day Brazilian cities, finding increased turnout — implying transportation costs (including walking distance) meaningful barrier. Brazilian electoral law requires voters assigned polling stations near registered address, reinforcing spatial proximity assumption. Pereira, R. H. M., Braga, C. K. V., Serra, B., & Nadalin, V. (2023). “Free public transit voter turnout.” Available : https://www.urbandemographics.org/files/2023_Pereira_et_al_free_public_transit_voter_turnout.pdf second important assumption voters reside municipality registered vote, municipality captured census. residential assumption allows us use census population data target distribution: age structure voters polling station reflect age structure surrounding population. Without assumption, calibration step valid. use realistic walking travel times computed OpenStreetMap road network, straight-line distances. Mountains, rivers, street layout affect actual travel time captured routing engine (see Section 9).","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"pipeline-overview","dir":"Articles","previous_headings":"Part I: Motivation and Pipeline Overview","what":"3. Pipeline Overview","title":"Methodology","text":"full interpolation pipeline six steps: Census data: population counts age bracket per tract (br_prepare_population()) Tract geometries: census tract polygons IBGE (br_prepare_tracts()) Electoral data: votes, turnout, voter demographics per station (br_prepare_electoral()) Travel times: walking routes tract representative points stations (compute_travel_times()) Optimization: find per-tract decay parameters α\\alpha minimize demographic mismatch (optimize_alpha()) Interpolation: build per-bracket Sinkhorn weight matrix (sinkhorn_weights()) apply station-level variable (X̂=W×V\\hat{X} = W \\times V) convenience function interpolate_election_br() wraps six steps single call Brazilian municipalities, handling data downloads, geocoding, default parameter selection automatically.  figure illustrates spatial data layers involved. Starting bottom: municipality boundary, census tracts colored population, polling station locations, final interpolated results tract level.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"census-population-data","dir":"Articles","previous_headings":"Part II: Data","what":"4. Census Population Data","title":"Methodology","text":"data frame also includes 28 calibration columns (pop_hom_alf_18_19, pop_hom_nalf_18_19, …, pop_mul_nalf_60_69) cross gender × literacy × 7 age brackets. calibration variables bridge census tracts polling stations. 7 brackets built. TSE voter profile data records voters 12 finer age bins (18, 19, 20, 21–24, 25–29, 30–34, 35–39, 40–44, 45–49, 50–54, 55–59, 60–64, 65–69). br_prepare_electoral() aggregates 7 groups align census age brackets. 2022 Census — reports 15–19 group instead 18–20 — package applies 2/52/5 proxy approximate 18–19 voting-age share. 7 matched brackets key insight: observed levels (census tracts polling stations), enabling calibration. package also supports full calibration calib_type = \"full\", crosses gender (male/female) × literacy (literate/illiterate) × 7 age groups produce 28 calibration columns. provides stronger spatial signal optimizer must simultaneously match spatial distribution subgroup. Full calibration default interpolate_election_br().","code":"pop_data <- br_prepare_population(\"3170701\", year = 2022) head(pop_data[, 1:10]) code_tract    code_muni pop_00_04 pop_05_09 pop_10_14 pop_15_19 pop_20_24 pop_25_29 pop_30_39 pop_40_49 1 3170701xxxxx  3170701      68        68        62        88        68        58       144       129 2 3170701xxxxx  3170701      37        36        47        38        47        44        83        95 ..."},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"census-tract-geometries","dir":"Articles","previous_headings":"Part II: Data","what":"5. Census Tract Geometries","title":"Methodology","text":"downloads tract geometries geobr, removes green areas (parks, water bodies zero population), transforms EPSG:5880 (equal-area projection accurate spatial operations), joins population columns.  Note urban-rural gradient: small, densely populated tracts city center; large, sparsely populated tracts periphery.","code":"tracts_sf <- br_prepare_tracts(3170701, pop_data)"},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"electoral-data-at-polling-stations","dir":"Articles","previous_headings":"Part II: Data","what":"6. Electoral Data at Polling Stations","title":"Methodology","text":"result contains one row per polling station : Vote columns (CAND_13, CAND_22, …): votes per candidate (ballot number suffix; 95 = blank, 96 = null) Turnout (QT_COMPARECIMENTO): total voters showed Voter age profiles (votantes_18_20, …, votantes_65_69): TSE’s fine-grained age registration brackets, aggregated match 7 census brackets Coordinates (lat, long): geocoded polling station locations Column dictionary: attr(electoral, \"column_dictionary\") contains metadata column (type, cargo, candidate name, party) parameter controls gets included: \"candidates\": one column per candidate \"parties\": aggregated party (PARTY_PT, PARTY_PL, …) \"turnout\": QT_COMPARECIMENTO, QT_APTOS, QT_ABSTENCOES \"demographics\": GENERO_* EDUC_* columns","code":"electoral <- br_prepare_electoral(   code_muni_ibge = \"3170701\",   code_muni_tse  = \"54135\",   uf = \"MG\", year = 2022,   cargo = \"presidente\", turno = 1,   what = c(\"candidates\", \"turnout\") )"},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"calibration-variables-comparing-source-and-target","dir":"Articles","previous_headings":"Part II: Data","what":"7. Calibration Variables: Comparing Source and Target","title":"Methodology","text":"calibration variables bridge census tracts polling stations. age brackets observed levels: Census: “many people aged 18–20 live tract?” (IBGE) Electoral: “many registered voters aged 18–20 voted station?” (TSE) age brackets saw distinguishing Rocinha Copacabana Section 1. demographic signature varies across neighborhoods precisely method uses calibrate weights.  shapes similar totals differ: census counts residents, TSE counts registered voters. everyone voting age registered, registration rates vary age bracket. optimization finds alpha values interpolated voter age profiles match census age profiles tract. weights correct demographics, also correct vote counts.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"representative-points-from-tracts-to-routable-origins","dir":"Articles","previous_headings":"Part III: Geography","what":"8. Representative Points: From Tracts to Routable Origins","title":"Methodology","text":"Routing engines need point--point queries, tracts polygons. need single representative point per tract. Three methods available: choice representative point matters large, irregularly shaped tracts rural peri-urban areas. Consider southern periphery São Paulo, census tracts extend several square kilometers mixed urban forested land:  three-panel comparison shows set large tracts south São Paulo. red dots (centroids) frequently fall uninhabited areas — middle Mata Atlântica forest empty fields. blue dots (point surface) guaranteed inside polygon, may still far people actually live. green dots (pop-weighted) use WorldPop population raster find densely populated cell within tract, placing representative point residents actually .  Zooming largest tract, centroid falls dense forest pop-weighted point correctly identifies settlement area. difference can affect travel time calculations tens minutes. pop_weighted method downloads WorldPop Brazil Constrained 2020 raster (~48 MB, cached) finds raster cell highest population density within tract. pop_min_area parameter (default: 1 km²) controls threshold: tracts smaller use point_on_surface regardless chosen method, since small urban tracts dense enough interior point reasonable proxy.","code":"pts_pos <- compute_representative_points(tracts_sf,   method = \"point_on_surface\") pts_pop <- compute_representative_points(tracts_sf,   method = \"pop_weighted\")"},{"path":[]},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"why-walking-travel-time","dir":"Articles","previous_headings":"Part III: Geography > 9. Travel Times: Building the Distance Matrix","what":"9.1 Why walking travel time?","title":"Methodology","text":"Brazil, voters assigned polling stations near registered address. election day, voters walk polling station. merely assumption convenience — grounded geographic design Brazilian electoral system empirical evidence. Pereira et al. (2023) studied introduction free public transit election days Brazilian cities. finding free transit significantly increased turnout implies cost getting polls — primarily walking distance — real barrier affects participation. distance matters whether people vote , certainly matters vote. therefore use realistic walking travel times computed OpenStreetMap road network, Euclidean (straight-line) distances. routing engine (r5r) accounts actual street layout, elevation, one-way streets, pedestrian paths, physical barriers.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"euclidean-distance-vs--walking-routes","dir":"Articles","previous_headings":"Part III: Geography > 9. Travel Times: Building the Distance Matrix","what":"9.2 Euclidean distance vs. walking routes","title":"Methodology","text":"just use straight-line distance? geography creates dramatic discrepancies Euclidean distance actual walking time. Two examples: Example 1: Mountain barrier (Rio de Janeiro) point Botafogo neighborhood lies base Corcovado/Sumaré hills. polling station Laranjeiras sits side. straight line, distance modest — walking route must navigate around steep terrain:  solid blue line shows actual walking route computed r5r OSM road network. dotted red line shows straight-line distance. mountainous terrain, can differ factor 3–5x. Example 2: Water barrier (Recife) point Boa Vista neighborhood destination Brasília Teimosa peninsula separated Recife’s waterways. walking route must navigate around estuary cross bridges, adding significant distance compared straight line.  Example 3: Water barrier (Florianópolis) Florianópolis, capital Santa Catarina, split mainland island Atlantic. point Coqueiros (mainland) destination Costeira Pirajubaé (island) separated bay. walking route must detour one bridges connecting two sides:  examples illustrate Euclidean distance poor proxy actual accessibility — routing engine matters.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"building-the-travel-time-matrix","dir":"Articles","previous_headings":"Part III: Geography > 9. Travel Times: Building the Distance Matrix","what":"9.3 Building the travel time matrix","title":"Methodology","text":"builds [N tracts × M stations] matrix walking travel times minutes, using r5r routing engine OpenStreetMap data. Origins: representative points (Section 8) Destinations: polling station coordinates Mode: walking (default), configurable Max trip duration: 300 minutes; unreachable pairs get value OSM data downloaded via download_r5r_data(), fetches state-level .pbf files clips municipality bounding box using osmium.  heatmap shows spatial structure: block-diagonal pattern nearby tract-station pairs short travel times.  Tracts center short travel times nearest station; peripheral tracts farther away. offset: applying IDW kernel, add 1 travel times (time_matrix + 1) avoid singularity t=0t = 0.","code":"time_matrix <- compute_travel_times(   tracts_sf = tracts_sf,   points_sf = electoral_sf,   network_path = network_path,   tract_id = \"id\",   point_id = \"id\" )"},{"path":[]},{"path":[]},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"intuition-gravitational-pull","dir":"Articles","previous_headings":"Part IV: The Weight Matrix > 10. The IDW Kernel: Turning Distance into Influence","what":"Intuition: gravitational pull","title":"Methodology","text":"Think polling station exerting “gravitational pull” nearby tracts. Closer stations pull harder. IDW (Inverse Distance Weighting) kernel translates intuition numbers: given travel time tract station, produces weight decreases distance.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"a-concrete-example","dir":"Articles","previous_headings":"Part IV: The Weight Matrix > 10. The IDW Kernel: Turning Distance into Influence","what":"A concrete example","title":"Methodology","text":"Suppose tract three nearby stations 5, 12, 30 minutes walking distance. much station contribute tract’s estimate? decay parameter α=2\\alpha = 2: nearest station (5 min) gets lion’s share weight. 30-minute station contributes little.","code":"tt <- c(5, 12, 30)  # travel times in minutes alpha <- 2 raw_weights <- (tt + 1)^(-alpha) normalized <- raw_weights / sum(raw_weights) cat(\"Travel times:\", tt, \"minutes\\n\") #> Travel times: 5 12 30 minutes cat(\"Raw weights: \", round(raw_weights, 5), \"\\n\") #> Raw weights:  0.02778 0.00592 0.00104 cat(\"Normalized:  \", round(normalized, 3), \"\\n\") #> Normalized:   0.8 0.17 0.03 cat(\"The 5-min station gets\", round(normalized[1] * 100),     \"% of this tract's weight\\n\") #> The 5-min station gets 80 % of this tract's weight"},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"the-formula","dir":"Articles","previous_headings":"Part IV: The Weight Matrix > 10. The IDW Kernel: Turning Distance into Influence","what":"The formula","title":"Methodology","text":"raw weight tract ii station jj: Wijraw=(tij+1)−αiW^{\\text{raw}}_{ij} = (t_{ij} + 1)^{-\\alpha_i} : tijt_{ij}: travel time tract ii station jj (minutes) αi\\alpha_i: decay parameter tract ii (optimized)","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"how-alpha-controls-the-decay","dir":"Articles","previous_headings":"Part IV: The Weight Matrix > 10. The IDW Kernel: Turning Distance into Influence","what":"How alpha controls the decay","title":"Methodology","text":"α=0.5\\alpha = 0.5: nearly flat — stations contribute almost equally α=2\\alpha = 2: moderate — stations within 10 minutes dominate α=10\\alpha = 10: steep cliff — nearest station matters","code":"tt_range <- 0:60 alphas <- c(0.5, 1, 2, 5, 10) decay_df <- do.call(rbind, lapply(alphas, function(a) {   data.frame(time = tt_range, weight = (tt_range + 1)^(-a),              alpha = paste0(\"alpha = \", a)) })) decay_df$alpha <- factor(decay_df$alpha,                           levels = paste0(\"alpha = \", alphas))  library(ggplot2) ggplot(decay_df, aes(x = time, y = weight, color = alpha)) +   geom_line(linewidth = 0.8) +   scale_y_log10() +   labs(title = \"Weight Decay Curves\",        subtitle = \"Higher alpha = steeper decay = more concentrated weights\",        x = \"Travel time (minutes)\", y = \"Weight (log scale)\",        color = \"\") +   theme_minimal() +   theme(plot.title = element_text(face = \"bold\"),         legend.position = \"right\")"},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"why-per-tract-alpha","dir":"Articles","previous_headings":"Part IV: The Weight Matrix > 10. The IDW Kernel: Turning Distance into Influence","what":"Why per-tract alpha?","title":"Methodology","text":"single global α\\alpha capture heterogeneity urban geography. Urban centers many overlapping station catchments — tracts need low α\\alpha spread weight across several stations. Isolated peripheral tracts one nearby station need high α\\alpha concentrate weight. optimizer finds best α\\alpha tract independently.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"why-single-sided-standardization-fails","dir":"Articles","previous_headings":"Part IV: The Weight Matrix","what":"11. Why Single-Sided Standardization Fails","title":"Methodology","text":"introducing Sinkhorn algorithm, let us understand simpler approaches work. need normalize raw weight matrix weights sum meaningful quantities. two natural choices — fail .","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"column-only-standardization","dir":"Articles","previous_headings":"Part IV: The Weight Matrix > 11. Why Single-Sided Standardization Fails","what":"11.1 Column-only standardization","title":"Methodology","text":"first approach: divide column sum station distributes 100% data: Wijcol=Wijraw∑iWijrawW^{\\text{col}}_{ij} = \\frac{W^{\\text{raw}}_{ij}}{\\sum_i W^{\\text{raw}}_{ij}} Column sums = 1 (source conservation: every vote distributed exactly ). constraint row sums. Tract 1 10% population receives disproportionate share close station 1. Municipal totals preserved, distribution across tracts wrong.","code":"# Toy example: 5 tracts, 3 stations tt_toy <- matrix(   c(2,  10, 25, 30, 50,   # station 1: close to tract 1     15,  3, 12, 28, 45,   # station 2: close to tract 2     40, 35, 20,  5,  8),  # station 3: close to tracts 4-5   nrow = 5, ncol = 3 ) pop_toy <- c(100, 300, 150, 200, 250)  # population per tract  alpha_toy <- rep(2, 5) W_raw <- (tt_toy + 1)^(-alpha_toy)  # Column standardize W_col <- t(t(W_raw) / colSums(W_raw))  cat(\"Column sums (should be 1 — OK):\\n\") #> Column sums (should be 1 — OK): round(colSums(W_col), 4) #> [1] 1 1 1  cat(\"\\nRow sums (uncontrolled — BAD):\\n\") #>  #> Row sums (uncontrolled — BAD): round(rowSums(W_col), 4) #> [1] 0.9751 0.9300 0.1439 0.6594 0.2917  cat(\"\\nPopulation shares (what rows should look like):\\n\") #>  #> Population shares (what rows should look like): round(pop_toy / sum(pop_toy) * 3, 4) #> [1] 0.30 0.90 0.45 0.60 0.75"},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"row-only-standardization","dir":"Articles","previous_headings":"Part IV: The Weight Matrix > 11. Why Single-Sided Standardization Fails","what":"11.2 Row-only standardization","title":"Methodology","text":"opposite approach: normalize rows match population shares. Now rows correct, column sums wrong. stations “distribute” 100% votes, others less 100%. municipal total longer conserved: multiply weights vote counts, get (fewer) total votes actually existed.","code":"# Row standardize to population-proportional targets m <- ncol(tt_toy) row_targets_toy <- pop_toy / sum(pop_toy) * m  W_row <- W_raw * (row_targets_toy / rowSums(W_raw))  cat(\"Row sums (should match population targets — OK):\\n\") #> Row sums (should match population targets — OK): round(rowSums(W_row), 4) #> [1] 0.30 0.90 0.45 0.60 0.75  cat(\"\\nColumn sums (should be 1 — BAD):\\n\") #>  #> Column sums (should be 1 — BAD): round(colSums(W_row), 4) #> [1] 0.5038 1.1226 1.3736"},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"the-dilemma","dir":"Articles","previous_headings":"Part IV: The Weight Matrix > 11. Why Single-Sided Standardization Fails","what":"The dilemma","title":"Methodology","text":"Column-: preserves totals distributes incorrectly Row-: distributes correctly preserve totals need constraints simultaneously.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"the-idea-balancing-a-table","dir":"Articles","previous_headings":"Part IV: The Weight Matrix > 12. Sinkhorn Balancing: Double Conservation","what":"12.1 The idea: balancing a table","title":"Methodology","text":"Imagine table estimated phone calls 5 cities. cell contains best guess many calls go city ii city jj. also know total calls city (row totals) total calls city (column totals) telephone billing records. initial estimates don’t match known totals. want adjust table : row sums known row total column sums known column total relative pattern within row column preserved (city calls city B twice much city C, ratio maintained) exactly Iterative Proportional Fitting (IPF) . alternates scaling rows match row totals scaling columns match column totals. rounds, sets totals satisfied simultaneously. context: table weight matrix WW (tracts × stations) Row totals population-proportional targets (ri=popi/∑pop×mr_i = \\text{pop}_i / \\sum \\text{pop} \\times m) Column totals 1 (station distributes 100%) initial pattern comes IDW kernel (travel-time-based weights)","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"historical-context-from-demography-to-optimal-transport","dir":"Articles","previous_headings":"Part IV: The Weight Matrix > 12. Sinkhorn Balancing: Double Conservation","what":"12.2 Historical context: from demography to optimal transport","title":"Methodology","text":"idea alternating row column normalization discovered independently several fields, giving different name: Iterative Proportional Fitting (IPF): Deming & Stephan (1940) introduced adjusting census contingency tables match known marginal totals — directly related application. RAS method: economists use update input-output tables row column totals available new period. Matrix balancing: transportation planners apply trip distribution — fitting origin-destination matrix known trip generation attraction totals. Sinkhorn-Knopp algorithm: Richard Sinkhorn (1964) proved key convergence result: matrix positive entries can made doubly stochastic procedure. result later extended rectangular matrices arbitrary prescribed marginals. Optimal transport: machine learning literature, Sinkhorn algorithm standard method computing entropy- regularized optimal transport (Cuturi, 2013). describe procedure: alternate row column normalization marginal constraints satisfied. convergence guaranteed sum(row_targets) = sum(col_targets), balanced matrix unique.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"step-by-step-worked-example","dir":"Articles","previous_headings":"Part IV: The Weight Matrix > 12. Sinkhorn Balancing: Double Conservation","what":"12.3 Step-by-step worked example","title":"Methodology","text":"Let us trace algorithm hand small example. 3×3 raw weight matrix want achieve specific row column sums: just 2 iterations, row column sums close targets. relative pattern within row preserved: tract 1 still gets weight station 1, tract 3 station 3. absolute values adjusted population source constraints satisfied.","code":"# Small 3x3 example for hand-tracing W_ex <- matrix(c(   0.8, 0.1, 0.05,  # tract 1: near station 1   0.3, 0.6, 0.1,   # tract 2: near station 2   0.05, 0.2, 0.9   # tract 3: near station 3 ), nrow = 3, byrow = TRUE)  row_targets_ex <- c(1.5, 0.9, 0.6)  # population-proportional col_targets_ex <- c(1, 1, 1)        # source conservation  cat(\"=== Initial matrix ===\\n\") #> === Initial matrix === print(round(W_ex, 3)) #>      [,1] [,2] [,3] #> [1,] 0.80  0.1 0.05 #> [2,] 0.30  0.6 0.10 #> [3,] 0.05  0.2 0.90 cat(\"Row sums:\", round(rowSums(W_ex), 3), \"\\n\") #> Row sums: 0.95 1 1.15 cat(\"Targets: \", row_targets_ex, \"\\n\") #> Targets:  1.5 0.9 0.6  # --- Iteration 1: Row scaling --- cat(\"\\n=== Iteration 1: Scale rows ===\\n\") #>  #> === Iteration 1: Scale rows === row_factors <- row_targets_ex / rowSums(W_ex) cat(\"Row scale factors:\", round(row_factors, 3), \"\\n\") #> Row scale factors: 1.579 0.9 0.522 W_ex <- W_ex * row_factors  # multiply each row cat(\"After row scaling:\\n\") #> After row scaling: print(round(W_ex, 3)) #>       [,1]  [,2]  [,3] #> [1,] 1.263 0.158 0.079 #> [2,] 0.270 0.540 0.090 #> [3,] 0.026 0.104 0.470 cat(\"Row sums now:\", round(rowSums(W_ex), 3), \"(match targets)\\n\") #> Row sums now: 1.5 0.9 0.6 (match targets) cat(\"Col sums now:\", round(colSums(W_ex), 3), \"(not yet 1)\\n\") #> Col sums now: 1.559 0.802 0.639 (not yet 1)  # --- Iteration 1: Column scaling --- cat(\"\\n=== Iteration 1: Scale columns ===\\n\") #>  #> === Iteration 1: Scale columns === col_factors <- col_targets_ex / colSums(W_ex) cat(\"Col scale factors:\", round(col_factors, 3), \"\\n\") #> Col scale factors: 0.641 1.247 1.566 W_ex <- t(t(W_ex) * col_factors) cat(\"After column scaling:\\n\") #> After column scaling: print(round(W_ex, 3)) #>       [,1]  [,2]  [,3] #> [1,] 0.810 0.197 0.124 #> [2,] 0.173 0.673 0.141 #> [3,] 0.017 0.130 0.735 cat(\"Row sums now:\", round(rowSums(W_ex), 3), \"(shifted slightly)\\n\") #> Row sums now: 1.131 0.987 0.882 (shifted slightly) cat(\"Col sums now:\", round(colSums(W_ex), 3), \"(match targets)\\n\") #> Col sums now: 1 1 1 (match targets)  # --- Iteration 2 --- cat(\"\\n=== Iteration 2: Scale rows again ===\\n\") #>  #> === Iteration 2: Scale rows again === row_factors <- row_targets_ex / rowSums(W_ex) W_ex <- W_ex * row_factors col_factors <- col_targets_ex / colSums(W_ex) W_ex <- t(t(W_ex) * col_factors) cat(\"After iteration 2:\\n\") #> After iteration 2: print(round(W_ex, 3)) #>       [,1]  [,2]  [,3] #> [1,] 0.864 0.271 0.207 #> [2,] 0.127 0.637 0.162 #> [3,] 0.009 0.092 0.631 cat(\"Row sums:\", round(rowSums(W_ex), 4), \"\\n\") #> Row sums: 1.342 0.9261 0.7319 cat(\"Col sums:\", round(colSums(W_ex), 4), \"\\n\") #> Col sums: 1 1 1 cat(\"Max error:\", round(max(   abs(rowSums(W_ex) - row_targets_ex),   abs(colSums(W_ex) - col_targets_ex) ), 6), \"\\n\") #> Max error: 0.157996"},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"convergence","dir":"Articles","previous_headings":"Part IV: The Weight Matrix > 12. Sinkhorn Balancing: Double Conservation","what":"12.4 Convergence","title":"Methodology","text":"algorithm converges rapidly — typically machine precision within 15–50 iterations:","code":"# Convergence demo with the 5-tract toy example m <- ncol(tt_toy) row_targets <- pop_toy / sum(pop_toy) * m col_targets <- rep(1, m)  W <- W_raw  # from section 11 max_err_history <- numeric(50) for (k in 1:50) {   rs <- rowSums(W); rs[rs == 0] <- 1   W <- W * (row_targets / rs)   cs <- colSums(W); cs[cs == 0] <- 1   W <- t(t(W) * (col_targets / cs))   max_err_history[k] <- max(     abs(rowSums(W) - row_targets),     abs(colSums(W) - col_targets)   ) }  conv_df <- data.frame(iteration = 1:50, max_error = max_err_history) ggplot(conv_df, aes(x = iteration, y = max_error)) +   geom_line(color = \"#4575b4\", linewidth = 0.8) +   geom_point(color = \"#4575b4\", size = 1) +   scale_y_log10() +   labs(title = \"Sinkhorn Convergence\",        subtitle = \"Marginal error converges to machine precision in ~15 iterations\",        x = \"Iteration\", y = \"Max marginal error (log scale)\") +   theme_minimal() +   theme(plot.title = element_text(face = \"bold\"))"},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"the-formal-algorithm","dir":"Articles","previous_headings":"Part IV: The Weight Matrix > 12. Sinkhorn Balancing: Double Conservation","what":"12.5 The formal algorithm","title":"Methodology","text":"Using package function: algorithm pseudocode:","code":"W_balanced <- sinkhorn_balance(W_raw,   row_targets = row_targets,   col_targets = col_targets )  cat(\"Row sums (should match targets):\\n\") #> Row sums (should match targets): cbind(target = round(row_targets, 4),       actual = round(rowSums(W_balanced), 4)) #>      target actual #> [1,]   0.30   0.30 #> [2,]   0.90   0.90 #> [3,]   0.45   0.45 #> [4,]   0.60   0.60 #> [5,]   0.75   0.75  cat(\"\\nColumn sums (should be 1):\\n\") #>  #> Column sums (should be 1): round(colSums(W_balanced), 4) #> [1] 1 1 1 W <- W_raw for iter in 1..max_iter:   W <- W * (row_targets / rowSums(W))        # scale rows   W <- t(t(W) * (col_targets / colSums(W)))  # scale columns   if max marginal error < tol: break"},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"before-and-after-what-sinkhorn-changes","dir":"Articles","previous_headings":"Part IV: The Weight Matrix > 12. Sinkhorn Balancing: Double Conservation","what":"12.6 Before and after: what Sinkhorn changes","title":"Methodology","text":"Sinkhorn redistributes weight: -weighted tracts (near many stations) get less, -weighted tracts get . geographic “shape” row preserved, “scale” changes match population. Key properties: balanced matrix unique given row/column targets Non-negative: input non-negative, output non-negative Convergence guaranteed sum(row_targets) = sum(col_targets) Unreachable tracts (-zero rows) remain zero flagged","code":"W_std_long <- expand.grid(tract = 1:5, station = 1:3) W_std_long$weight <- as.vector(W_col) W_std_long$method <- \"Column standardized\"  W_bal_long <- expand.grid(tract = 1:5, station = 1:3) W_bal_long$weight <- as.vector(W_balanced) W_bal_long$method <- \"Sinkhorn balanced\"  both <- rbind(W_std_long, W_bal_long) both$method <- factor(both$method,   levels = c(\"Column standardized\", \"Sinkhorn balanced\"))  ggplot(both, aes(x = station, y = tract, fill = weight)) +   geom_tile(color = \"white\") +   geom_text(aes(label = round(weight, 3)), size = 3) +   facet_wrap(~method) +   scale_fill_viridis_c(option = \"viridis\", direction = -1) +   labs(title = \"Weight Matrix: Before and After Sinkhorn\",        x = \"Station\", y = \"Tract\") +   theme_minimal() +   theme(plot.title = element_text(face = \"bold\"))"},{"path":[]},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"the-problem-age-groups-have-different-geographies","dir":"Articles","previous_headings":"Part IV: The Weight Matrix > 12.7 Per-Bracket Sinkhorn: Matching Each Age Group Separately","what":"The problem: age groups have different geographies","title":"Methodology","text":"Think spatial distribution voters age. Young adults (18–24) cluster near universities, cheap rental apartments, transit corridors. Elderly voters (60–69) concentrate established neighborhoods, retirement communities, areas healthcare facilities. spatial patterns differ substantially — yet single weight matrix must allocate age groups simultaneously. aggregate Sinkhorn (Sections 12.1–12.6), weight matrix one set row targets: total population per tract, summed across age brackets. optimizer must find one set weights simultaneously matches 7 (28, full calibration) different demographic distributions. inherent compromise: weights correctly distribute 18–20 year-olds may systematically misallocate 60–69 year-olds, vice versa. Consider concrete scenario. Tract near university many young voters station 1. Tract B retirement neighborhood elderly voters station 3. tracts might similar total populations, age profiles point different stations. aggregate weight matrix averages age groups capture distinction.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"the-per-bracket-extension","dir":"Articles","previous_headings":"Part IV: The Weight Matrix > 12.7 Per-Bracket Sinkhorn: Matching Each Age Group Separately","what":"The per-bracket extension","title":"Methodology","text":"Per-bracket Sinkhorn solves running separate transport problem demographic bracket k=1,…,Kk = 1, \\ldots, K. Instead one weight matrix WW, build KK bracket-specific matrices W(1),…,W(K)W^{(1)}, \\ldots, W^{(K)}, row column constraints: bracket kk: Row targets: ri(k)=Pik/∑iPik⋅∑jSjkr_i^{(k)} = P_{ik} / \\sum_i P_{ik} \\cdot \\sum_j S_{jk} — census population bracket kk tract ii, rescaled total row mass matches total column mass bracket kk. Column targets: cj(k)=Sjkc_j^{(k)} = S_{jk} — number voters bracket kk station jj. Sinkhorn balance: apply standard algorithm Section 12 targets (r(k),c(k))(r^{(k)}, c^{(k)}) IDW kernel KK produce W(k)W^{(k)}. rescaling step 1 ensures ∑iri(k)=∑jcj(k)\\sum_i r_i^{(k)} = \\sum_j c_j^{(k)}, condition Sinkhorn convergence. Aggregate finalize: Wtotal=∑k=1KW(k)W_{\\text{total}} = \\sum_{k=1}^{K} W^{(k)} followed final aggregate Sinkhorn pass column targets cj=1c_j = 1 row targets ri=popi/∑pop×Mr_i = \\text{pop}_i / \\sum \\text{pop} \\times M enforce overall source conservation (station distributes exactly 100% data).","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"why-this-works-better","dir":"Articles","previous_headings":"Part IV: The Weight Matrix > 12.7 Per-Bracket Sinkhorn: Matching Each Age Group Separately","what":"Why this works better","title":"Methodology","text":"bracket’s transport problem simpler: needs match one demographic column. young-voter transport naturally assign weight nearby stations many young voters. elderly-voter transport elderly voters. bracket-specific solutions generally differ spatial distribution age group different. aggregation step combines bracket-specific patterns. tract near university gets weight young-bracket transport nearby youth-heavy stations, still receiving appropriate weight elderly-bracket transport nearby elderly-heavy stations. final Sinkhorn pass ensures overall column sums remain 1.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"worked-example","dir":"Articles","previous_headings":"Part IV: The Weight Matrix > 12.7 Per-Bracket Sinkhorn: Matching Each Age Group Separately","what":"Worked example","title":"Methodology","text":"extend toy example Section 11 two brackets whose spatial distributions differ sharply: per-bracket approach recovers demographic distributions accurately bracket’s transport tailored spatial pattern, rather forced one-size-fits-compromise.","code":"# Bracket 1 (\"young\"): concentrated near station 1 # Bracket 2 (\"old\"): concentrated near station 3 pop_young <- c(60, 100, 50, 30, 20)   # young pop per tract pop_old   <- c(40, 200, 100, 170, 230) # old pop per tract  src_young <- c(150, 70, 40)  # young voters per station src_old   <- c(100, 330, 310) # old voters per station  pop_mat_toy <- cbind(young = pop_young, old = pop_old) src_mat_toy <- cbind(young = src_young, old = src_old)  # Per-bracket weights: each bracket gets its own Sinkhorn transport W_total <- matrix(0, 5, 3) for (k in 1:2) {   rb <- pop_mat_toy[, k]   cb <- src_mat_toy[, k]   rb_scaled <- rb / sum(rb) * sum(cb)   # rescale so sum(r) == sum(c)   W_k <- sinkhorn_balance(W_raw, rb_scaled, cb)   W_total <- W_total + W_k }  # Final aggregate Sinkhorn to enforce column-sum = 1 pop_total_toy <- rowSums(pop_mat_toy) m_toy <- ncol(W_total) rt <- pop_total_toy / sum(pop_total_toy) * m_toy W_pb <- sinkhorn_balance(W_total, rt, rep(1, m_toy))  # Compare: aggregate-only vs per-bracket W_agg <- sinkhorn_balance(W_raw, rt, rep(1, m_toy))  # Interpolate BOTH brackets young_hat_agg <- as.numeric(W_agg %*% src_young) young_hat_pb  <- as.numeric(W_pb %*% src_young) old_hat_agg   <- as.numeric(W_agg %*% src_old) old_hat_pb    <- as.numeric(W_pb %*% src_old)  cat(\"=== Young bracket ===\\n\") #> === Young bracket === cat(\"Census truth:             \", pop_young, \"\\n\") #> Census truth:              60 100 50 30 20 cat(\"Aggregate Sinkhorn:       \", round(young_hat_agg), \"\\n\") #> Aggregate Sinkhorn:        45 83 45 40 48 cat(\"Per-bracket Sinkhorn:     \", round(young_hat_pb), \"\\n\") #> Per-bracket Sinkhorn:      45 87 46 38 45 cat(\"Aggregate SSE:   \", round(sum((young_hat_agg - pop_young)^2)), \"\\n\") #> Aggregate SSE:    1408 cat(\"Per-bracket SSE: \", round(sum((young_hat_pb - pop_young)^2)), \"\\n\") #> Per-bracket SSE:  1095  cat(\"\\n=== Old bracket ===\\n\") #>  #> === Old bracket === cat(\"Census truth:             \", pop_old, \"\\n\") #> Census truth:              40 200 100 170 230 cat(\"Aggregate Sinkhorn:       \", round(old_hat_agg), \"\\n\") #> Aggregate Sinkhorn:        31 239 107 159 204 cat(\"Per-bracket Sinkhorn:     \", round(old_hat_pb), \"\\n\") #> Per-bracket Sinkhorn:      31 228 105 164 212 cat(\"Aggregate SSE:   \", round(sum((old_hat_agg - pop_old)^2)), \"\\n\") #> Aggregate SSE:    2466 cat(\"Per-bracket SSE: \", round(sum((old_hat_pb - pop_old)^2)), \"\\n\") #> Per-bracket SSE:  1250  cat(\"\\n=== Total SSE across both brackets ===\\n\") #>  #> === Total SSE across both brackets === total_agg <- sum((young_hat_agg - pop_young)^2) +   sum((old_hat_agg - pop_old)^2) total_pb <- sum((young_hat_pb - pop_young)^2) +   sum((old_hat_pb - pop_old)^2) cat(\"Aggregate:\", round(total_agg), \"\\n\") #> Aggregate: 3874 cat(\"Per-bracket:\", round(total_pb), \"\\n\") #> Per-bracket: 2345 # Visual comparison: aggregate vs per-bracket recovery comparison_df <- data.frame(   tract = rep(1:5, 4),   value = c(pop_young, pop_old, young_hat_pb, old_hat_pb),   bracket = rep(c(\"Young\", \"Old\", \"Young\", \"Old\"), each = 5),   source = rep(c(\"Census truth\", \"Census truth\",                   \"Per-bracket estimate\", \"Per-bracket estimate\"),                each = 5) )  ggplot(comparison_df,        aes(x = factor(tract), y = value, fill = source)) +   geom_col(position = \"dodge\", width = 0.7) +   facet_wrap(~bracket, scales = \"free_y\") +   scale_fill_manual(values = c(\"Census truth\" = \"#4575b4\",                                 \"Per-bracket estimate\" = \"#fdae61\")) +   labs(title = \"Per-Bracket Sinkhorn: Recovery of Age-Group Profiles\",        x = \"Tract\", y = \"Population\", fill = \"\") +   theme_minimal() +   theme(plot.title = element_text(face = \"bold\"),         legend.position = \"bottom\")"},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"connection-to-the-optimizer","dir":"Articles","previous_headings":"Part IV: The Weight Matrix > 12.7 Per-Bracket Sinkhorn: Matching Each Age Group Separately","what":"Connection to the optimizer","title":"Methodology","text":"PB-SGD optimization (Section 14), per-bracket Sinkhorn performed log-domain 3D tensors shape [ka × batch × m], ka number active demographic brackets batch number sampled tracts per SGD step. vectorizes KK separate transport problems single batched matrix computation GPU CPU, making nearly fast single aggregate Sinkhorn pass. Section 14.3 derives log-domain Sinkhorn updates, Section 14.4 presents complete 3D-tensor pseudocode. optimization, sinkhorn_weights() builds final weight matrix using per-bracket logic full convergence (1000 Sinkhorn iterations, marginal error falls 10−1010^{-10}): pop_matrix source_matrix provided, function automatically uses per-bracket mode. Without , falls back single-Sinkhorn mode backward compatibility.","code":"W <- sinkhorn_weights(time_matrix, alpha, offset = 1,   row_targets = row_targets,   pop_matrix = pop_matrix,   source_matrix = source_matrix)"},{"path":[]},{"path":[]},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"the-key-insight","dir":"Articles","previous_headings":"Part V: Calibration and Optimization > 13. The Calibration Objective","what":"13.1 The key insight","title":"Methodology","text":"ingredients: travel times, IDW kernel parametrized α\\alpha, Sinkhorn balancing enforce constraints. Now need find right α\\alpha. calibration logic: weights correct, interpolating voter age profiles stations recover census age profiles tract. Consider concrete example. Census data says tract X 200 people aged 30–39. weights good, multiplying weight row tract X station-level voter counts 30–39 age bracket give us approximately 200. gives 150 300, weights wrong — geographic allocation biased. optimization finds α\\alpha values minimize mismatch across tracts age brackets simultaneously.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"the-iterative-procedure","dir":"Articles","previous_headings":"Part V: Calibration and Optimization > 13. The Calibration Objective","what":"13.2 The iterative procedure","title":"Methodology","text":"optimization loop:  words: Initialize: set αi=1\\alpha_i = 1 tracts (moderate decay) Build IDW kernel: compute raw weights travel times current α\\alpha Sinkhorn balance: enforce row column constraints Interpolate demographics: multiply balanced weights station-level age profiles Compare census: compute squared error interpolated census age profiles Adjust α\\alpha: use gradient (via automatic differentiation) nudge α\\alpha direction reduces error Repeat error stops decreasing iteration loop evaluates complete forward pass: α→kernel→Sinkhorn→interpolation→error\\alpha \\\\text{kernel} \\\\text{Sinkhorn} \\\\text{interpolation} \\\\text{error}.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"the-formal-objective","dir":"Articles","previous_headings":"Part V: Calibration and Optimization > 13. The Calibration Objective","what":"13.3 The formal objective","title":"Methodology","text":"f(α)=∑∑k(V̂ik−Pik)2f(\\alpha) = \\sum_i \\sum_k \\left( \\hat{V}_{ik} - P_{ik} \\right)^2 : V̂=W(α)×S\\hat{V} = W(\\alpha) \\times S — interpolated voter demographics per tract, WW built via per-bracket Sinkhorn (Section 12.7) PP — census demographics per tract kk = demographic bracket index (K=7K = 7 age-calibration, K=28K = 28 full gender × literacy × age calibration) weight matrix W(α)W(\\alpha) sum per-bracket transport matrices W(k)W^{(k)}, balanced match bracket kk’s row/column targets, followed final aggregate Sinkhorn pass.  landscape clear minimum. practice, tract alpha, creating high-dimensional optimization problem.","code":"# Simplified case: all tracts share the same alpha tt_adj <- tt_toy + 1 pop_matrix_toy <- matrix(pop_toy, ncol = 1) src_matrix_toy <- matrix(c(250, 400, 350), ncol = 1)  alpha_range <- seq(0.1, 8, by = 0.1) sse_values <- sapply(alpha_range, function(a) {   sinkhorn_objective(     alpha = rep(a, 5),     time_matrix = tt_adj,     pop_matrix = pop_matrix_toy,     source_matrix = src_matrix_toy,     row_targets = pop_toy / sum(pop_toy) * 3,     sk_iter = 50   ) }) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 1.09e-10) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 1.68e-10) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 2.52e-10) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 3.68e-10) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 5.28e-10) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 7.43e-10) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 1.03e-09) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 1.40e-09) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 1.88e-09) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 2.48e-09) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 3.24e-09) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 4.19e-09) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 5.35e-09) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 6.76e-09) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 8.45e-09) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 1.05e-08) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 1.29e-08) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 1.57e-08) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 1.90e-08) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 2.28e-08) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 2.72e-08) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 3.22e-08) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 3.79e-08) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 4.43e-08) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 5.16e-08) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 5.98e-08) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 6.89e-08) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 7.90e-08) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 9.03e-08) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 1.03e-07) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 1.16e-07) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 1.32e-07) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 1.48e-07) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 1.66e-07) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 1.86e-07) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 2.08e-07) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 2.31e-07) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 2.57e-07) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 2.85e-07) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 3.15e-07) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 3.48e-07) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 3.84e-07) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 4.23e-07) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 4.64e-07) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 5.09e-07) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 5.58e-07) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 6.11e-07) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 6.68e-07) #> Warning: Sinkhorn did not converge after 50 iterations (max marginal error: #> 7.29e-07)  ggplot(data.frame(alpha = alpha_range, sse = sse_values),        aes(x = alpha, y = sse)) +   geom_line(color = \"#4575b4\", linewidth = 0.8) +   geom_vline(xintercept = alpha_range[which.min(sse_values)],              linetype = \"dashed\", color = \"#d73027\") +   labs(title = \"Objective Function Landscape\",        subtitle = sprintf(          \"Minimum at alpha = %.1f (shared across all tracts)\",          alpha_range[which.min(sse_values)]),        x = expression(alpha), y = \"SSE\") +   theme_minimal() +   theme(plot.title = element_text(face = \"bold\"))"},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"sinkhorn-iterations-during-optimization-sk_iter","dir":"Articles","previous_headings":"Part V: Calibration and Optimization > 13. The Calibration Objective","what":"13.4 Sinkhorn iterations during optimization (sk_iter)","title":"Methodology","text":"objective function f(α)f(\\alpha) depends Sinkhorn-balanced weights. principle, exact Sinkhorn convergence require hundreds iterations per evaluation. SGD optimization, need gradients point approximately right direction — exact ones. opens key tradeoff: iterations (e.g., sk_iter = 3): per-bracket transport poorly approximated. Row column targets far satisfied. Gradients noisy may point wrong directions, causing optimizer diverge get stuck. many iterations (e.g., sk_iter = 50): transport nearly exact, memory grows O(ka×b×m×𝚜𝚔_𝚒𝚝𝚎𝚛)O(k_a \\times b \\times m \\times \\texttt{sk\\_iter}) torch must store intermediate tensors backpropagation unrolled iterations. GPU, can exceed available VRAM large cities. sweet spot (sk_iter = 15): experiments across municipalities varying sizes (Varginha, Niteroi, Belo Horizonte, São Paulo) showed 15 iterations achieve near-optimal spatial variation resulting alpha vectors keeping memory usage well within GPU limits. Beyond 15, marginal improvement gradient quality negligible. default sk_iter = 15 balances gradient accuracy memory cost. final weight computation optimization (via sinkhorn_weights()) uses full convergence-based Sinkhorn 1000 iterations, final interpolation always exact regardless sk_iter training.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"why-automatic-differentiation","dir":"Articles","previous_headings":"Part V: Calibration and Optimization > 14. Optimization: Per-Bracket SGD with Log-Domain Sinkhorn","what":"14.1 Why automatic differentiation?","title":"Methodology","text":"objective function involves KK iterations Sinkhorn scaling. iteration multiplies, divides, sums — standard operations. writing analytical gradient loss function KK unrolled Sinkhorn iterations hand tedious error-prone. Torch’s automatic differentiation handles : define forward pass (kernel → Sinkhorn → interpolation → loss), torch computes gradient loss respect α\\alpha automatically recording every operation applying chain rule backward.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"why-log-domain-sinkhorn","dir":"Articles","previous_headings":"Part V: Calibration and Optimization > 14. Optimization: Per-Bracket SGD with Log-Domain Sinkhorn","what":"14.2 Why log-domain Sinkhorn?","title":"Methodology","text":"standard Sinkhorn algorithm multiplies weights directly. α\\alpha large travel times vary widely, weights become astronomically small: 32-bit floating point (standard GPU computation), numbers smaller 1.2×10−381.2 \\times 10^{-38} underflow zero. weight becomes exactly zero, Sinkhorn row/column scaling produces 0/0=NaN0/0 = \\text{NaN}, optimization collapses. log-domain solution: instead storing tiny weights directly, store logarithms. weight 10−2010^{-20} log(10−20)=−46\\log(10^{-20}) = -46, perfectly representable float32.","code":"# Demonstrate the underflow problem tt_demo <- c(5, 20, 60, 120, 200)  # travel times (minutes) alpha_high <- 8  raw <- (tt_demo + 1)^(-alpha_high) cat(\"Raw weights at alpha = 8:\\n\") #> Raw weights at alpha = 8: cat(formatC(raw, format = \"e\", digits = 2), \"\\n\") #> 5.95e-07 2.64e-11 5.22e-15 2.18e-17 3.75e-19 cat(\"\\nIn float32, values below ~1.2e-38 become exactly 0\\n\") #>  #> In float32, values below ~1.2e-38 become exactly 0 cat(\"Zero weights cause division by zero in Sinkhorn scaling\\n\") #> Zero weights cause division by zero in Sinkhorn scaling"},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"deriving-the-log-domain-sinkhorn-updates","dir":"Articles","previous_headings":"Part V: Calibration and Optimization > 14. Optimization: Per-Bracket SGD with Log-Domain Sinkhorn","what":"14.3 Deriving the log-domain Sinkhorn updates","title":"Methodology","text":"Start standard Sinkhorn row update. classical algorithm, maintain scaling vectors uu vv Wij=ui⋅Kij⋅vjW_{ij} = u_i \\cdot K_{ij} \\cdot v_j: ui=ri∑jKij⋅vju_i = \\frac{r_i}{\\sum_j K_{ij} \\cdot v_j} Take logarithm sides: logui=logri−log(∑jKij⋅vj)\\log u_i = \\log r_i - \\log\\left(\\sum_j K_{ij} \\cdot v_j\\right) Rewrite sum inside log expressing everything log space: logui=logri−log(∑jexp(logKij+logvj))\\log u_i = \\log r_i - \\log\\left(\\sum_j \\exp(\\log K_{ij} + \\log v_j)\\right) operation log(∑jexp(xj))\\log\\left(\\sum_j \\exp(x_j)\\right) logsumexp function — numerically stable primitive available torch: logui=logri−logsumexpj(logKij+logvj)\\log u_i = \\log r_i - \\text{logsumexp}_j(\\log K_{ij} + \\log v_j) Similarly, column update (column target cj=1c_j = 1, logcj=0\\log c_j = 0): logvj=−logsumexpi(logKij+logui)\\log v_j = -\\text{logsumexp}_i(\\log K_{ij} + \\log u_i) log-kernel simply: logKij=−αi⋅log(tij+1)\\log K_{ij} = -\\alpha_i \\cdot \\log(t_{ij} + 1)","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"the-complete-per-bracket-log-domain-sinkhorn-algorithm","dir":"Articles","previous_headings":"Part V: Calibration and Optimization > 14. Optimization: Per-Bracket SGD with Log-Domain Sinkhorn","what":"14.4 The complete per-bracket log-domain Sinkhorn algorithm","title":"Methodology","text":"optimizer performs Sinkhorn transport per bracket 3D tensors. reading pseudocode, helps understand tensor shapes involved: first dimension (kak_a) indexes demographic brackets. second dimension (bb) indexes sampled tracts mini-batch. third dimension (mm) indexes stations. kak_a brackets share log-kernel — row/column targets differ — Sinkhorn updates can computed single vectorized operation across brackets. Every operation — log, exp, logsumexp, matrix multiply, subtraction, squaring — defined backward pass torch. gradient ∇αf\\nabla_\\alpha f flows backward sk_iter Sinkhorn iterations automatically. scale column targets? sample mini-batch bb tracts full set nn, row targets batch (r_batch) sum less full row targets (r_mat). column targets (voter counts stations) remain — haven’t sampled stations, tracts. used full column targets, Sinkhorn problem inconsistent: row sums much smaller column sums, algorithm fail converge. fix scale bracket’s column targets ratio sum(rbatch(k))/sum(rfull(k))\\text{sum}(r_{\\text{batch}}^{(k)}) / \\text{sum}(r_{\\text{full}}^{(k)}), mini-batch Sinkhorn problem matching row column totals. ensures mini-batch step solves well-posed transport problem consistent full-data objective. Key design choices: 3D tensors: kak_a brackets batched single [ka × b × m] tensor, enabling efficient GPU parallelism Per-bracket targets: bracket row/column targets, giving age group spatial transport solution Batch scaling: V_scaled scaled b/n loss n/b gradient unbiased estimate full-data gradient, regardless batch size","code":"Input: log_t[n,m], alpha[n], P[n,ka], V[m,ka], sk_iter, batch_size  # Preprocess: per-bracket row/column targets (done once) for each bracket b in 1..ka:     r_mat[b,:] = P[:,b] / sum(P[:,b]) * sum(V[:,b])  # rescale rows     c_mat[b,:] = V[:,b]  # --- PB-SGD step (repeated for max_steps iterations) --- # Sample mini-batch of b tracts idx = sample(1..n, batch_size) r_batch = r_mat[:, idx]                    # [ka x b]  # Column scaling: adjust column targets to match the mini-batch # (see explanation below) c_batch = c_mat * (rowSums(r_batch) / rowSums(r_mat))  # [ka x m]  # Build 3D log-targets (unsqueeze for broadcasting) log_r_3d = log(r_batch)                     # [ka x b x 1] log_c_3d = log(c_batch)                     # [ka x 1 x m]  # Log-kernel for batch (same kernel for all brackets) log_K[i,j] = -alpha[idx[i]] * log_t[idx[i], j]   # [b x m] log_K_3d = log_K expanded to [ka x b x m]   # broadcast across brackets  # Log-domain Sinkhorn iterations (per bracket, batched) log_u = zeros(ka, b, 1) log_v = zeros(ka, 1, m)  for k = 1 to sk_iter:     log_u = log_r_3d - logsumexp_j(log_K_3d + log_v)   # row update     log_v = log_c_3d - logsumexp_i(log_K_3d + log_u)   # column update  # Recover weights, aggregate brackets, and column-normalize W_all = exp(log_u + log_K_3d + log_v)       # [ka x b x m] W_total = sum(W_all, dim=bracket)            # [b x m] W_norm = W_total / colSums(W_total)          # column-normalize  # Compute loss (scaled for batch → full-data estimate) V_scaled = V * (b / n) V_hat = W_norm @ V_scaled                    # [b x ka] loss = sum((V_hat - P[idx,:])^2) * (n / b)"},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"pb-sgd-per-bracket-stochastic-gradient-descent","dir":"Articles","previous_headings":"Part V: Calibration and Optimization > 14. Optimization: Per-Bracket SGD with Log-Domain Sinkhorn","what":"14.5 PB-SGD: Per-Bracket Stochastic Gradient Descent","title":"Methodology","text":"use ADAM (Adaptive Moment Estimation) underlying optimizer, mini-batch sampling per-bracket Sinkhorn transport. 800 PB-SGD steps: Sample mini-batch batch_size tracts (default 500) Per-bracket Sinkhorn: demographic column gets log-domain Sinkhorn transport [ka x batch x m] tensors Aggregate bracket contributions column-normalize Compute loss: scaled SSE interpolated observed values Gradient masking: update optimizer moments sampled tracts Gradient clipping norm 5.0 prevents divergence Alpha clamped [lower_bound, upper_bound] (default [0.01, 20]) learning rate halves steps 200, 400, 600.  typical loss curve shows three phases: (1) rapid descent first ~200 steps optimizer finds right ballpark alpha, (2) slower refinement phase (steps 200–600) learning rate halves twice optimizer fine-tunes per-tract parameters, (3) plateau final 200 steps improvements become marginal. loss computed random mini-batch step, curve fluctuate — normal expected stochastic optimization. package tracks best loss seen across steps returns corresponding alpha values, transient spikes affect final result. Key tuning parameters:","code":"optim_result <- optimize_alpha(   time_matrix   = time_matrix,   pop_matrix    = pop_matrix,   source_matrix = source_matrix,   row_targets   = row_targets,   batch_size    = 500,     # mini-batch size (full-batch if n <= 500)   sk_iter       = 15,      # Sinkhorn iterations per step   max_steps     = 800,     # total SGD steps   lr_init       = 0.05,    # initial learning rate   use_gpu       = FALSE    # CPU for small problems )"},{"path":[]},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"the-effect-of-alpha-spatial-interpretation","dir":"Articles","previous_headings":"Part VI: Results and Validation","what":"15. The Effect of Alpha: Spatial Interpretation","title":"Methodology","text":"alphas cluster moderate range, tails extending toward 0 (uniform allocation) upper bound (nearest-station-).  Low alpha (blue, urban core): weight spread across many nearby stations. Multiple stations overlap, optimizer distributes influence broadly. High alpha (red, periphery): weight concentrated nearest station. Isolated tracts one dominant station.  α=1\\alpha = 1, weights nearly uniform. α=10\\alpha = 10, nearest station dominates ~85% weight. Interpretation guide: α<1\\alpha < 1: draws information almost equally stations. Unusual — check data issues. α∈[1,3]\\alpha \\[1, 3]: several nearby stations contribute. Typical dense urban areas. α∈[3,6]\\alpha \\[3, 6]: stations dominate. Typical suburban areas. α>6\\alpha > 6: one station dominates almost entirely. Typical isolated tracts.","code":"# How alpha changes the weight distribution for a fixed tract tt_one_tract <- c(3, 8, 15, 25, 40) alphas_demo <- c(1, 3, 5, 10) wt_df <- do.call(rbind, lapply(alphas_demo, function(a) {   w <- (tt_one_tract + 1)^(-a)   w <- w / sum(w)   data.frame(station = 1:5, weight = w,              alpha = paste0(\"alpha = \", a)) })) wt_df$alpha <- factor(wt_df$alpha,                         levels = paste0(\"alpha = \", alphas_demo))  ggplot(wt_df, aes(x = factor(station), y = weight, fill = alpha)) +   geom_col(position = \"dodge\") +   labs(title = \"Weight Distribution as Alpha Increases\",        subtitle = \"Fixed tract, 5 stations at 3, 8, 15, 25, 40 min\",        x = \"Station (sorted by distance)\",        y = \"Normalized weight\", fill = \"\") +   theme_minimal() +   theme(plot.title = element_text(face = \"bold\"))"},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"the-interpolation-from-weights-to-tract-level-estimates","dir":"Articles","previous_headings":"Part VI: Results and Validation","what":"16. The Interpolation: From Weights to Tract-Level Estimates","title":"Methodology","text":"weight matrix WW encodes geographic relationship tracts stations. Multiplying station-level variable produces tract-level estimates: X̂=W×V\\hat{X} = W \\times V WW [N × M], VV [M × 1], X̂\\hat{X} [N × 1]. multiple variables: X̂=W×Vmatrix\\hat{X} = W \\times V_{\\text{matrix}} VmatrixV_{\\text{matrix}} [M × P].   Geographic polarization becomes visible tract level — spatial pattern previously impossible observe station-level data alone. Calibration validation: interpolated demographics match census demographics (optimization objective).  Points cluster tightly around 45-degree line, confirming optimization found good weights. reuse principle: weight matrix WW property geography calibration. computed, can interpolate variable measured polling stations — candidates, parties, turnout, gender composition, education level — without re-optimizing alpha.","code":"W <- sinkhorn_weights(time_matrix, optim_result$alpha,   offset = 1, row_targets = row_targets,   pop_matrix = pop_matrix, source_matrix = source_matrix)  electoral_data <- as.matrix(   sources[, c(\"CAND_13\", \"CAND_22\", \"QT_COMPARECIMENTO\")] ) interpolated <- W %*% electoral_data  pct_lula <- interpolated[, \"CAND_13\"] /   interpolated[, \"QT_COMPARECIMENTO\"] * 100"},{"path":[]},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"conservation-properties","dir":"Articles","previous_headings":"Part VI: Results and Validation > 17. Validation: How Well Did We Recover the Age Structure?","what":"17.1 Conservation properties","title":"Methodology","text":"Column conservation (source conservation): ∑iWij=1∀j\\sum_i W_{ij} = 1 \\quad \\forall j station distributes exactly 100% data. Municipal totals preserved exactly. Row conservation (population proportionality): ∑jWij=ri=popi∑pop×m\\sum_j W_{ij} = r_i = \\frac{\\text{pop}_i}{\\sum \\text{pop}} \\times m Calibration residuals:  Residuals centered near zero small magnitude. Outliers may indicate boundary effects (voters crossing municipality borders) data quality issues.","code":"votes <- c(500, 800, 700) interpolated_votes <- as.numeric(W_balanced %*% votes)  cat(\"Source total:\", sum(votes), \"\\n\") #> Source total: 2000 cat(\"Interpolated total:\", round(sum(interpolated_votes)), \"\\n\") #> Interpolated total: 2000 cat(\"Per-tract:\", round(interpolated_votes), \"\\n\") #> Per-tract: 151 644 304 399 502"},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"age-pyramid-recovery-rocinha-and-copacabana-revisited","dir":"Articles","previous_headings":"Part VI: Results and Validation > 17. Validation: How Well Did We Recover the Age Structure?","what":"17.2 Age pyramid recovery: Rocinha and Copacabana revisited","title":"Methodology","text":"Section 1, showed Rocinha Copacabana strikingly different age structures. interpolation recover patterns?  blue bars show census truth (population age bracket) yellow bars show Sinkhorn-interpolated voter profiles. interpolation closely recovers distinctive age patterns neighborhoods: Rocinha’s young skew Copacabana’s aging profile. demanding test. method know anything Rocinha Copacabana neighborhoods — sees census tracts polling stations. Yet calibration age brackets produces weights correctly recover neighborhood-level demographic signatures.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"comparison-with-voronoi-assignment","dir":"Articles","previous_headings":"Part VI: Results and Validation > 17. Validation: How Well Did We Recover the Age Structure?","what":"17.3 Comparison with Voronoi assignment","title":"Methodology","text":"simplest alternative method Voronoi assignment: assign tract nearest polling station use station’s data directly. equivalent constructing Voronoi (Thiessen) polygons around station assigning tract 100% weight one station. compare methods across four Brazilian state capitals diverse urban morphologies: Palmas (), Cuiabá (MT), Manaus (), Natal (RN).  Voronoi approach, tract inherits complete demographic electoral profile single station. ignores many--many structure: tract near boundary two Voronoi cells gets none influence station just across boundary. well two methods recover census age structure? following figure compares predicted versus observed demographic profiles across four cities:  Sinkhorn points cluster tightly around 45-degree line every city. Voronoi points show much scatter — many tracts large prediction errors assigned station different demographic composition.  residual boxplots confirm pattern across four cities: Sinkhorn residuals tightly centered around zero, Voronoi residuals much larger spread. aggregate SSE ratio quantifies advantage:  every city, Sinkhorn method achieves dramatically lower squared error Voronoi assignment — factor 275x (Cuiabá) 1,624x (Manaus), Palmas 601x Natal 639x. advantage consistent across cities different sizes urban layouts, confirming smooth, calibrated weighting fundamentally superior hard nearest-station assignment.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"ecological-correlation-lula-vote-share-and-household-income","dir":"Articles","previous_headings":"Part VI: Results and Validation > 17. Validation: How Well Did We Recover the Age Structure?","what":"17.4 Ecological correlation: Lula vote share and household income","title":"Methodology","text":"final validation exercise, examine whether interpolated voting patterns exhibit expected ecological correlations. spatial weights correct, interpolated vote shares correlate tract-level socioeconomic indicators independent data sources. correlate interpolated percentage votes Lula (PT) census tract average monthly income household heads, obtained 2022 Census (via censobr::read_tracts(2022, \"ResponsavelRenda\")). show correlation four cities different socioeconomic profiles: São Paulo (SP), Salvador (BA), Porto Alegre (RS), Cuiabá (MT).  negative correlation consistent across four cities well-established patterns Brazilian electoral geography: lower-income areas tend vote heavily PT candidates, higher-income areas lean toward parties. fact interpolated tract-level estimates reproduce pattern — using vote data originally measured polling stations, tracts — provides external validation spatial weights geographically meaningful. income data log-transformed (log(x+1)\\log(x+1)) reduce influence extreme values improve linearity.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"performance-and-tuning","dir":"Articles","previous_headings":"Part VII: Practical","what":"18. Performance and Tuning","title":"Methodology","text":"timings assume default PB-SGD parameters: batch_size = 500, sk_iter = 15, max_steps = 800, dtype = \"float32\". Practical runtimes (optimization step , actual runs): Igrejinha (85 tracts, 17 stations): ~24s CPU Varginha (279 tracts, 37 stations): ~52s CPU Palmas (660 tracts, 71 stations): ~135s CPU Niterói (1,169 tracts, 135 stations): ~17s GPU Belo Horizonte (5,113 tracts, 407 stations): ~105s GPU Rio de Janeiro (13,370 tracts, 1,392 stations): ~10 min GPU Note total wall-clock time interpolate_election_br() also includes data downloads, travel time computation (via r5r), weight matrix construction, can dominate larger cities. Memory estimation. GPU memory optimization two main components: Full kernel matrix (always memory): n×m×bytesn \\times m \\times \\text{bytes} — e.g., 5,100 × 407 × 4 ≈ 8 MB Belo Horizonte float32. 3D Sinkhorn tensors (main cost): ka×min(𝚋𝚊𝚝𝚌𝚑_𝚜𝚒𝚣𝚎,n)×m×bytes×(2+2×𝚜𝚔_𝚒𝚝𝚎𝚛)k_a \\times \\min(\\texttt{batch\\_size}, n) \\times m \\times \\text{bytes} \\times (2 + 2 \\times \\texttt{sk\\_iter}) — torch must store intermediate tensors backpropagation unrolled Sinkhorn iterations. kak_a number active demographic brackets (7 calib_type = \"age_only\", 28 calib_type = \"full\") bytes 4 (float32) 8 (float64). actual values reported optimizer precomputation. calib_type = \"age_only\" (ka=7k_a = 7), memory approximately 4× smaller. large cities GPU, consider reducing batch_size sk_iter, switching dtype = \"float32\" (default) using \"float64\". RStudio: torch inside RStudio IDE requires subprocess execution via callr (automatic transparent user). Standalone R scripts run directly.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"setup-torch-java-and-r5r","dir":"Articles","previous_headings":"Part VII: Practical","what":"19. Setup: Torch, Java, and r5r","title":"Methodology","text":"Torch (required optimization): GPU support: Windows (CUDA), macOS (MPS Apple Silicon), Linux (CUDA). CPU always works fallback. Java + r5r (required travel time computation): Memory: options(java.parameters = \"-Xmx8g\") loading r5r large municipalities. Cache management:","code":"setup_torch()    # installs torch + libtorch/lantern binaries check_torch()    # diagnoses installation (R package, binaries, GPU) setup_java()     # downloads and installs Java 21+ check_r5r()      # checks Java version and r5r readiness setup_osmium()   # installs osmium-tool for OSM clipping get_interpElections_cache_dir()    # where downloads are stored interpElections_cache()            # list cached files by category interpElections_cache_clean()      # clear cache"},{"path":[]},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"notation","dir":"Articles","previous_headings":"Part VII: Practical > 20. Mathematical Appendix","what":"Notation","title":"Methodology","text":"NN = number census tracts, MM = number polling stations KK = number calibration brackets (7 age-, 28 full) t∈ℝN×Mt \\\\mathbb{R}^{N \\times M}: travel time matrix (minutes) α∈ℝN\\alpha \\\\mathbb{R}^N: per-tract decay parameters P∈ℝN×KP \\\\mathbb{R}^{N \\times K}: census population age bracket S∈ℝM×KS \\\\mathbb{R}^{M \\times K}: voter counts age bracket stations r∈ℝNr \\\\mathbb{R}^N: row targets (ri=popi/∑pop×Mr_i = \\text{pop}_i / \\sum \\text{pop} \\times M) c∈ℝMc \\\\mathbb{R}^M: column targets (cj=1c_j = 1)","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"idw-kernel","dir":"Articles","previous_headings":"Part VII: Practical > 20. Mathematical Appendix","what":"IDW kernel","title":"Methodology","text":"Kij=(tij+1)−αiK_{ij} = (t_{ij} + 1)^{-\\alpha_i}","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"log-domain-kernel","dir":"Articles","previous_headings":"Part VII: Practical > 20. Mathematical Appendix","what":"Log-domain kernel","title":"Methodology","text":"logKij=−αi⋅log(tij+1)\\log K_{ij} = -\\alpha_i \\cdot \\log(t_{ij} + 1)","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"sinkhorn-iterations-log-domain-single-bracket","dir":"Articles","previous_headings":"Part VII: Practical > 20. Mathematical Appendix","what":"Sinkhorn iterations (log-domain, single bracket)","title":"Methodology","text":"Initialize: logu=𝟎N×1\\log u = \\mathbf{0}_{N \\times 1}, logv=𝟎1×M\\log v = \\mathbf{0}_{1 \\times M} k=1k = 1 KsinkK_{\\text{sink}}: logui←logri−logsumexpj(logKij+logvj)\\log u_i \\leftarrow \\log r_i - \\text{logsumexp}_j(\\log K_{ij} + \\log v_j)logvj←−logsumexpi(logKij+logui)\\log v_j \\leftarrow -\\text{logsumexp}_i(\\log K_{ij} + \\log u_i)","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"balanced-weight-matrix-single-bracket","dir":"Articles","previous_headings":"Part VII: Practical > 20. Mathematical Appendix","what":"Balanced weight matrix (single bracket)","title":"Methodology","text":"Wij=exp(logui+logKij+logvj)W_{ij} = \\exp(\\log u_i + \\log K_{ij} + \\log v_j)","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"per-bracket-sinkhorn","dir":"Articles","previous_headings":"Part VII: Practical > 20. Mathematical Appendix","what":"Per-bracket Sinkhorn","title":"Methodology","text":"demographic bracket k=1,…,Kk = 1, \\ldots, K: Rescale row targets: ri(k)=Pik/∑iPik⋅∑jSjkr_i^{(k)} = P_{ik} / \\sum_i P_{ik} \\cdot \\sum_j S_{jk} Set column targets: cj(k)=Sjkc_j^{(k)} = S_{jk} Run Sinkhorn (r(k),c(k))(r^{(k)}, c^{(k)}) kernel KK get W(k)W^{(k)} Aggregate: Wtotal=∑k=1KW(k)W_{\\text{total}} = \\sum_{k=1}^{K} W^{(k)} Final balance: run Sinkhorn WtotalW_{\\text{total}} aggregate row targets ri=popi/∑pop×Mr_i = \\text{pop}_i / \\sum \\text{pop} \\times M column targets cj=1c_j = 1.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"per-bracket-sinkhorn-on-3d-tensors-pb-sgd","dir":"Articles","previous_headings":"Part VII: Practical > 20. Mathematical Appendix","what":"Per-bracket Sinkhorn on 3D tensors (PB-SGD)","title":"Methodology","text":"optimization, per-bracket Sinkhorn vectorized across brackets 3D tensors. Let kak_a = number active brackets, bb = mini-batch size, MM = number stations. Preprocessing (done SGD loop): Per-bracket row targets r(k)∈ℝNr^{(k)} \\\\mathbb{R}^N column targets c(k)∈ℝMc^{(k)} \\\\mathbb{R}^M stored matrices: R∈ℝka×NR \\\\mathbb{R}^{k_a \\times N}, C∈ℝka×MC \\\\mathbb{R}^{k_a \\times M}. Per-step computation (sampled batch indices ℬ\\mathcal{B}, |ℬ|=b|\\mathcal{B}| = b): Mini-batch targets: Rbatch=R[:,ℬ]∈ℝka×b,Cbatch,k=Ck⋅∑iRbatch,ki∑iRki∈ℝka×MR_{\\text{batch}} = R[:, \\mathcal{B}] \\\\mathbb{R}^{k_a \\times b}, \\qquad C_{\\text{batch},k} = C_k \\cdot \\frac{\\sum_i R_{\\text{batch},ki}}{\\sum_i R_{ki}} \\\\mathbb{R}^{k_a \\times M} Initialize: logu∈ℝka×b×1=𝟎,logv∈ℝka×1×M=𝟎\\log u \\\\mathbb{R}^{k_a \\times b \\times 1} = \\mathbf{0}, \\qquad \\log v \\\\mathbb{R}^{k_a \\times 1 \\times M} = \\mathbf{0} Log-kernel (shared across brackets): logKij=−αℬ()⋅log(tℬ(),j+1)∈ℝb×M\\log K_{ij} = -\\alpha_{\\mathcal{B}()} \\cdot \\log(t_{\\mathcal{B}(),j} + 1) \\\\mathbb{R}^{b \\times M} Broadcast 3D: logK3D∈ℝka×b×M\\log K^{3D} \\\\mathbb{R}^{k_a \\times b \\times M} (identical across bracket dimension). ℓ=1\\ell = 1 sk_iter: loguk,,⋅←logrbatch,(k)−logsumexpj(logKk,,j3D+logvk,⋅,j)[ka×b×1]\\log u_{k,,\\cdot} \\leftarrow \\log r^{(k)}_{\\text{batch},} - \\text{logsumexp}_j\\!\\left(\\log K^{3D}_{k,,j} + \\log v_{k,\\cdot,j}\\right) \\quad [k_a \\times b \\times 1]logvk,⋅,j←logcbatch,j(k)−logsumexpi(logKk,,j3D+loguk,,⋅)[ka×1×M]\\log v_{k,\\cdot,j} \\leftarrow \\log c^{(k)}_{\\text{batch},j} - \\text{logsumexp}_i\\!\\left(\\log K^{3D}_{k,,j} + \\log u_{k,,\\cdot}\\right) \\quad [k_a \\times 1 \\times M] Recover per-bracket weights aggregate across brackets: Wk,,jall=exp(loguk,,⋅+logKk,,j3D+logvk,⋅,j)[ka×b×M]W^{\\text{}}_{k,,j} = \\exp\\!\\left(\\log u_{k,,\\cdot} + \\log K^{3D}_{k,,j} + \\log v_{k,\\cdot,j}\\right) \\quad [k_a \\times b \\times M]Wijbatch=∑k=1kaWk,,jall[b×M]W^{\\text{batch}}_{ij} = \\sum_{k=1}^{k_a} W^{\\text{}}_{k,,j} \\quad [b \\times M] Column-normalize: Wijnorm=Wijbatch/∑′Wi′jbatch[b×M]W^{\\text{norm}}_{ij} = W^{\\text{batch}}_{ij} \\bigg/ \\sum_{'} W^{\\text{batch}}_{'j} \\quad [b \\times M]","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"mini-batch-loss","dir":"Articles","previous_headings":"Part VII: Practical > 20. Mathematical Appendix","what":"Mini-batch loss","title":"Methodology","text":"V̂=Wnorm⋅(S⋅b/N)[b×K]\\hat{V} = W^{\\text{norm}} \\cdot (S \\cdot b/N) \\quad [b \\times K]fbatch=Nb∑∈ℬ∑k(V̂ik−Pik)2f_{\\text{batch}} = \\frac{N}{b} \\sum_{\\\\mathcal{B}} \\sum_k (\\hat{V}_{ik} - P_{ik})^2 scaling factors b/Nb/N N/bN/b ensure gradient unbiased estimator full-data gradient.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"objective-function-full-data","dir":"Articles","previous_headings":"Part VII: Practical > 20. Mathematical Appendix","what":"Objective function (full data)","title":"Methodology","text":"f(α)=∥W(α)⋅S−P∥F2=∑=1N∑k=1K(∑j=1MWijSjk−Pik)2f(\\alpha) = \\| W(\\alpha) \\cdot S - P \\|_F^2 = \\sum_{=1}^N \\sum_{k=1}^K \\left( \\sum_{j=1}^M W_{ij} S_{jk} - P_{ik} \\right)^2 W(α)∈ℝN×MW(\\alpha) \\\\mathbb{R}^{N \\times M} per-bracket Sinkhorn weight matrix.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/methodology.html","id":"gradient","dir":"Articles","previous_headings":"Part VII: Practical > 20. Mathematical Appendix","what":"Gradient","title":"Methodology","text":"Computed torch autograd unrolled per-bracket Sinkhorn iterations 3D tensors. operation (log, exp, logsumexp, matrix multiply, subtraction, squaring) defined backward pass torch: ∇αf=∂∂α∥pb_sinkhorn(kernel(α),P,S)⋅S−P∥F2\\nabla_\\alpha f = \\frac{\\partial}{\\partial \\alpha} \\| \\text{pb\\_sinkhorn}(\\text{kernel}(\\alpha), P, S) \\cdot S - P \\|_F^2 gradient flows backward sk_iter Sinkhorn iterations. components corresponding sampled batch indices ℬ\\mathcal{B} used update ADAM moments (gradient masking).","code":""},{"path":"https://antrologos.github.io/interpElections/articles/working-with-results.html","id":"loading-results","dir":"Articles","previous_headings":"","what":"Loading Results","title":"Working with Results","text":"","code":"# Run the pipeline (these were computed with GPU) result_nit <- interpolate_election_br(   \"Niteroi\", year = 2022, cargo = \"presidente\",   what = c(\"candidates\", \"parties\", \"turnout\", \"demographics\"),   keep = c(\"weights\", \"sources_sf\", \"time_matrix\"),   use_gpu = TRUE )  result_bh <- interpolate_election_br(   \"Belo Horizonte\", year = 2022, cargo = \"presidente\",   what = c(\"candidates\", \"turnout\"),   keep = c(\"weights\", \"sources_sf\"),   use_gpu = TRUE )"},{"path":"https://antrologos.github.io/interpElections/articles/working-with-results.html","id":"print-and-summary","dir":"Articles","previous_headings":"","what":"Print and Summary","title":"Working with Results","text":"print() method gives compact overview: summary() method adds per-variable statistics grouped type: dictionary groups columns type (candidate, party, turnout, demographics, calibration) metadata like candidate name, party abbreviation, ballot number:","code":"result_nit interpElections result -- Brazilian election   Municipality: NITERÓI (RJ)   IBGE: 3303302 | TSE: 58653 | Election: 2022 | Census: 2022   Census tracts: 1169 | Sources: 135    Variables: 63     Candidates:    13 (CAND_27, CAND_14, CAND_30, CAND_13, ...)     Parties:       11 (PARTY_27, PARTY_14, PARTY_30, PARTY_13, ...)     Turnout:       1 (QT_COMPARECIMENTO)     Demographics:  10 (GENERO_FEMININO, GENERO_MASCULINO, ...)     Calibration:   28 (vot_hom_alf_18_19, vot_hom_alf_20_24, ...)    Optimizer: pb_sgd_sinkhorn_cuda (obj = 1265038.68)   Alpha:     [0.010, 17.623] (mean 2.507) summary(result_nit) View(result_nit$dictionary)"},{"path":[]},{"path":"https://antrologos.github.io/interpElections/articles/working-with-results.html","id":"single-variable","dir":"Articles","previous_headings":"Plotting","what":"Single variable","title":"Working with Results","text":"Variables can referenced : Column name: \"CAND_13\", \"PARTY_PT\", \"QT_COMPARECIMENTO\" Ballot number: 13, 22 Candidate name (substring, case-insensitive): \"Lula\", \"Bolsonaro\" Party abbreviation: \"PT\", \"PL\"","code":"plot(result_nit, variable = \"Lula\")"},{"path":"https://antrologos.github.io/interpElections/articles/working-with-results.html","id":"absolute-counts","dir":"Articles","previous_headings":"Plotting","what":"Absolute counts","title":"Working with Results","text":"","code":"plot(result_nit, variable = \"Lula\", type = \"absolute\")"},{"path":"https://antrologos.github.io/interpElections/articles/working-with-results.html","id":"faceted-comparison","dir":"Articles","previous_headings":"Plotting","what":"Faceted comparison","title":"Working with Results","text":"","code":"plot(result_nit, variable = c(\"Lula\", \"Bolsonaro\"), type = \"pct_tract\")"},{"path":"https://antrologos.github.io/interpElections/articles/working-with-results.html","id":"plot-types","dir":"Articles","previous_headings":"Plotting","what":"Plot types","title":"Working with Results","text":"type parameter controls quantity mapped:","code":""},{"path":"https://antrologos.github.io/interpElections/articles/working-with-results.html","id":"break-methods","dir":"Articles","previous_headings":"Plotting","what":"Break methods","title":"Working with Results","text":"breaks parameter controls color scale: \"quantile\" (default): equal-count bins \"continuous\": smooth gradient \"jenks\": natural breaks (requires classInt package) Custom numeric vector: breaks = c(0, 20, 40, 60, 80, 100)","code":"plot(result_nit, variable = \"Lula\", breaks = \"continuous\") plot(result_nit, variable = \"Lula\", breaks = \"jenks\")"},{"path":"https://antrologos.github.io/interpElections/articles/working-with-results.html","id":"additional-options","dir":"Articles","previous_headings":"Plotting","what":"Additional options","title":"Working with Results","text":"","code":"# Overlay polling stations plot(result_nit, variable = \"Lula\", show_sources = TRUE)  # Zoom into a region (lon/lat bounding box) plot(result_nit, variable = \"Lula\",      limits = c(-43.15, -43.05, -22.92, -22.86))  # Custom palette plot(result_nit, variable = \"Lula\", palette = \"viridis\") plot(result_nit, variable = \"Lula\", palette = \"Spectral\")  # Composable with ggplot2 library(ggplot2) plot(result_nit, variable = \"Lula\") + theme_dark()"},{"path":"https://antrologos.github.io/interpElections/articles/working-with-results.html","id":"interactive-maps","dir":"Articles","previous_headings":"Plotting","what":"Interactive maps","title":"Working with Results","text":"","code":"# Opens in browser with hover tooltips and zoom plot_interactive(result_nit, variable = \"Lula\")"},{"path":"https://antrologos.github.io/interpElections/articles/working-with-results.html","id":"large-scale-example-belo-horizonte","dir":"Articles","previous_headings":"Plotting","what":"Large-scale example (Belo Horizonte)","title":"Working with Results","text":"","code":"plot(result_bh, variable = \"Lula\")"},{"path":"https://antrologos.github.io/interpElections/articles/working-with-results.html","id":"extracting-alpha","dir":"Articles","previous_headings":"","what":"Extracting Alpha","title":"Working with Results","text":"coef() method returns optimized decay parameters:  Map alpha values spatially see urban/peripheral gradient:  Interpretation: Low alpha (blue) = weight spread across many stations (dense urban areas). High alpha (red) = weight concentrated nearest station (periphery).","code":"alpha <- coef(result_nit) summary(alpha) result_nit$tracts_sf$alpha <- coef(result_nit) ggplot(result_nit$tracts_sf) +   geom_sf(aes(fill = alpha), color = \"white\", linewidth = 0.05) +   scale_fill_distiller(palette = \"RdYlBu\", direction = -1) +   theme_void()"},{"path":"https://antrologos.github.io/interpElections/articles/working-with-results.html","id":"residual-analysis","dir":"Articles","previous_headings":"","what":"Residual Analysis","title":"Working with Results","text":"residuals() method computes calibration residuals (fitted minus observed) tract age bracket. Requires keep = \"weights\" keep = \"time_matrix\".  Residuals centered near zero. Large residuals may indicate boundary effects (voters crossing municipality borders), data quality issues, census/election year mismatches.","code":"resid <- residuals(result_nit) str(resid) #> num [1:1169, 1:28] ...  # Per-bracket summary colMeans(resid)                        # mean residual per bracket sqrt(colMeans(resid^2))                # RMSE per bracket"},{"path":"https://antrologos.github.io/interpElections/articles/working-with-results.html","id":"validation-checklist","dir":"Articles","previous_headings":"","what":"Validation Checklist","title":"Working with Results","text":"Five checks apply result:","code":"# 1. Total conservation: interpolated totals match source totals colSums(result_nit$interpolated)[1:3] colSums(result_nit$sources[, result_nit$interp_cols[1:3]])  # 2. Residual magnitude resid <- residuals(result_nit) sqrt(mean(resid^2))   # overall RMSE  # 3. Alpha distribution (no extreme piling at bounds) summary(coef(result_nit))  # 4. Non-negative values all(result_nit$interpolated >= -1e-10)  # 5. Convergence result_nit$optimization$convergence   # 0 = success"},{"path":"https://antrologos.github.io/interpElections/articles/working-with-results.html","id":"exporting-results","dir":"Articles","previous_headings":"","what":"Exporting Results","title":"Working with Results","text":"","code":"# Plain data frame (no geometry) df <- as.data.frame(result_nit) write.csv(df, \"niteroi_2022.csv\", row.names = FALSE)  # GeoPackage with geometry (for GIS) sf::st_write(result_nit$tracts_sf, \"niteroi_2022.gpkg\")  # Column metadata result_nit$dictionary  # Source-level data (without geometry) head(result_nit$sources)"},{"path":"https://antrologos.github.io/interpElections/articles/working-with-results.html","id":"areal-aggregation-from-tracts-to-neighborhoods","dir":"Articles","previous_headings":"","what":"Areal Aggregation: From Tracts to Neighborhoods","title":"Working with Results","text":"Tract-level results can reaggregated larger zones (neighborhoods, administrative regions, custom polygons) using areal_weights() areal_interpolate(). Example: Belo Horizonte tracts neighborhoods weight matrix W_areal [n_neighborhoods x n_tracts]. column sums 1 (tract’s data distributed proportionally area overlap). areal_interpolate() simply W_areal %*% data. approach preserves total conservation: neighborhood-level totals equal tract-level totals, equal original municipality totals.","code":"library(sf) library(geobr)  # Download BH neighborhood boundaries bairros <- read_neighborhood(year = 2010) bairros <- bairros[bairros$code_muni == 3106200, ]  # Compute area-weighted intersection matrix W_areal <- areal_weights(   target_sf = bairros,   source_sf = result_bh$tracts_sf,   target_id = \"code_neighborhood\",   source_id = \"code_tract\" )  # Aggregate interpolated data vote_data <- result_bh$interpolated aggregated <- areal_interpolate(vote_data, W_areal)  # Conservation check colSums(aggregated)[1:3] colSums(vote_data)[1:3]   # should match"},{"path":"https://antrologos.github.io/interpElections/articles/working-with-results.html","id":"the-keep-parameter","dir":"Articles","previous_headings":"","what":"The keep Parameter","title":"Working with Results","text":"Control intermediate objects retained result: Default: NULL (lightweight, nothing kept). Recommended: enables residual analysis source point overlays without excessive memory use.","code":"result <- interpolate_election_br(\"Niteroi\", year = 2022,   keep = c(\"weights\", \"sources_sf\"))"},{"path":"https://antrologos.github.io/interpElections/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Rogerio Barbosa. Author, maintainer. Lucas Gelape. Author.","code":""},{"path":"https://antrologos.github.io/interpElections/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Barbosa R, Gelape L (2026). interpElections: Spatial Interpolation Electoral Data via Inverse Distance Weighting. R package version 0.1.0, https://antrologos.github.io/interpElections/.","code":"@Manual{,   title = {interpElections: Spatial Interpolation of Electoral Data via Inverse Distance Weighting},   author = {Rogerio Barbosa and Lucas Gelape},   year = {2026},   note = {R package version 0.1.0},   url = {https://antrologos.github.io/interpElections/}, }"},{"path":"https://antrologos.github.io/interpElections/index.html","id":"interpelections","dir":"","previous_headings":"","what":"Spatial Interpolation of Electoral Data via Inverse Distance Weighting","title":"Spatial Interpolation of Electoral Data via Inverse Distance Weighting","text":"Spatial interpolation electoral data via Sinkhorn-balanced inverse distance weighting. Disaggregates point-level data (e.g., polling station vote counts) polygon-level estimates (e.g., census tracts) using travel-time-based IDW per-zone decay parameters calibrated demographic totals. Sinkhorn balancing enforces population conservation source conservation simultaneously.","code":""},{"path":"https://antrologos.github.io/interpElections/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Spatial Interpolation of Electoral Data via Inverse Distance Weighting","text":"Optional: setup_torch() GPU optimization, setup_java() r5r travel-time routing, setup_osmium() OSM data clipping.","code":"# install.packages(\"remotes\") remotes::install_github(\"antrologos/interpElections\")"},{"path":"https://antrologos.github.io/interpElections/index.html","id":"quick-example-brazilian-election","dir":"","previous_headings":"","what":"Quick example: Brazilian election","title":"Spatial Interpolation of Electoral Data via Inverse Distance Weighting","text":"Three lines: downloads census data, electoral results, road networks; computes travel times; optimizes per-tract decay; interpolates variables census tracts.","code":"library(interpElections)  result <- interpolate_election_br(\"Varginha\", year = 2022,   cargo = \"presidente\", what = c(\"candidates\", \"turnout\"))  summary(result) plot(result, variable = \"Lula\")"},{"path":"https://antrologos.github.io/interpElections/index.html","id":"quick-example-custom-data","dir":"","previous_headings":"","what":"Quick example: Custom data","title":"Spatial Interpolation of Electoral Data via Inverse Distance Weighting","text":"","code":"result <- interpolate_election(   tracts_sf     = my_zones,   electoral_sf  = my_sources,   tract_id      = \"zone_id\",   point_id      = \"source_id\",   calib_tracts  = c(\"pop_young\", \"pop_old\"),   calib_sources = c(\"count_young\", \"count_old\"),   time_matrix   = my_travel_times )"},{"path":"https://antrologos.github.io/interpElections/index.html","id":"how-it-works","dir":"","previous_headings":"","what":"How it works","title":"Spatial Interpolation of Electoral Data via Inverse Distance Weighting","text":"tract source j, IDW kernel : Wij=(tij+1)−αiW_{ij} = (t_{ij} + 1)^{-\\alpha_i} Sinkhorn balancing iteratively scales rows columns row sums proportional population column sums equal 1 (source distributes exactly 100% data). optimal alpha found minimizing squared error interpolated census demographics via torch ADAM log-domain Sinkhorn differentiation.","code":""},{"path":[]},{"path":[]},{"path":"https://antrologos.github.io/interpElections/index.html","id":"gpu-acceleration","dir":"","previous_headings":"","what":"GPU acceleration","title":"Spatial Interpolation of Electoral Data via Inverse Distance Weighting","text":"GPU (CUDA/MPS) recommended municipalities >1,000 census tracts. CPU works problem sizes.","code":"setup_torch()     # one-time installation use_gpu(TRUE)     # enable globally"},{"path":"https://antrologos.github.io/interpElections/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Spatial Interpolation of Electoral Data via Inverse Distance Weighting","text":"Barbosa, R. & Gelape, L. (2025). interpElections: Spatial Interpolation Electoral Data via Sinkhorn-Balanced Inverse Distance Weighting. R package version 0.1.0. https://github.com/antrologos/interpElections","code":""},{"path":"https://antrologos.github.io/interpElections/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Spatial Interpolation of Electoral Data via Inverse Distance Weighting","text":"MIT","code":""},{"path":"https://antrologos.github.io/interpElections/reference/areal_interpolate.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate data from source zones to target polygons using areal weights — areal_interpolate","title":"Aggregate data from source zones to target polygons using areal weights — areal_interpolate","text":"Applies precomputed areal weight matrix (areal_weights()) transfer data source zones target polygons.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/areal_interpolate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate data from source zones to target polygons using areal weights — areal_interpolate","text":"","code":"areal_interpolate(data, weights)"},{"path":"https://antrologos.github.io/interpElections/reference/areal_interpolate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate data from source zones to target polygons using areal weights — areal_interpolate","text":"data Numeric matrix data.frame [n_source x p]. Data source zones. Rows must correspond columns weights. weights Numeric matrix [n_target x n_source]. Output areal_weights().","code":""},{"path":"https://antrologos.github.io/interpElections/reference/areal_interpolate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate data from source zones to target polygons using areal weights — areal_interpolate","text":"Numeric matrix [n_target x p]. Aggregated values target polygons.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/areal_interpolate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregate data from source zones to target polygons using areal weights — areal_interpolate","text":"","code":"W <- matrix(c(0.7, 0.3, 0.2, 0.8), nrow = 2)  # 2 targets x 2 sources src_data <- matrix(c(100, 200), nrow = 2)        # 2 sources x 1 variable areal_interpolate(src_data, W) #>      [,1] #> [1,]  110 #> [2,]  190"},{"path":"https://antrologos.github.io/interpElections/reference/areal_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute area-weighted intersection matrix between two polygon layers — areal_weights","title":"Compute area-weighted intersection matrix between two polygon layers — areal_weights","text":"Builds weight matrix maps values source polygons (e.g., census tracts) target polygons (e.g., custom analysis zones) based fraction area shared .","code":""},{"path":"https://antrologos.github.io/interpElections/reference/areal_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute area-weighted intersection matrix between two polygon layers — areal_weights","text":"","code":"areal_weights(target_sf, source_sf, target_id = \"id\", source_id = \"id\")"},{"path":"https://antrologos.github.io/interpElections/reference/areal_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute area-weighted intersection matrix between two polygon layers — areal_weights","text":"target_sf sf object polygon geometries. target zones aggregate . source_sf sf object polygon geometries. source zones (e.g., census tracts interpolated data). target_id Character. Name ID column target_sf. source_id Character. Name ID column source_sf.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/areal_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute area-weighted intersection matrix between two polygon layers — areal_weights","text":"numeric matrix [n_target x n_source]. column standardized weights target zones sum 1 (0 source zone overlap). Row names = target IDs, column names = source IDs.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/areal_weights.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute area-weighted intersection matrix between two polygon layers — areal_weights","text":"Requires sf package. Geometries made valid sf::st_make_valid() computing intersections.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/as.data.frame.interpElections_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert result to data frame — as.data.frame.interpElections_result","title":"Convert result to data frame — as.data.frame.interpElections_result","text":"Drops geometry tracts_sf returns plain data frame census tract IDs interpolated values.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/as.data.frame.interpElections_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert result to data frame — as.data.frame.interpElections_result","text":"","code":"# S3 method for class 'interpElections_result' as.data.frame(x, ...)"},{"path":"https://antrologos.github.io/interpElections/reference/as.data.frame.interpElections_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert result to data frame — as.data.frame.interpElections_result","text":"x interpElections_result object. ... Ignored.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/as.data.frame.interpElections_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert result to data frame — as.data.frame.interpElections_result","text":"data frame.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_download_geocode.html","id":null,"dir":"Reference","previous_headings":"","what":"Download geocoded polling station data from TSE — br_download_geocode","title":"Download geocoded polling station data from TSE — br_download_geocode","text":"Downloads official polling station location data (eleitorado por local de votação) TSE open data portal. file includes geographic coordinates (NR_LATITUDE, NR_LONGITUDE) polling locations, along voter counts addresses.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_download_geocode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Download geocoded polling station data from TSE — br_download_geocode","text":"","code":"br_download_geocode(   year,   uf = NULL,   code_muni_tse = NULL,   force = FALSE,   cache = TRUE,   verbose = TRUE )"},{"path":"https://antrologos.github.io/interpElections/reference/br_download_geocode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Download geocoded polling station data from TSE — br_download_geocode","text":"year Integer. Election year (e.g., 2010, 2012, 2016, 2020). uf Character NULL. Two-letter state abbreviation. provided, filters results state. code_muni_tse Character NULL. 5-digit TSE municipality code. provided, filters results municipality . force Logical. Re-download even cached file exists. Default: FALSE. cache Logical. TRUE (default), downloaded files stored persistently. See get_interpElections_cache_dir(). verbose Logical. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_download_geocode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Download geocoded polling station data from TSE — br_download_geocode","text":"data frame one row per section per round, using original TSE column names. Returns NULL data available given year (e.g., 2010). Key columns: CD_MUNICIPIO TSE municipality code (5-digit) NR_ZONA Electoral zone number NR_LOCAL_VOTACAO Polling location number NR_SECAO Section number NR_LATITUDE Latitude polling location (-1 missing) NR_LONGITUDE Longitude polling location (-1 missing) NM_LOCAL_VOTACAO Name polling location DS_ENDERECO Address polling location","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_download_geocode.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Download geocoded polling station data from TSE — br_download_geocode","text":"TSE data available 2010 onward. years 2010 (e.g., 2008), function returns NULL caller can fall back alternative sources. Data downloaded https://cdn.tse.jus.br/estatistica/sead/odsele/eleitorado_locais_votacao/. Files cached persistently default reused subsequent calls unless force = TRUE. Use interpElections_cache() manage cached files. CSV files use semicolon (;) delimiter Latin-1 encoding. Missing coordinates stored -1 TSE data.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/br_download_party_legends.html","id":null,"dir":"Reference","previous_headings":"","what":"Download party legends from TSE — br_download_party_legends","title":"Download party legends from TSE — br_download_party_legends","text":"Downloads official party legend data (consulta de legendas) TSE open data portal given election year. file maps party numbers (NR_PARTIDO) abbreviations (SG_PARTIDO) full names (NM_PARTIDO).","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_download_party_legends.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Download party legends from TSE — br_download_party_legends","text":"","code":"br_download_party_legends(year, force = FALSE, cache = TRUE, verbose = TRUE)"},{"path":"https://antrologos.github.io/interpElections/reference/br_download_party_legends.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Download party legends from TSE — br_download_party_legends","text":"year Integer. Election year (e.g., 2008, 2012, 2016, 2020, 2022). force Logical. Re-download even cached file exists. Default: FALSE. cache Logical. TRUE (default), downloaded files stored persistently. See get_interpElections_cache_dir(). verbose Logical. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_download_party_legends.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Download party legends from TSE — br_download_party_legends","text":"data frame TSE party/coalition data. Key columns: NR_PARTIDO Party number (2-digit) SG_PARTIDO Party abbreviation (e.g., \"PT\", \"MDB\") NM_PARTIDO Full party name","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_download_party_legends.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Download party legends from TSE — br_download_party_legends","text":"Data downloaded https://cdn.tse.jus.br/estatistica/sead/odsele/consulta_coligacao/. file contains coalition/party records election year, unique party number--abbreviation mapping extracted. Files cached persistently default reused subsequent calls unless force = TRUE.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/br_download_turnout.html","id":null,"dir":"Reference","previous_headings":"","what":"Download turnout/attendance data from TSE — br_download_turnout","title":"Download turnout/attendance data from TSE — br_download_turnout","text":"Downloads official turnout detail data (detalhe da votação por seção) TSE open data portal. file provides attendance counts, abstentions, vote type breakdowns per polling section.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_download_turnout.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Download turnout/attendance data from TSE — br_download_turnout","text":"","code":"br_download_turnout(   year,   uf = NULL,   code_muni_tse = NULL,   cargo = NULL,   turno = 1L,   force = FALSE,   cache = TRUE,   verbose = TRUE )"},{"path":"https://antrologos.github.io/interpElections/reference/br_download_turnout.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Download turnout/attendance data from TSE — br_download_turnout","text":"year Integer. Election year (e.g., 2008, 2012, 2016, 2020). uf Character NULL. Two-letter state abbreviation. Used filter nationwide file single state. code_muni_tse Character NULL. 5-digit TSE municipality code. provided, filters results municipality . cargo Integer NULL. Electoral office code filter. NULL, uses office (turnout across offices). turno Integer. Election round (1 2). Default: 1. force Logical. Re-download even cached file exists. Default: FALSE. cache Logical. TRUE (default), downloaded files stored persistently. See get_interpElections_cache_dir(). verbose Logical. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_download_turnout.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Download turnout/attendance data from TSE — br_download_turnout","text":"data frame one row per section per office, using original TSE column names. Key columns: ANO_ELEICAO Election year CD_MUNICIPIO TSE municipality code (5-digit) NR_ZONA Electoral zone number NR_SECAO Section number CD_CARGO Office code QT_COMPARECIMENTO Number voters attended QT_APTOS Number eligible voters QT_ABSTENCOES Number abstentions","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_download_turnout.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Download turnout/attendance data from TSE — br_download_turnout","text":"TSE publishes data single nationwide file https://cdn.tse.jus.br/estatistica/sead/odsele/detalhe_votacao_secao/. file can large (hundreds MB). Results filtered municipality /state immediately reading.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/br_download_votes.html","id":null,"dir":"Reference","previous_headings":"","what":"Download candidate vote data from TSE — br_download_votes","title":"Download candidate vote data from TSE — br_download_votes","text":"Downloads official candidate vote data (votação por seção eleitoral) TSE open data portal given election year state. data downloaded ZIP file containing semicolon-delimited CSV.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_download_votes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Download candidate vote data from TSE — br_download_votes","text":"","code":"br_download_votes(   year,   uf,   code_muni_tse = NULL,   cargo = NULL,   turno = 1L,   force = FALSE,   cache = TRUE,   verbose = TRUE )"},{"path":"https://antrologos.github.io/interpElections/reference/br_download_votes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Download candidate vote data from TSE — br_download_votes","text":"year Integer. Election year (e.g., 2008, 2012, 2016, 2020). uf Character. Two-letter state abbreviation (e.g., \"SP\", \"RJ\"), \"BR\" download national file (used presidential data). code_muni_tse Character NULL. 5-digit TSE municipality code. provided, filters results municipality . cargo Integer NULL. Electoral office code filter (e.g., 13 = Vereador, 11 = Prefeito). NULL, returns offices. turno Integer. Election round (1 2). Default: 1. force Logical. Re-download even cached file exists. Default: FALSE. cache Logical. TRUE (default), downloaded files stored persistent cross-session cache directory (see get_interpElections_cache_dir()). FALSE, files stored temporary directory lost R restarts. verbose Logical. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_download_votes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Download candidate vote data from TSE — br_download_votes","text":"data frame one row per candidate per polling section, using original TSE column names. Key columns: ANO_ELEICAO Election year CD_MUNICIPIO TSE municipality code (5-digit) NR_ZONA Electoral zone number NR_SECAO Section number NR_LOCAL_VOTACAO Polling location number CD_CARGO Office code NR_VOTAVEL Candidate number (95 = blank, 96 = null) NM_VOTAVEL Candidate name QT_VOTOS Number votes","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_download_votes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Download candidate vote data from TSE — br_download_votes","text":"Data downloaded https://cdn.tse.jus.br/estatistica/sead/odsele/votacao_secao/. Files cached persistently default reused subsequent calls unless force = TRUE. Use interpElections_cache() manage cached files. CSV files use semicolon (;) delimiter Latin-1 encoding. Note: general elections, presidential vote data (cargo 1) published national file (uf = \"BR\") rather per-state files. br_prepare_electoral() handles automatically.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_electoral.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare Brazilian electoral data at the polling-location level — br_prepare_electoral","title":"Prepare Brazilian electoral data at the polling-location level — br_prepare_electoral","text":"Downloads TSE voter profile, attendance, candidate vote data, merges geocoded polling station coordinates, aggregates voting-location level. Returns data frame ready interpolation.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_electoral.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare Brazilian electoral data at the polling-location level — br_prepare_electoral","text":"","code":"br_prepare_electoral(   code_muni_ibge,   code_muni_tse,   uf,   year,   cargo = NULL,   turno = 1L,   what = \"candidates\",   candidates = NULL,   parties = NULL,   perfil_path = NULL,   comparecimento_path = NULL,   votacao_path = NULL,   geocode_path = NULL,   cache = TRUE,   force = FALSE,   verbose = TRUE )"},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_electoral.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare Brazilian electoral data at the polling-location level — br_prepare_electoral","text":"code_muni_ibge Character. 7-digit IBGE municipality code (e.g., \"3550308\" Sao Paulo). code_muni_tse Character. 5-digit TSE municipality code (e.g., \"71072\" Sao Paulo). Typically obtained via interpolate_election_br(), resolves automatically. uf Character. Two-letter state abbreviation (e.g., \"SP\", \"RJ\", \"MG\"). year Integer. Election year. See interpolate_election_br() distinction municipal general election years. cargo Integer, character, NULL. electoral office(s) include. Accepts human-readable aliases (case-insensitive), TSE numeric codes, vector either: NULL (default), offices present data file included. general election years, automatically downloads national file presidential data. multiple cargos selected, output columns prefixed (e.g., PREFEITO_CAND_*, VEREADOR_CAND_*). turno Integer. Election round: 1 (first round, default) 2 (runoff). runoff exists presidente, governador, prefeito (cities >200k voters), candidate wins outright first round. Character vector. Controls data columns produced output. One : \"candidates\" (default): One column per candidate vote counts, named CAND_<ballot_number>. Also includes QT_COMPARECIMENTO (total turnout). Special ballot numbers: 95 = blank votes (em branco), 96 = null votes (nulo). \"parties\": One column per party total votes, named PARTY_<abbreviation> (e.g., PARTY_PT, PARTY_MDB). Also includes QT_COMPARECIMENTO. \"turnout\": Turnout statistics: QT_COMPARECIMENTO (voters showed ), QT_APTOS (eligible voters), QT_ABSTENCOES (abstentions), available data. \"demographics\": Voter profile gender (GENERO_FEMININO, GENERO_MASCULINO, GENERO_NAO_INFORMADO) education level (EDUC_ANALFABETO, EDUC_LE_ESCREVE, EDUC_FUND_INCOMP, EDUC_FUND_COMP, EDUC_MEDIO_INCOMP, EDUC_MEDIO_COMP, EDUC_SUP_INCOMP, EDUC_SUP_COMP, EDUC_NAO_INFORMADO). Note: demographics come voter registration profile, vote data, cargo filter applies. Values can combined: = c(\"candidates\", \"parties\", \"turnout\", \"demographics\"). candidates Character numeric vector, NULL. Filter specific candidates (applies \"candidates\" %% ): Numeric values match candidate's ballot number exactly. Example: candidates = c(13, 22). Character values perform accent-normalized, case-insensitive substring matching candidate's registered name. Example: candidates = \"LULA\" matches \"LUIZ INACIO LULA DA SILVA\". NULL (default): candidates kept. parties Character vector NULL. Filter specific parties (applies \"parties\" %% ). Uses official TSE party abbreviations, matched case-insensitively. Example: parties = c(\"PT\", \"PL\", \"MDB\"). NULL (default): parties kept. perfil_path Character NULL. Path local voter profile CSV file. NULL (default), downloads TSE. comparecimento_path Character NULL. Path attendance parquet file. NULL (default), turnout computed vote data . votacao_path Character NULL. Path candidate votes parquet file. NULL (default), downloads TSE. geocode_path Character NULL. Path CSV geocoded polling station coordinates (columns: nr_zona, nr_local_votacao, lat, long). NULL, coordinates obtained TSE Danny Hidalgo's geocoding project. cache Logical. TRUE (default), downloaded files stored persistently. See get_interpElections_cache_dir(). force Logical. Re-download even cached file exists. Default: FALSE. verbose Logical. Print progress messages. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_electoral.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare Brazilian electoral data at the polling-location level — br_prepare_electoral","text":"data frame one row per voting location (per polling section). Contains following column groups: Always present: lat, long: Coordinates voting location. id: Sequential integer ID. votantes_18_20, ..., votantes_65_69: Registered voters per age bracket location (used calibration data). vot_hom_alf_*, vot_hom_nalf_*, vot_mul_alf_*, vot_mul_nalf_*: Cross-tabulated voters gender, literacy, age bracket (used \"full\" calibration mode). 48 columns total (12 age groups x 4 gender-literacy categories). Conditional : \"candidates\": CAND_<number> columns + QT_COMPARECIMENTO. \"parties\": PARTY_<abbrev> columns + QT_COMPARECIMENTO. \"turnout\": QT_COMPARECIMENTO, QT_APTOS, QT_ABSTENCOES. \"demographics\": GENERO_* EDUC_* columns. multiple cargo values selected, candidate party columns prefixed (e.g., PREFEITO_CAND_45, VEREADOR_PARTY_PT).","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_electoral.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prepare Brazilian electoral data at the polling-location level — br_prepare_electoral","text":"users use interpolate_election_br() instead, calls function internally runs full interpolation pipeline. Use br_prepare_electoral() directly need raw polling-location data without interpolation. votacao_path comparecimento_path NULL, data auto-downloaded official TSE open data portal using br_download_votes() br_download_turnout().","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_electoral.html","id":"data-sources","dir":"Reference","previous_headings":"","what":"Data sources","title":"Prepare Brazilian electoral data at the polling-location level — br_prepare_electoral","text":"data downloaded TSE open data portal https://cdn.tse.jus.br/estatistica/sead/odsele/. Presidential vote data (cargo 1) published separate national file (votacao_secao_<year>_BR.zip, ~250 MB) rather per-state files. function detects presidential data needed downloads national file automatically. Geocoded polling station coordinates come two sources: official TSE data (available ~2020 onwards, missing coordinates) Danny Hidalgo's geocoding project (https://github.com/fdhidalgo/geocode_br_polling_stations), covers earlier years. TSE coordinates take priority available.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_electoral.html","id":"dependencies","dir":"Reference","previous_headings":"","what":"Dependencies","title":"Prepare Brazilian electoral data at the polling-location level — br_prepare_electoral","text":"Requires dplyr, tidyr, data.table, stringr packages. reading local parquet files, arrow package also required.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_electoral.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare Brazilian electoral data at the polling-location level — br_prepare_electoral","text":"","code":"if (FALSE) { # \\dontrun{ # ── Basic usage ──────────────────────────────────────────────── # All candidates in the 2020 municipal election for Boa Vista elec <- br_prepare_electoral(   code_muni_ibge = \"1400100\",   code_muni_tse  = \"01120\",   uf = \"RR\",   year = 2020,   what = c(\"candidates\", \"turnout\") )  # ── Specific cargo ───────────────────────────────────────────── # Only the presidential race in 2022 elec <- br_prepare_electoral(   code_muni_ibge = \"3170701\",   code_muni_tse  = \"54135\",   uf = \"MG\",   year = 2022,   cargo = \"presidente\" )  # ── Filter specific candidates ───────────────────────────────── # Only Lula and Bolsonaro in the 2022 presidential race elec <- br_prepare_electoral(   code_muni_ibge = \"3170701\",   code_muni_tse  = \"54135\",   uf = \"MG\",   year = 2022,   cargo = \"presidente\",   candidates = c(13, 22) )  # ── Party vote totals ────────────────────────────────────────── elec <- br_prepare_electoral(   code_muni_ibge = \"3170701\",   code_muni_tse  = \"54135\",   uf = \"MG\",   year = 2020,   cargo = \"vereador\",   what = \"parties\",   parties = c(\"PT\", \"MDB\", \"PL\") )  # ── Voter demographics ───────────────────────────────────────── elec <- br_prepare_electoral(   code_muni_ibge = \"3170701\",   code_muni_tse  = \"54135\",   uf = \"MG\",   year = 2022,   what = \"demographics\" ) # -> GENERO_FEMININO, GENERO_MASCULINO, EDUC_SUP_COMP, ... } # }"},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_population.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare Brazilian census population data by age bracket per census tract — br_prepare_population","title":"Prepare Brazilian census population data by age bracket per census tract — br_prepare_population","text":"Downloads census population data IBGE (via censobr package), groups ages brackets, returns data frame one row per census tract. Supports census years 2000, 2010, 2022.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_population.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare Brazilian census population data by age bracket per census tract — br_prepare_population","text":"","code":"br_prepare_population(code_muni, year = 2010)"},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_population.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare Brazilian census population data by age bracket per census tract — br_prepare_population","text":"code_muni Numeric character vector. IBGE municipality codes. year Integer. Census year: 2000, 2010, 2022. Default: 2010.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_population.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare Brazilian census population data by age bracket per census tract — br_prepare_population","text":"data frame columns: code_muni, code_tract, population bracket columns (pop_*). exact brackets depend census year (see Details).","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_population.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prepare Brazilian census population data by age bracket per census tract — br_prepare_population","text":"Requires censobr, dplyr, tidyr, data.table packages. Census 2000 2010 produce following voting-age brackets: pop_18_20, pop_21_24, pop_25_29, pop_30_39, pop_40_49, pop_50_59, pop_60_69. Census 2022 produces: pop_15_19, pop_20_24, pop_25_29, pop_30_39, pop_40_49, pop_50_59, pop_60_69. years also produce: pop_00_04, pop_05_09, pop_10_14, pop_15_17 (pop_15_19 2022), pop_70mais. Additionally, years produce gender x literacy columns voting-age brackets: pop_hom_alf_*, pop_hom_nalf_*, pop_mul_alf_*, pop_mul_nalf_* (literate/illiterate men/women). used \"full\" calibration mode interpolate_election_br().","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_population.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare Brazilian census population data by age bracket per census tract — br_prepare_population","text":"","code":"if (FALSE) { # \\dontrun{ # Census 2010 population for Sao Paulo pop <- br_prepare_population(code_muni = \"3550308\", year = 2010) head(pop) } # }"},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_tracts.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare census tract shapefiles with population data for a Brazilian municipality — br_prepare_tracts","title":"Prepare census tract shapefiles with population data for a Brazilian municipality — br_prepare_tracts","text":"Downloads census tract geometries via geobr, joins population data br_prepare_population(), optionally clips urban area mask, removes unpopulated tracts.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_tracts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare census tract shapefiles with population data for a Brazilian municipality — br_prepare_tracts","text":"","code":"br_prepare_tracts(   code_muni,   pop_data,   remove_unpopulated = TRUE,   clip_sf = NULL,   year = 2010,   crs = \"EPSG:5880\",   verbose = TRUE )"},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_tracts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare census tract shapefiles with population data for a Brazilian municipality — br_prepare_tracts","text":"code_muni Numeric character. IBGE municipality code. pop_data Data frame. Output br_prepare_population(). Must contain code_tract population bracket columns. remove_unpopulated Logical. Remove tracts pop_total == 0. Default: TRUE. clip_sf Optional sf polygon object. provided, census tracts clipped geometry (e.g., remove non-urban areas like parks, forests, water bodies). Population proportionally adjusted based fraction area retained. year Integer. Census tract geometry year. Default: 2010. crs Character integer. CRS output. Default: SIRGAS 2000 / Brazil Polyconic (EPSG:5880). verbose Logical. Print progress messages. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_tracts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare census tract shapefiles with population data for a Brazilian municipality — br_prepare_tracts","text":"sf object census tract polygons columns: code_tract, pop_* bracket columns pop_data, pop_total (sum brackets).","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_tracts.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prepare census tract shapefiles with population data for a Brazilian municipality — br_prepare_tracts","text":"Requires geobr, sf, dplyr packages.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_tracts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare census tract shapefiles with population data for a Brazilian municipality — br_prepare_tracts","text":"","code":"if (FALSE) { # \\dontrun{ pop <- br_prepare_population(\"3550308\", year = 2010) tracts <- br_prepare_tracts(\"3550308\", pop) } # }"},{"path":"https://antrologos.github.io/interpElections/reference/check_r5r.html","id":null,"dir":"Reference","previous_headings":"","what":"Check r5r and Java 21 setup — check_r5r","title":"Check r5r and Java 21 setup — check_r5r","text":"Runs diagnostic check r5r dependency chain: whether r5r package installed whether suitable Java/JDK (version 21+) available system.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/check_r5r.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check r5r and Java 21 setup — check_r5r","text":"","code":"check_r5r()"},{"path":"https://antrologos.github.io/interpElections/reference/check_r5r.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check r5r and Java 21 setup — check_r5r","text":"Invisibly, list components: r5r_installed Logical. java_found Logical. java_version Integer major version, NA. java_sufficient Logical. TRUE version >= 21. java_memory Character NULL. Configured JVM max heap (e.g. \"4g\"). system_ram Character NULL. Total system RAM (e.g. \"16 GB\"). ready Logical. TRUE checks pass.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/check_r5r.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check r5r and Java 21 setup — check_r5r","text":"","code":"check_r5r() #> [ok] r5r package installed (v2.3.0) #> [!!] Java 17 found, but r5r requires >= 21 #> [--] Java max heap: not configured (JVM default, typically 256m) #>      Set with: interpElections::set_java_memory(\"4g\") #>      System RAM: 15.6 GB #>  #> Some checks failed. #> Run interpElections::setup_java() to download and install Java 21."},{"path":"https://antrologos.github.io/interpElections/reference/check_torch.html","id":null,"dir":"Reference","previous_headings":"","what":"Check torch and GPU setup — check_torch","title":"Check torch and GPU setup — check_torch","text":"Runs comprehensive diagnostic torch dependency chain: whether torch R package installed, whether libtorch/lantern binaries present, GPU hardware available, whether CUDA MPS acceleration actually working.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/check_torch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check torch and GPU setup — check_torch","text":"","code":"check_torch(verbose = TRUE)"},{"path":"https://antrologos.github.io/interpElections/reference/check_torch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check torch and GPU setup — check_torch","text":"verbose Logical. Print diagnostic messages. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/check_torch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check torch and GPU setup — check_torch","text":"Invisibly, list components: torch_installed Logical. torch R package installed? torch_version Character NA. torch package version. binaries_installed Logical. libtorch/lantern binaries present? gpu_hardware Character. \"nvidia\", \"apple_silicon\", \"none\". gpu_name Character NA. GPU name hardware detection. gpu_vram Character NA. VRAM MB (NVIDIA ). cuda_available Logical. torch report CUDA available? cuda_runtime Character NA. CUDA runtime version. cuda_compute Character NA. GPU compute capability. cudnn_available Logical. mps_available Logical. MPS available (Apple Silicon)? tensor_test Logical. Can tensor created GPU? device Character. Best available device: \"cuda\", \"mps\", \"cpu\". ready Logical. TRUE GPU acceleration fully working.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/check_torch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check torch and GPU setup — check_torch","text":"","code":"if (FALSE) { # \\dontrun{ check_torch() } # }"},{"path":"https://antrologos.github.io/interpElections/reference/coef.interpElections_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract alpha coefficients — coef.interpElections_result","title":"Extract alpha coefficients — coef.interpElections_result","text":"Returns alpha decay parameter vector, plays role \"coefficients\" IDW model.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/coef.interpElections_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract alpha coefficients — coef.interpElections_result","text":"","code":"# S3 method for class 'interpElections_result' coef(object, ...)"},{"path":"https://antrologos.github.io/interpElections/reference/coef.interpElections_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract alpha coefficients — coef.interpElections_result","text":"object interpElections_result object. ... Ignored.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/coef.interpElections_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract alpha coefficients — coef.interpElections_result","text":"Numeric vector length n (one alpha per census tract).","code":""},{"path":"https://antrologos.github.io/interpElections/reference/compute_representative_points.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute representative points for census tracts — compute_representative_points","title":"Compute representative points for census tracts — compute_representative_points","text":"Computes single representative point census tract polygon. Three methods available: geometric point--surface (default), centroid, population-density-weighted using WorldPop raster data.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/compute_representative_points.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute representative points for census tracts — compute_representative_points","text":"","code":"compute_representative_points(   tracts_sf,   method = c(\"point_on_surface\", \"centroid\", \"pop_weighted\"),   pop_raster = NULL,   pop_min_area = 1,   tract_id = \"id\",   verbose = TRUE )"},{"path":"https://antrologos.github.io/interpElections/reference/compute_representative_points.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute representative points for census tracts — compute_representative_points","text":"tracts_sf sf polygon object containing census tract geometries. method Character. Method computing representative points: \"point_on_surface\" (Default) Uses sf::st_point_on_surface(). Guarantees point falls inside polygon, unlike centroids can fall outside concave shapes. \"centroid\" Uses sf::st_centroid(). Classic geometric centroid. May fall outside concave polygons. \"pop_weighted\" Uses population density raster (WorldPop Constrained 2020 default) find populated cell within tract. applied tracts area >= pop_min_area; smaller tracts use point_on_surface. Requires terra package. pop_raster terra::SpatRaster object, file path GeoTIFF, NULL. Population density raster method = \"pop_weighted\". NULL (default), WorldPop Brazil Constrained 2020 raster (~48 MB) downloaded automatically cached. Ignored methods. pop_min_area Numeric. Minimum tract area km² applying population-weighted method. Tracts smaller threshold use point_on_surface instead. Default: 1 (km²). used method = \"pop_weighted\". tract_id Character. Name ID column tracts_sf. Default: \"id\". verbose Logical. Print progress messages? Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/compute_representative_points.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute representative points for census tracts — compute_representative_points","text":"sf POINT object WGS84 (EPSG:4326) one row per tract, preserving tract_id column. Carries attribute \"point_method\" recording method used.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/compute_representative_points.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute representative points for census tracts — compute_representative_points","text":"","code":"if (FALSE) { # \\dontrun{ tracts <- br_prepare_tracts(code_muni = 3170701) tracts$id <- tracts$code_tract  # Default: point on surface pts <- compute_representative_points(tracts)  # Population-weighted for large tracts pts_pop <- compute_representative_points(tracts, method = \"pop_weighted\") } # }"},{"path":"https://antrologos.github.io/interpElections/reference/compute_travel_times.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute a travel-time matrix from census tract representative points to source points — compute_travel_times","title":"Compute a travel-time matrix from census tract representative points to source points — compute_travel_times","text":"Builds travel-time matrix using r5r routing engine. Computes travel times representative points target census tracts geolocated source points (e.g., polling locations).","code":""},{"path":"https://antrologos.github.io/interpElections/reference/compute_travel_times.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute a travel-time matrix from census tract representative points to source points — compute_travel_times","text":"","code":"compute_travel_times(   tracts_sf,   points_sf,   network_path,   tract_id = \"id\",   point_id = \"id\",   point_method = \"point_on_surface\",   pop_raster = NULL,   pop_min_area = 1,   mode = \"WALK\",   max_trip_duration = 300L,   fill_missing = max_trip_duration,   n_threads = 4L,   departure_datetime = NULL,   verbose = TRUE )"},{"path":"https://antrologos.github.io/interpElections/reference/compute_travel_times.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute a travel-time matrix from census tract representative points to source points — compute_travel_times","text":"tracts_sf sf object polygon geometries. Target census tracts. points_sf sf object point geometries. Source points. network_path Character. Path directory containing OSM .pbf file building r5r network. tract_id Character. Name ID column tracts_sf. Default: \"id\". point_id Character. Name ID column points_sf. Default: \"id\". point_method Character. Method computing representative points census tracts. One \"point_on_surface\" (default), \"centroid\", \"pop_weighted\". See compute_representative_points() details. pop_raster terra::SpatRaster object, file path GeoTIFF, NULL. Population density raster point_method = \"pop_weighted\". NULL, WorldPop data auto-downloaded. Ignored methods. pop_min_area Numeric. Minimum tract area km² applying population-weighted method. Default: 1. mode Character. Routing mode. Default: \"WALK\". max_trip_duration Integer. Maximum trip duration minutes. Default: 300. fill_missing Numeric. Value fill unreachable origin-destination pairs. Default: max_trip_duration. n_threads Integer. Number r5r routing threads. Default: 4. departure_datetime POSIXct NULL. Departure time transit-based routing. Required mode includes transit components. Default: NULL (ignored WALK/BICYCLE modes). verbose Logical. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/compute_travel_times.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute a travel-time matrix from census tract representative points to source points — compute_travel_times","text":"numeric matrix [n_tracts x n_points]. Travel times minutes. Row names = census tract IDs, column names = point IDs. Unreachable pairs filled fill_missing.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/compute_travel_times.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute a travel-time matrix from census tract representative points to source points — compute_travel_times","text":"Requires r5r sf packages. r5r requires Java/JDK 21+. Use download_r5r_data() obtain OSM data needed network_path.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/compute_travel_times.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute a travel-time matrix from census tract representative points to source points — compute_travel_times","text":"","code":"if (FALSE) { # \\dontrun{ tt <- compute_travel_times(   tracts_sf = tracts, points_sf = stations,   network_path = \"path/to/osm_data\",   tract_id = \"code_tract\", point_id = \"id\" ) } # }"},{"path":"https://antrologos.github.io/interpElections/reference/download_r5r_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Download OSM and elevation data for r5r routing — download_r5r_data","title":"Download OSM and elevation data for r5r routing — download_r5r_data","text":"Downloads OpenStreetMap road network (.pbf file) optionally satellite elevation data needed build r5r routing network. output directory can passed directly compute_travel_times() network_path.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/download_r5r_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Download OSM and elevation data for r5r routing — download_r5r_data","text":"","code":"download_r5r_data(   area_sf,   output_dir,   osm = TRUE,   elevation = FALSE,   osm_provider = \"geofabrik\",   force = FALSE,   verbose = TRUE )"},{"path":"https://antrologos.github.io/interpElections/reference/download_r5r_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Download OSM and elevation data for r5r routing — download_r5r_data","text":"area_sf sf object defining area interest. bounding box used select appropriate OSM extract clip downloaded file. output_dir Character. Directory save downloaded files. Created exist. osm Logical. Download OpenStreetMap road network. Default: TRUE. elevation Logical. Download elevation raster accurate walking/cycling routing hilly terrain. Default: FALSE. osm_provider Character. OSM extract provider osmextract. Default: \"geofabrik\". Alternatives: \"bbbike\", \"openstreetmap_fr\". force Logical. Re-download even files already exist. Default: FALSE. verbose Logical. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/download_r5r_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Download OSM and elevation data for r5r routing — download_r5r_data","text":"list paths downloaded files: osm_pbf Character. Path OSM .pbf file (NULL osm = FALSE). elevation_tif Character. Path elevation .tif file (NULL elevation = FALSE). output_dir Character. output directory path.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/download_r5r_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Download OSM and elevation data for r5r routing — download_r5r_data","text":"downloading provider extract (may cover whole state), .pbf file clipped bounding box area_sf using osmium osmconvert (available system). avoids r5r's geographic extent limit (~975,000 km2). Requires osmextract package OSM downloads optionally elevatr package elevation data. suggested dependencies package. clipping large OSM extracts, osmium-tool (recommended) osmconvert must installed. neither found, function interactively offer install one via setup_osmium() proceeding. non-interactive mode, stops actionable error message. dependency checks (R packages clipping tools) run start, downloads begin.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/get_interpElections_cache_dir.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the interpElections cache directory — get_interpElections_cache_dir","title":"Get the interpElections cache directory — get_interpElections_cache_dir","text":"Returns path directory interpElections stores cached downloaded files (TSE data, Hidalgo geocoding, travel time matrices, etc.). default location OS-appropriate (via tools::R_user_dir()). custom path can set set_interpElections_cache_dir().","code":""},{"path":"https://antrologos.github.io/interpElections/reference/get_interpElections_cache_dir.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the interpElections cache directory — get_interpElections_cache_dir","text":"","code":"get_interpElections_cache_dir()"},{"path":"https://antrologos.github.io/interpElections/reference/get_interpElections_cache_dir.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the interpElections cache directory — get_interpElections_cache_dir","text":"Character. Path cache directory.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/interpElections-package.html","id":null,"dir":"Reference","previous_headings":"","what":"interpElections: Spatial Interpolation of Electoral Data via Inverse Distance Weighting — interpElections-package","title":"interpElections: Spatial Interpolation of Electoral Data via Inverse Distance Weighting — interpElections-package","text":"Spatial interpolation electoral data via inverse distance weighting Sinkhorn-balanced weights per-census-tract optimized decay parameters. Designed disaggregating voting results polling locations census tracts using travel-time-based IDW. Optimization uses torch autograd (ADAM) CPU GPU.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/interpElections-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"interpElections: Spatial Interpolation of Electoral Data via Inverse Distance Weighting — interpElections-package","text":"Maintainer: Rogerio Barbosa rogerio.barbosa@iesp.uerj.br Authors: Lucas Gelape","code":""},{"path":"https://antrologos.github.io/interpElections/reference/interpElections_cache.html","id":null,"dir":"Reference","previous_headings":"","what":"Manage the interpElections download cache — interpElections_cache","title":"Manage the interpElections download cache — interpElections_cache","text":"Lists deletes cached files. default shows per-category size breakdown. Use details = TRUE see individual files. Use delete_file = \"\" clear entire cache.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/interpElections_cache.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Manage the interpElections download cache — interpElections_cache","text":"","code":"interpElections_cache(   list_files = TRUE,   delete_file = NULL,   details = FALSE,   verbose = TRUE )"},{"path":"https://antrologos.github.io/interpElections/reference/interpElections_cache.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Manage the interpElections download cache — interpElections_cache","text":"list_files Logical. TRUE (default), prints per-category summary returns cached file paths. delete_file Character NULL. pattern match files deletion (matched relative paths via grepl()), \"\" delete entire cache. targeted deletion category, see interpElections_cache_clean(). details Logical. TRUE, also prints individual filenames within category. Default: FALSE. verbose Logical. Print messages. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/interpElections_cache.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Manage the interpElections download cache — interpElections_cache","text":"Invisibly returns character vector cached file paths (deletion).","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/interpElections_cache.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Manage the interpElections download cache — interpElections_cache","text":"","code":"if (FALSE) { # \\dontrun{ # Per-category summary interpElections_cache()  # Detailed listing (every file) interpElections_cache(details = TRUE)  # Delete files matching a pattern interpElections_cache(delete_file = \"2020\")  # Delete everything interpElections_cache(delete_file = \"all\") } # }"},{"path":"https://antrologos.github.io/interpElections/reference/interpElections_cache_clean.html","id":null,"dir":"Reference","previous_headings":"","what":"Delete cached files by category — interpElections_cache_clean","title":"Delete cached files by category — interpElections_cache_clean","text":"Convenience function clearing specific categories cached data. discoverable interpElections_cache() delete_file.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/interpElections_cache_clean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Delete cached files by category — interpElections_cache_clean","text":"","code":"interpElections_cache_clean(   category = c(\"all\", \"downloads\", \"processed\", \"networks\", \"travel_times\", \"pop_raster\",     \"votes\", \"turnout\", \"geocode\", \"profile\", \"hidalgo\", \"osm\", \"electoral\", \"tracts\",     \"r5r\"),   verbose = TRUE )"},{"path":"https://antrologos.github.io/interpElections/reference/interpElections_cache_clean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Delete cached files by category — interpElections_cache_clean","text":"category Character. category clear. One : \"\" Delete entire cache \"downloads\" raw downloads (votes, turnout, geocode, profile, hidalgo, osm) \"processed\" processed/cached results (electoral, tracts) \"networks\" r5r network indices \"travel_times\" Cached travel time matrices \"votes\" TSE vote data ZIPs \"turnout\" TSE turnout data ZIPs \"geocode\" TSE polling station location ZIPs \"profile\" TSE voter profile ZIPs \"hidalgo\" Hidalgo geocoding fallback data \"osm\" OpenStreetMap road network extracts \"electoral\" Processed electoral data (br_prepare_electoral output) \"tracts\" Cached census tract geometries \"r5r\" r5r routing network indices verbose Logical. Print messages. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/interpElections_cache_clean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Delete cached files by category — interpElections_cache_clean","text":"Invisibly returns path(s) deleted.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/interpElections_cache_clean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Delete cached files by category — interpElections_cache_clean","text":"","code":"if (FALSE) { # \\dontrun{ # Clear only processed electoral data (forces re-computation next run) interpElections_cache_clean(\"electoral\")  # Clear all raw downloads interpElections_cache_clean(\"downloads\")  # Clear everything interpElections_cache_clean(\"all\") } # }"},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election.html","id":null,"dir":"Reference","previous_headings":"","what":"One-step IDW interpolation from source points to census tracts — interpolate_election","title":"One-step IDW interpolation from source points to census tracts — interpolate_election","text":"High-level wrapper combines travel-time computation (optional), alpha optimization, interpolation single call. travel time matrix provided, OSM road network data automatically downloaded travel times computed via r5r.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"One-step IDW interpolation from source points to census tracts — interpolate_election","text":"","code":"interpolate_election(   tracts_sf,   electoral_sf,   tract_id,   point_id,   calib_tracts,   calib_sources,   interp_sources = NULL,   time_matrix = NULL,   network_path = NULL,   elevation_path = NULL,   osm_buffer_km = 10,   min_pop = 1,   alpha = NULL,   offset = 1,   keep = NULL,   use_gpu = NULL,   verbose = TRUE,   ...,   .step_offset = 0L,   .step_total = NULL )"},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"One-step IDW interpolation from source points to census tracts — interpolate_election","text":"tracts_sf sf polygon object. Target census tracts. electoral_sf sf point object. Source points (e.g., voting locations). tract_id Character. Name ID column tracts_sf. point_id Character. Name ID column electoral_sf. calib_tracts Character vector. Column names tracts_sf use calibration population matrix. Must match calib_sources length. calib_sources Character vector. Column names electoral_sf use source calibration matrix. Must match calib_tracts length. interp_sources Character vector NULL. Column names electoral_sf interpolate. Default NULL means numeric columns calib_sources. time_matrix Numeric matrix [n x m] NULL. Pre-computed travel times. provided, skips travel time computation. network_path Character NULL. Path directory OSM .pbf file. provided (time_matrix NULL), travel times computed directly without downloading OSM data. elevation_path Character NULL. Path elevation .tif file r5r routing. osm_buffer_km Numeric. Buffer kilometers expand bounding box auto-downloading OSM data. Default: 10. min_pop Numeric. Minimum total population calib_tracts census tract included. Default: 1. alpha Numeric vector length n, NULL. Pre-computed decay parameters. provided, optimization skipped. offset Numeric. Travel time offset. Default: 1. keep Character vector NULL. Names heavy intermediate objects include result. Default NULL (lightweight). Options: \"weights\" (column-standardized weight matrix [n x m]), \"time_matrix\" (travel time matrix [n x m]), \"sources_sf\" (source points sf object geometry), \"pop_raster\" (population density raster, point_method = \"pop_weighted\"), \"rep_points\" (representative points sf object used routing). can large big municipalities. Travel times cached disk can reloaded without keeping memory. use_gpu Logical NULL. Passed optimize_alpha(). verbose Logical. Print progress. Default: TRUE. ... Additional arguments forwarded optimize_alpha(), compute_travel_times(), /download_r5r_data(). Notable forwarded arguments: point_method (representative point method), pop_raster (population density raster), pop_min_area (area threshold pop-weighted points). See compute_travel_times() details. .step_offset Integer. Internal: offset added step numbers called interpolate_election_br(). set manually. .step_total Integer NULL. Internal: total step count unified progress display. set manually.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"One-step IDW interpolation from source points to census tracts — interpolate_election","text":"list class \"interpElections_result\" components: interpolated Numeric matrix [n x p]. Interpolated values. alpha Numeric vector length n. Decay parameters used. tracts_sf sf object interpolated columns joined census tracts. sources Data frame (geometry) source point data. optimization interpElections_optim object, NULL alpha pre-supplied. offset Numeric. Offset value used. call matched call. tract_id Character. Name census tract ID column. point_id Character. Name ID column sources. interp_cols Character vector. Names interpolated columns. calib_cols List $tracts $sources calibration columns. weights Numeric matrix [n x m] NULL. Present keep includes \"weights\". time_matrix Numeric matrix [n x m] NULL. Present keep includes \"time_matrix\". sources_sf sf point object NULL. Source points geometry. Present keep includes \"sources_sf\". pop_raster terra::SpatRaster NULL. Population density raster (cropped municipality). Present keep includes \"pop_raster\" point_method = \"pop_weighted\" used. rep_points sf POINT object NULL. Representative points used travel time routing. Present keep includes \"rep_points\".","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"One-step IDW interpolation from source points to census tracts — interpolate_election","text":"","code":"if (FALSE) { # \\dontrun{ # Minimal: sf objects + column names (auto-downloads OSM) result <- interpolate_election(   tracts_sf    = census_tracts,   electoral_sf = voting_stations,   tract_id     = \"code_tract\",   point_id     = \"id\",   calib_tracts  = c(\"pop_18_24\", \"pop_25_34\"),   calib_sources = c(\"voters_18_24\", \"voters_25_34\") )  # With pre-computed travel times (skip r5r) result <- interpolate_election(   tracts_sf    = census_tracts,   electoral_sf = voting_stations,   tract_id     = \"code_tract\",   point_id     = \"id\",   calib_tracts  = c(\"pop_young\", \"pop_old\"),   calib_sources = c(\"voters_young\", \"voters_old\"),   time_matrix  = my_tt_matrix ) } # }"},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election_br.html","id":null,"dir":"Reference","previous_headings":"","what":"One-step interpolation for Brazilian elections — interpolate_election_br","title":"One-step interpolation for Brazilian elections — interpolate_election_br","text":"High-level wrapper auto-downloads census data, electoral data, tract geometries, OSM road networks, runs full optimization interpolation pipeline. user needs provide IBGE municipality code (name) election year.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election_br.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"One-step interpolation for Brazilian elections — interpolate_election_br","text":"","code":"interpolate_election_br(   code_muni,   uf = NULL,   year,   comparecimento_path = NULL,   votacao_path = NULL,   network_path = NULL,   time_matrix = NULL,   cargo = NULL,   turno = 1L,   what = \"candidates\",   candidates = NULL,   parties = NULL,   interp_sources = NULL,   census_year = NULL,   clip_sf = NULL,   remove_unpopulated = TRUE,   osm_buffer_km = 10,   osm_provider = \"openstreetmap_fr\",   point_method = \"point_on_surface\",   pop_raster = NULL,   pop_min_area = 1,   keep = NULL,   alpha = NULL,   offset = 1,   calib_type = \"full\",   use_gpu = NULL,   cache = TRUE,   force = FALSE,   verbose = TRUE,   ... )"},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election_br.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"One-step interpolation for Brazilian elections — interpolate_election_br","text":"code_muni Numeric character. Either 7-digit IBGE municipality code (e.g., 3550308 Sao Paulo) municipality name (e.g., \"Sao Paulo\", \"SAO PAULO\", \"São Paulo\"). Name matching case-insensitive, accent-insensitive, whitespace-trimmed. name exists multiple states, use uf parameter disambiguate. TSE code state abbreviation resolved automatically bundled muni_crosswalk table. uf Character NULL. Two-letter state abbreviation (e.g., \"SP\", \"RJ\") disambiguation code_muni municipality name exists multiple states. Case-insensitive. Ignored (message) code_muni numeric IBGE code. Default: NULL. year Integer. Election year. Brazil holds two types elections: Municipal (even years divisible 4): 2000, 2004, 2008, 2012, 2016, 2020, 2024. Offices: prefeito, vereador. General/federal (even years divisible 4): 2002, 2006, 2010, 2014, 2018, 2022. Offices: presidente, governador, senador, deputado federal, deputado estadual. comparecimento_path Character NULL. Path attendance/turnout parquet file. NULL (default), turnout computed vote data . votacao_path Character NULL. Path candidate votes parquet file. NULL (default), vote data auto-downloaded TSE open data portal. network_path Character NULL. Path directory containing OSM .pbf file r5r routing. NULL time_matrix also NULL, OSM data auto-downloaded via download_r5r_data(). time_matrix Numeric matrix NULL. Pre-computed travel time matrix [n x m]. provided, skips travel time computation (r5r, OSM download). Useful re-running different parameters municipality. cargo Integer, character, NULL. electoral office(s) include. Accepts one human-readable aliases (case-insensitive) TSE numeric codes: NULL (default), offices available election year included. multiple cargos selected, output columns prefixed office name (e.g., PRESIDENTE_CAND_13, GOVERNADOR_CAND_22). turno Integer. Election round: 1 (first round, default) 2 (runoff). first round always exists. second round (turno 2) held presidente, governador, prefeito (cities >200k voters), candidate wins outright majority. turno 2 occur, result contain zero vote rows offices. Character vector. Controls information interpolated census tracts. One : \"candidates\" (default): Vote counts per candidate. Creates one column per candidate, named CAND_<number> (e.g., CAND_13, CAND_22). Also includes QT_COMPARECIMENTO (total turnout). \"parties\": Vote counts aggregated party. Creates one column per party, named PARTY_<abbreviation> (e.g., PARTY_PT, PARTY_PL). Also includes QT_COMPARECIMENTO. \"turnout\": Turnout abstention. Creates QT_COMPARECIMENTO (voters showed ), QT_APTOS (eligible voters), QT_ABSTENCOES (abstentions), available. \"demographics\": Voter profile demographics. Creates GENERO_* columns (e.g., GENERO_FEMININO, GENERO_MASCULINO) EDUC_* columns (e.g., EDUC_SUP_COMP, EDUC_FUND_INCOMP). Multiple values can combined: = c(\"candidates\", \"parties\", \"turnout\", \"demographics\"). candidates Character numeric vector, NULL. Filter specific candidates (used \"candidates\" %% ): number (numeric): Matches candidate's ballot number exactly. Example: candidates = c(13, 22) keeps candidates 13 (Lula) 22 (Bolsonaro) 2022. name (character): Performs accent-normalized, case-insensitive substring matching candidate's registered name. Example: candidates = \"LULA\" matches \"LUIZ INACIO LULA DA SILVA\". NULL (default): candidates included (including special codes 95 = votos em branco, 96 = votos nulos). parties Character vector NULL. Filter specific parties (used \"parties\" %% ). Uses official TSE party abbreviations, matched case-insensitively: Example: parties = c(\"PT\", \"PL\") keeps PT PL. NULL (default): parties included. interp_sources Character vector NULL. Column names electoral data interpolate. Default NULL auto-selects based . Override need fine-grained control columns interpolated. census_year Integer NULL. Census year population data (2000, 2010, 2022). NULL (default), auto-selected based election year: Elections 2000-2004 use Census 2000 Elections 2008-2016 use Census 2010 Elections 2020+ use Census 2022 clip_sf sf polygon NULL. Optional geometry clip tracts (e.g., urban area boundary). Tracts outside polygon removed interpolation. remove_unpopulated Logical. Remove zero-population tracts. Default: TRUE. osm_buffer_km Numeric. Buffer km OSM bounding box expansion. Default: 10. osm_provider Character. OSM extract provider osmextract. Default: \"openstreetmap_fr\" (state-level extracts Brazil). Alternatives: \"geofabrik\", \"bbbike\". used OSM data auto-downloaded (network_path time_matrix provided). point_method Character. Method computing representative points census tracts. One \"point_on_surface\" (default, guaranteed inside polygon), \"centroid\", \"pop_weighted\" (uses WorldPop raster large tracts). See compute_representative_points(). pop_raster terra::SpatRaster, file path, NULL. Population density raster point_method = \"pop_weighted\". NULL, WorldPop Brazil Constrained 2020 (~48 MB) auto-downloaded. pop_min_area Numeric. Minimum tract area (km²) applying population-weighted method. Smaller tracts use point_on_surface. Default: 1. keep Character vector NULL. Names heavy intermediate objects include result. Default NULL (lightweight). Options: \"weights\", \"time_matrix\", \"sources_sf\", \"pop_raster\", \"rep_points\". See interpolate_election() details. alpha Numeric vector NULL. Pre-computed decay parameters (one per tract). provided, optimization step skipped entirely. Useful re-interpolating previously optimized alpha. offset Numeric. Travel time offset. Default: 1. calib_type Character. Calibration column type: \"full\" (default): 28 columns crossing gender (male/female) × literacy (literate/illiterate) × 7 age brackets. Provides stronger spatial signal optimizer. \"age_only\": 7 age-bracket-columns (original behavior). use_gpu Logical NULL. Passed optimize_alpha(). cache Logical. TRUE (default), downloaded files (TSE data, OSM networks, census tracts) stored persistently across R sessions. See get_interpElections_cache_dir(). Subsequent calls reuse cached files, making re-runs much faster. force Logical. Re-download even cached file exists. Default: FALSE. verbose Logical. Default: TRUE. ... Additional arguments forwarded interpolate_election(), optimize_alpha(), compute_travel_times(), /download_r5r_data().","code":""},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election_br.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"One-step interpolation for Brazilian elections — interpolate_election_br","text":"list class \"interpElections_result\" components: interpolated Numeric matrix [n x p]. Rows = census tracts, columns = interpolated variables. alpha Numeric vector length n. Optimized decay parameters. tracts_sf sf object interpolated columns joined , ready mapping plot() ggplot2. sources Data frame prepared electoral data (one row per voting location), without geometry. optimization interpElections_optim NULL (alpha pre-supplied). offset Numeric. Offset value used. call matched call. tract_id Character. Name census tract ID column. point_id Character. Name source point ID column. interp_cols Character vector. Names interpolated columns. calib_cols List $tracts $sources calibration columns. weights Numeric matrix NULL. Present keep includes \"weights\". time_matrix Numeric matrix NULL. Present keep includes \"time_matrix\". sources_sf sf point object NULL. Present keep includes \"sources_sf\". code_muni IBGE municipality code. year Election year. census_year Census year. Character vector data types interpolated. pop_data Data frame census population tract.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election_br.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"One-step interpolation for Brazilian elections — interpolate_election_br","text":"Internally calls interpolate_election() preparing inputs.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election_br.html","id":"election-types","dir":"Reference","previous_headings":"","what":"Election types","title":"One-step interpolation for Brazilian elections — interpolate_election_br","text":"Brazil holds elections every two years, alternating municipal general (federal/state) elections: Municipal elections (2000, 2004, 2008, 2012, 2016, 2020, 2024): elect prefeito (mayor) vereador (city councilor). General elections (2002, 2006, 2010, 2014, 2018, 2022): elect presidente, governador, senador, deputado federal, deputado estadual. Presidential vote data published TSE separate national file (~250 MB). function handles download automatically cargo includes \"presidente\" cargo = NULL general election year.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election_br.html","id":"output-columns","dir":"Reference","previous_headings":"","what":"Output columns","title":"One-step interpolation for Brazilian elections — interpolate_election_br","text":"tracts_sf output contains original census tract geometry plus interpolated columns. Column names follow patterns: CAND_<number> Interpolated vote count candidate ballot number <number>. Special numbers: 95 = blank votes (em branco), 96 = null votes (nulo). PARTY_<abbrev> Interpolated total votes party <abbrev> (e.g., PARTY_PT, PARTY_PL). GENERO_<category> Interpolated voter count gender (e.g., GENERO_FEMININO, GENERO_MASCULINO). EDUC_<level> Interpolated voter count education level (e.g., EDUC_SUP_COMP, EDUC_FUND_INCOMP). QT_COMPARECIMENTO Total voters showed . QT_APTOS Total eligible voters (available). QT_ABSTENCOES Total abstentions (available). multiple cargo values selected, candidate party columns prefixed: PRESIDENTE_CAND_13, GOVERNADOR_PARTY_PT, etc.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election_br.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"One-step interpolation for Brazilian elections — interpolate_election_br","text":"","code":"if (FALSE) { # \\dontrun{ # ── Minimal usage ─────────────────────────────────────────────── # Just an IBGE code + year. Everything else is auto-downloaded. result <- interpolate_election_br(   code_muni = 3550308,   # Sao Paulo   year = 2020 )  # The result includes an sf object ready for mapping plot(result$tracts_sf[\"CAND_13\"])   # ── Choosing a specific cargo ─────────────────────────────────── # Municipal election: only city councilors (vereador) result <- interpolate_election_br(   code_muni = 3170701, year = 2020,   cargo = \"vereador\" )  # General election: only the presidential race result <- interpolate_election_br(   code_muni = 3170701, year = 2022,   cargo = \"presidente\" )  # Multiple offices at once (columns are prefixed) result <- interpolate_election_br(   code_muni = 3170701, year = 2022,   cargo = c(\"presidente\", \"governador\") ) # -> columns: PRESIDENTE_CAND_13, GOVERNADOR_CAND_30, ...   # ── Turno (election round) ───────────────────────────────────── # First round (default) r1 <- interpolate_election_br(   code_muni = 3170701, year = 2022,   cargo = \"presidente\", turno = 1 )  # Runoff (second round) -- only 2 candidates r2 <- interpolate_election_br(   code_muni = 3170701, year = 2022,   cargo = \"presidente\", turno = 2 )   # ── Choosing what to interpolate ─────────────────────────────── # Party vote totals instead of individual candidates result <- interpolate_election_br(   code_muni = 3170701, year = 2022,   cargo = \"governador\",   what = \"parties\" ) # -> columns: PARTY_PT, PARTY_PL, PARTY_MDB, ...  # Voter demographics (gender + education) result <- interpolate_election_br(   code_muni = 3170701, year = 2022,   what = \"demographics\" ) # -> columns: GENERO_FEMININO, EDUC_SUP_COMP, ...  # Turnout and abstention result <- interpolate_election_br(   code_muni = 3170701, year = 2020,   cargo = \"prefeito\",   what = \"turnout\" ) # -> columns: QT_COMPARECIMENTO, QT_APTOS, QT_ABSTENCOES  # Everything at once result <- interpolate_election_br(   code_muni = 3170701, year = 2022,   cargo = \"governador\",   what = c(\"candidates\", \"parties\", \"turnout\", \"demographics\") )   # ── Filtering candidates ─────────────────────────────────────── # By ballot number result <- interpolate_election_br(   code_muni = 3170701, year = 2022,   cargo = \"presidente\",   candidates = c(13, 22) ) # -> only CAND_13 (Lula) and CAND_22 (Bolsonaro)  # By name (accent-insensitive substring search) result <- interpolate_election_br(   code_muni = 3170701, year = 2022,   cargo = \"presidente\",   candidates = \"LULA\" ) # -> matches \"LUIZ INACIO LULA DA SILVA\"   # ── Filtering parties ────────────────────────────────────────── result <- interpolate_election_br(   code_muni = 3170701, year = 2022,   cargo = \"presidente\",   what = \"parties\",   parties = c(\"PT\", \"PL\") ) # -> only PARTY_PT and PARTY_PL   # ── Re-using a previous result ───────────────────────────────── # Keep the time_matrix for reuse (opt-in via keep) result <- interpolate_election_br(   code_muni = 3170701, year = 2022,   cargo = \"governador\",   keep = \"time_matrix\" )  # Then reuse the alpha and travel time matrix result2 <- interpolate_election_br(   code_muni = 3170701, year = 2022,   cargo = \"governador\",   what = \"parties\",   time_matrix = result$time_matrix,   alpha = result$alpha )   # ── Pre-computed travel times (skip r5r) ─────────────────────── result <- interpolate_election_br(   code_muni = 3550308, year = 2020,   time_matrix = my_tt_matrix ) } # }"},{"path":"https://antrologos.github.io/interpElections/reference/muni_crosswalk.html","id":null,"dir":"Reference","previous_headings":"","what":"IBGE-TSE Municipality Code Crosswalk — muni_crosswalk","title":"IBGE-TSE Municipality Code Crosswalk — muni_crosswalk","text":"Official crosswalk table mapping IBGE 7-digit municipality codes TSE 5-digit electoral codes 5,710 Brazilian municipalities. Sourced GV-CEPESP.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/muni_crosswalk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IBGE-TSE Municipality Code Crosswalk — muni_crosswalk","text":"","code":"muni_crosswalk"},{"path":"https://antrologos.github.io/interpElections/reference/muni_crosswalk.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"IBGE-TSE Municipality Code Crosswalk — muni_crosswalk","text":"data frame 5,710 rows 4 columns: code_ibge Character. IBGE 7-digit municipality code. code_tse Character. TSE 5-digit municipality code. uf Character. Two-letter state abbreviation (e.g., \"SP\", \"RJ\"). nome Character. Municipality name uppercase.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/muni_crosswalk.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"IBGE-TSE Municipality Code Crosswalk — muni_crosswalk","text":"GV-CEPESP, FGV: https://github.com/GV-CEPESP/cepespdata/blob/main/tabelas_auxiliares/dados/codigo_municipio_ibge_tse.csv","code":""},{"path":"https://antrologos.github.io/interpElections/reference/muni_crosswalk.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IBGE-TSE Municipality Code Crosswalk — muni_crosswalk","text":"","code":"data(muni_crosswalk) # Look up TSE code for Sao Paulo (IBGE 3550308) muni_crosswalk[muni_crosswalk$code_ibge == \"3550308\", ] #>      code_ibge code_tse uf      nome #> 5360   3550308    71072 SP SÃO PAULO"},{"path":"https://antrologos.github.io/interpElections/reference/optimize_alpha.html","id":null,"dir":"Reference","previous_headings":"","what":"Find optimal decay parameters (alpha) for spatial interpolation — optimize_alpha","title":"Find optimal decay parameters (alpha) for spatial interpolation — optimize_alpha","text":"Optimizes per-zone decay parameters minimize squared error per-bracket Sinkhorn-balanced interpolated values known population counts. Uses Per-Bracket SGD (PB-SGD) mini-batch sampling log-domain Sinkhorn inside torch autograd. demographic bracket gets Sinkhorn transport; gradients flow unrolled iterations. Works CPU GPU (CUDA/MPS).","code":""},{"path":"https://antrologos.github.io/interpElections/reference/optimize_alpha.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find optimal decay parameters (alpha) for spatial interpolation — optimize_alpha","text":"","code":"optimize_alpha(   time_matrix,   pop_matrix,   source_matrix,   row_targets = NULL,   alpha_init = NULL,   batch_size = 500L,   sk_iter = 15L,   max_steps = 800L,   lr_init = 0.05,   use_gpu = NULL,   device = NULL,   dtype = \"float32\",   lower_bound = 0.01,   upper_bound = 20,   offset = 1,   verbose = TRUE )"},{"path":"https://antrologos.github.io/interpElections/reference/optimize_alpha.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find optimal decay parameters (alpha) for spatial interpolation — optimize_alpha","text":"time_matrix Numeric matrix [n x m]. Raw travel times. Rows = target zones, columns = source points. pop_matrix Numeric matrix [n x k]. Known population per zone, k demographic groups columns. source_matrix Numeric matrix [m x k]. Known counts source points (e.g., registered voters age group). row_targets Numeric vector length n, NULL. Target row sums Sinkhorn balancing. element specifies much weight zone attract, proportional share total population. NULL (default), auto-computed rowSums(pop_matrix) / sum(pop_matrix) * m. alpha_init Numeric vector length n, single value recycled. Initial guess alpha. Default: rep(1, n). batch_size Integer. Number zones (rows) sampled per SGD step. cities n <= batch_size, full batch used. Default: 500. sk_iter Integer. Number log-domain Sinkhorn iterations per SGD step. Higher values give accurate per-bracket transport increase memory usage. Default: 15. max_steps Integer. Total number SGD steps. Default: 800. lr_init Numeric. Initial ADAM learning rate. Halved steps 200, 400, 600. Default: 0.05. use_gpu Logical NULL. TRUE, use GPU (CUDA MPS). FALSE, use CPU. NULL (default), reads package option interpElections.use_gpu (set via use_gpu()). device Character NULL. Torch device: \"cuda\", \"mps\", \"cpu\". used GPU enabled. Default: NULL (auto-detect). dtype Character. Torch dtype: \"float32\" \"float64\". Default: \"float32\". Float32 halves memory usage negligible precision loss. lower_bound Numeric. Lower bound alpha values. Default: 0.01. upper_bound Numeric. Upper bound alpha values. Default: 20. offset Numeric. Value added travel times exponentiation. Default: 1. verbose Logical. Print progress messages? Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/optimize_alpha.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find optimal decay parameters (alpha) for spatial interpolation — optimize_alpha","text":"list class \"interpElections_optim\" components: alpha Numeric vector. Optimal alpha values. value Numeric. Objective function value optimum. method Character. Method used (e.g., \"pb_sgd_sinkhorn_cpu\", \"pb_sgd_sinkhorn_cuda\"). convergence Integer. 0 = success. iterations Number SGD steps taken. elapsed difftime object. Wall-clock time. message Character. Additional information. history Numeric vector. Loss values step. grad_norm_final Numeric. Final gradient norm. row_targets Numeric vector. Row targets used Sinkhorn. sk_iter Integer. Sinkhorn iterations per step. batch_size Integer. Mini-batch size used.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/optimize_alpha.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find optimal decay parameters (alpha) for spatial interpolation — optimize_alpha","text":"optimization requires torch R package. Install setup_torch() already available. Two execution paths: CPU (default): use_gpu = FALSE NULL. Uses torch CPU device. Fast small/medium problems (< 2000 tracts). GPU: use_gpu = TRUE. Uses CUDA MPS. Faster large problems (> 2000 tracts). paths use PB-SGD: mini-batch ADAM per-bracket log-domain Sinkhorn. Gradients computed via torch autograd unrolled Sinkhorn iterations. GPU memory usage bounded ka * min(batch_size, n) * m * bytes_per_elem * (2 + 2 * sk_iter).","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/optimize_alpha.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find optimal decay parameters (alpha) for spatial interpolation — optimize_alpha","text":"","code":"if (FALSE) { # \\dontrun{ tt <- matrix(c(2, 5, 3, 4, 6, 2), nrow = 2) pop <- matrix(c(100, 200), nrow = 2) src <- matrix(c(80, 120, 100), nrow = 3) result <- optimize_alpha(tt, pop, src, verbose = FALSE) result$alpha } # }"},{"path":"https://antrologos.github.io/interpElections/reference/plot.interpElections_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot an interpolated variable as a choropleth map — plot.interpElections_result","title":"Plot an interpolated variable as a choropleth map — plot.interpElections_result","text":"Produces ggplot2 choropleth map interpolated variable. Variables can referenced column name, ballot number, candidate name, party abbreviation.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/plot.interpElections_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot an interpolated variable as a choropleth map — plot.interpElections_result","text":"","code":"# S3 method for class 'interpElections_result' plot(   x,   variable = NULL,   type = \"pct_tract\",   palette = \"RdYlBu\",   breaks = \"quantile\",   n_breaks = 5L,   title = NULL,   subtitle = NULL,   legend_title = NULL,   caption = NULL,   show_sources = FALSE,   border_color = \"white\",   border_width = 0.05,   limits = NULL,   scale_bar = TRUE,   ... )  # S3 method for class 'interpElections_result' autoplot(object, ...)"},{"path":"https://antrologos.github.io/interpElections/reference/plot.interpElections_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot an interpolated variable as a choropleth map — plot.interpElections_result","text":"x interpElections_result object. variable Variable plot. Accepts column name (e.g., \"CAND_13\"), ballot number (numeric, e.g. 13), candidate name substring (e.g., \"Lula\"), party abbreviation (e.g., \"PT\"). Multiple values produce faceted comparison. NULL, auto-selects first candidate variable. type Quantity map: \"pct_tract\" (default), \"absolute\", \"pct_muni\", \"pct_valid\", \"pct_eligible\", \"density\". palette Color palette name. RColorBrewer palettes (e.g., \"RdYlBu\", \"YlGnBu\", \"Spectral\") viridis palettes (e.g., \"viridis\", \"magma\", \"plasma\"). Default: \"RdYlBu\" (diverging, colorblind-friendly). breaks Scale breaks: \"quantile\" (default), \"continuous\", \"jenks\" (requires classInt), numeric vector custom break points. n_breaks Number breaks \"quantile\" \"jenks\". Default: 5. title Plot title. NULL = auto-generated dictionary (title-cased candidate name party). subtitle Plot subtitle. NULL = auto-generated municipality/year/quantity metadata. legend_title Legend title. NULL = auto-generated quantity type. caption Plot caption. NULL = auto-generated source note. Use \"\" suppress. show_sources Overlay source points (polling stations) map. Requires sources_sf result (use keep = \"sources_sf\" interpolating). Default: FALSE. border_color Tract border color. Default: \"white\". border_width Tract border width. Default: 0.05. limits Bounding box map extent c(xmin, xmax, ymin, ymax) CRS data (typically longitude/latitude). NULL (default) shows full extent. Use zoom region interest. scale_bar Add scale bar (requires ggspatial). Default: TRUE. ... Ignored. object interpElections_result object.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/plot.interpElections_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot an interpolated variable as a choropleth map — plot.interpElections_result","text":"ggplot object (invisibly). Can customized ggplot2 + syntax.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/plot.interpElections_result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot an interpolated variable as a choropleth map — plot.interpElections_result","text":"","code":"if (FALSE) { # \\dontrun{ result <- interpolate_election_br(3304557, 2020, 2022)  # By candidate name (default: % of tract votes, quantile breaks) plot(result, variable = \"Lula\")  # By ballot number plot(result, variable = 13)  # Absolute counts with continuous scale plot(result, variable = \"PT\", type = \"absolute\",      breaks = \"continuous\")  # Faceted comparison plot(result, variable = c(\"Lula\", \"Bolsonaro\"))  # Zoom into a region plot(result, variable = \"Lula\",      limits = c(-43.2, -43.1, -22.95, -22.85))  # Composable with ggplot2 library(ggplot2) plot(result, variable = \"PT\") + theme_dark() } # }"},{"path":"https://antrologos.github.io/interpElections/reference/plot_interactive.html","id":null,"dir":"Reference","previous_headings":"","what":"Interactive map of interpolated results — plot_interactive","title":"Interactive map of interpolated results — plot_interactive","text":"Creates interactive leaflet/mapview map interpolated variable. Variables can referenced column name, ballot number, candidate name, party abbreviation. multiple variables provided, creates synchronized side--side panels via leafsync::sync().","code":""},{"path":"https://antrologos.github.io/interpElections/reference/plot_interactive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interactive map of interpolated results — plot_interactive","text":"","code":"plot_interactive(   result,   variable = NULL,   type = \"pct_tract\",   palette = \"RdYlBu\",   breaks = \"quantile\",   n_breaks = 5L,   popup_vars = NULL,   alpha = 0.7,   legend = TRUE,   layer_name = NULL,   basemap = \"OpenStreetMap\",   ... )"},{"path":"https://antrologos.github.io/interpElections/reference/plot_interactive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interactive map of interpolated results — plot_interactive","text":"result interpElections_result object. variable Variable map. Accepts column name, ballot number (numeric), candidate name substring, party abbreviation. Multiple values create synchronized comparison panels. NULL, auto-selects first candidate variable. type Quantity map: \"pct_tract\" (default), \"absolute\", \"pct_muni\", \"pct_valid\", \"pct_eligible\", \"density\". palette Color palette name. Default: \"RdYlBu\" (diverging, colorblind-friendly). breaks Scale breaks: \"quantile\" (default), \"continuous\", \"jenks\" (requires classInt), numeric vector custom break points. n_breaks Number breaks \"quantile\" \"jenks\". Default: 5. popup_vars Character vector column names show click popups. NULL, auto-selects census tract ID, plotted variable, turnout, calibration columns (capped 8). alpha Fill opacity (0 1). Default: 0.7. legend Show legend. Default: TRUE. layer_name Layer name map. NULL = auto-generated dictionary metadata. basemap Base map tile provider. Default: \"OpenStreetMap\". ... Additional arguments passed mapview::mapview().","code":""},{"path":"https://antrologos.github.io/interpElections/reference/plot_interactive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interactive map of interpolated results — plot_interactive","text":"mapview object (single variable) leafsync object (multiple variables synchronized panels).","code":""},{"path":"https://antrologos.github.io/interpElections/reference/plot_interactive.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interactive map of interpolated results — plot_interactive","text":"","code":"if (FALSE) { # \\dontrun{ result <- interpolate_election_br(3304557, 2020, 2022,                                    keep = \"sources_sf\")  # Interactive map by candidate name plot_interactive(result, variable = \"Lula\", type = \"pct_tract\")  # Side-by-side comparison (synced panels) plot_interactive(result, variable = c(\"Lula\", \"Bolsonaro\"),                  type = \"pct_tract\")  # Custom popup plot_interactive(result, variable = \"PT\",                  popup_vars = c(\"code_tract\", \"PARTY_PT\",                                 \"QT_COMPARECIMENTO\")) } # }"},{"path":"https://antrologos.github.io/interpElections/reference/residuals.interpElections_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute calibration residuals — residuals.interpElections_result","title":"Compute calibration residuals — residuals.interpElections_result","text":"Returns matrix calibration residuals (fitted minus observed) census tract calibration bracket. Requires weight matrix travel time matrix present result (use keep = \"weights\" keep = \"time_matrix\" running interpolation).","code":""},{"path":"https://antrologos.github.io/interpElections/reference/residuals.interpElections_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute calibration residuals — residuals.interpElections_result","text":"","code":"# S3 method for class 'interpElections_result' residuals(object, ...)"},{"path":"https://antrologos.github.io/interpElections/reference/residuals.interpElections_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute calibration residuals — residuals.interpElections_result","text":"object interpElections_result object. ... Ignored.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/residuals.interpElections_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute calibration residuals — residuals.interpElections_result","text":"Numeric matrix [n x k] residuals (fitted - observed), k number calibration brackets. Returns NULL (message) required data available.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/set_interpElections_cache_dir.html","id":null,"dir":"Reference","previous_headings":"","what":"Set a custom interpElections cache directory — set_interpElections_cache_dir","title":"Set a custom interpElections cache directory — set_interpElections_cache_dir","text":"Persists custom cache directory path across R sessions. path NULL, resets default OS-appropriate location.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/set_interpElections_cache_dir.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set a custom interpElections cache directory — set_interpElections_cache_dir","text":"","code":"set_interpElections_cache_dir(path = NULL, verbose = TRUE)"},{"path":"https://antrologos.github.io/interpElections/reference/set_interpElections_cache_dir.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set a custom interpElections cache directory — set_interpElections_cache_dir","text":"path Character NULL. Directory path cached files. Created exist. NULL resets default. verbose Logical. Print confirmation. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/set_interpElections_cache_dir.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set a custom interpElections cache directory — set_interpElections_cache_dir","text":"Invisibly returns cache directory path.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/set_java_memory.html","id":null,"dir":"Reference","previous_headings":"","what":"Set Java heap memory for r5r — set_java_memory","title":"Set Java heap memory for r5r — set_java_memory","text":"Configures maximum heap size Java Virtual Machine used r5r. Large travel-time matrices can require several gigabytes JVM heap.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/set_java_memory.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set Java heap memory for r5r — set_java_memory","text":"","code":"set_java_memory(size, persist = interactive())"},{"path":"https://antrologos.github.io/interpElections/reference/set_java_memory.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set Java heap memory for r5r — set_java_memory","text":"size Character. Memory size unit suffix, e.g. \"4g\" 4 GB, \"512m\" 512 MB, \"8g\" 8 GB. persist Logical. Also write ~/.Renviron setting persists across R sessions. Default: TRUE interactive sessions.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/set_java_memory.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set Java heap memory for r5r — set_java_memory","text":"Invisibly, previous value getOption(\"java.parameters\").","code":""},{"path":"https://antrologos.github.io/interpElections/reference/set_java_memory.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Set Java heap memory for r5r — set_java_memory","text":"sets options(java.parameters = \"-Xmx{size}\"). must called r5r (rJava) loaded — JVM starts, heap size changed without restarting R. rule thumb: allocate \\(\\ge 2\\) GB per million OD pairs expect travel-time matrix. municipality 5,000 census tracts 200 polling locations, 1 million pairs — 2-4 GB usually enough. Larger cities (e.g. Sao Paulo) may need 8-16 GB.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/set_java_memory.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set Java heap memory for r5r — set_java_memory","text":"","code":"if (FALSE) { # \\dontrun{ set_java_memory(\"4g\") set_java_memory(\"8g\", persist = TRUE) } # }"},{"path":"https://antrologos.github.io/interpElections/reference/setup_java.html","id":null,"dir":"Reference","previous_headings":"","what":"Download and configure Java 21 for r5r — setup_java","title":"Download and configure Java 21 for r5r — setup_java","text":"Downloads Adoptium Temurin JDK 21 current platform, extracts local directory, configures R session r5r can find . Optionally persists configuration ~/.Renviron.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/setup_java.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Download and configure Java 21 for r5r — setup_java","text":"","code":"setup_java(   install_dir = file.path(tools::R_user_dir(\"interpElections\", \"data\"), \"java\"),   persist = interactive(),   verbose = TRUE )"},{"path":"https://antrologos.github.io/interpElections/reference/setup_java.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Download and configure Java 21 for r5r — setup_java","text":"install_dir Character. install Java. Default uses tools::R_user_dir() Java lives alongside R user data. persist Logical. Write JAVA_HOME ~/.Renviron persists across R sessions. Default: TRUE interactive sessions. verbose Logical. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/setup_java.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Download and configure Java 21 for r5r — setup_java","text":"Invisibly, path installed JDK.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/setup_java.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Download and configure Java 21 for r5r — setup_java","text":"JDK downloaded Eclipse Adoptium project (https://adoptium.net). archive extracted install_dir/jdk-21 JAVA_HOME set current session. persist = TRUE, function appends (updates) JAVA_HOME line ~/.Renviron future R sessions find Java automatically.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/setup_java.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Download and configure Java 21 for r5r — setup_java","text":"","code":"if (FALSE) { # \\dontrun{ setup_java() check_r5r() } # }"},{"path":"https://antrologos.github.io/interpElections/reference/setup_osmium.html","id":null,"dir":"Reference","previous_headings":"","what":"Install osmium-tool for OSM file clipping — setup_osmium","title":"Install osmium-tool for OSM file clipping — setup_osmium","text":"Attempts install osmium-tool (osmconvert fallback) using system package manager. required clip large state-level OSM extracts municipality-level bounding boxes r5r routing.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/setup_osmium.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Install osmium-tool for OSM file clipping — setup_osmium","text":"","code":"setup_osmium(method = NULL, verbose = TRUE)"},{"path":"https://antrologos.github.io/interpElections/reference/setup_osmium.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Install osmium-tool for OSM file clipping — setup_osmium","text":"method Character NULL. Installation method use. NULL (default), auto-detects. Options: \"conda\": conda install (platforms) \"brew\": Homebrew (macOS) \"apt\": apt-get (Debian/Ubuntu) \"dnf\": dnf (Fedora/RHEL) \"download\": Download osmconvert binary (Windows ) verbose Logical. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/setup_osmium.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Install osmium-tool for OSM file clipping — setup_osmium","text":"Invisibly, path installed tool, NULL installation failed.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/setup_osmium.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Install osmium-tool for OSM file clipping — setup_osmium","text":"preferred tool osmium-tool, faster reliable. osmconvert used fallback osmium available. Windows, \"download\" method fetches pre-compiled osmconvert.exe binary saves interpElections cache. require conda package manager.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/setup_osmium.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Install osmium-tool for OSM file clipping — setup_osmium","text":"","code":"if (FALSE) { # \\dontrun{ setup_osmium() setup_osmium(method = \"conda\") setup_osmium(method = \"download\")  # Windows only } # }"},{"path":"https://antrologos.github.io/interpElections/reference/setup_torch.html","id":null,"dir":"Reference","previous_headings":"","what":"Install and configure torch with GPU support — setup_torch","title":"Install and configure torch with GPU support — setup_torch","text":"Installs torch R package (missing) downloads platform-appropriate libtorch + lantern binaries GPU support. installation, verifies GPU acceleration works via check_torch().","code":""},{"path":"https://antrologos.github.io/interpElections/reference/setup_torch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Install and configure torch with GPU support — setup_torch","text":"","code":"setup_torch(reinstall = FALSE, type = NULL, verbose = TRUE)"},{"path":"https://antrologos.github.io/interpElections/reference/setup_torch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Install and configure torch with GPU support — setup_torch","text":"reinstall Logical. Force re-download libtorch/lantern binaries even already exist. Use fix broken CUDA installations (e.g., CPU-lantern accidentally installed). Default: FALSE. type Character NULL. Installation type, passed torch::install_torch(). Common values: NULL (auto-detect), \"cuda\" (force CUDA Windows/Linux), \"cpu\" (force CPU-). Default: NULL (auto-detect based available GPU). verbose Logical. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/setup_torch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Install and configure torch with GPU support — setup_torch","text":"Invisibly, result check_torch() installation, partial list needs_restart = TRUE R must restarted.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/setup_torch.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Install and configure torch with GPU support — setup_torch","text":"installation proceeds stages: torch R package installed, installed CRAN. torch::install_torch() downloads libtorch lantern binaries. Windows/Linux NVIDIA GPU CUDA toolkit, automatically selects CUDA-enabled binaries. verification step runs check_torch() confirm GPU works. Important: torch package already loaded current R session calling setup_torch(), must restart R new binaries take effect. function detects warns accordingly.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/setup_torch.html","id":"cuda-auto-detection","dir":"Reference","previous_headings":"","what":"CUDA auto-detection","title":"Install and configure torch with GPU support — setup_torch","text":"torch::install_torch() detects CUDA version : CUDA environment variable (set, forces version) CUDA_PATH (Windows) CUDA_HOME (Linux) nvcc --version PATH","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/setup_torch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Install and configure torch with GPU support — setup_torch","text":"","code":"if (FALSE) { # \\dontrun{ setup_torch()                    # auto-detect GPU setup_torch(type = \"cuda\")       # force CUDA setup_torch(reinstall = TRUE)    # fix broken install } # }"},{"path":"https://antrologos.github.io/interpElections/reference/sinkhorn_balance.html","id":null,"dir":"Reference","previous_headings":"","what":"Balance a weight matrix using Sinkhorn/IPF iterations — sinkhorn_balance","title":"Balance a weight matrix using Sinkhorn/IPF iterations — sinkhorn_balance","text":"Applies alternating row column scaling enforce row column marginal constraints simultaneously. Also known Iterative Proportional Fitting (IPF) RAS algorithm.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/sinkhorn_balance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Balance a weight matrix using Sinkhorn/IPF iterations — sinkhorn_balance","text":"","code":"sinkhorn_balance(   W,   row_targets = NULL,   col_targets = NULL,   max_iter = 1000L,   tol = 1e-10 )"},{"path":"https://antrologos.github.io/interpElections/reference/sinkhorn_balance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Balance a weight matrix using Sinkhorn/IPF iterations — sinkhorn_balance","text":"W Numeric matrix [n x m]. Raw non-negative weight matrix. row_targets Numeric vector length n. Desired row sums. Default: NULL (uniform: rep(sum(col_targets) / n, n)). col_targets Numeric vector length m. Desired column sums. Default: NULL (rep(1, m), preserving source totals). max_iter Integer. Maximum Sinkhorn iterations. Default: 1000. tol Numeric. Convergence tolerance maximum marginal error. Default: 1e-10.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/sinkhorn_balance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Balance a weight matrix using Sinkhorn/IPF iterations — sinkhorn_balance","text":"Numeric matrix [n x m] row sums approximately equal row_targets column sums approximately equal col_targets. Attributes: iterations Integer. Number iterations performed. converged Logical. Whether convergence tolerance met. unreachable Integer vector. Indices -zero rows (skipped).","code":""},{"path":"https://antrologos.github.io/interpElections/reference/sinkhorn_balance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Balance a weight matrix using Sinkhorn/IPF iterations — sinkhorn_balance","text":"iteration: Row scaling: multiply row row_targets[] / rowSums(W)[] Column scaling: multiply column col_targets[j] / colSums(W)[j] Rows -zero (unreachable targets) skipped scaling remain zero. warning issued listing rows. algorithm requires sum(row_targets) approximately equal sum(col_targets) feasibility. warning issued differ 1\\","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/sinkhorn_balance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Balance a weight matrix using Sinkhorn/IPF iterations — sinkhorn_balance","text":"","code":"W <- matrix(c(3, 1, 0.5, 2, 4, 1.5), nrow = 2) balanced <- sinkhorn_balance(W, row_targets = c(1, 2), col_targets = c(1, 1, 1)) rowSums(balanced)  # approx c(1, 2) #> [1] 1 2 colSums(balanced)  # approx c(1, 1, 1) #> [1] 1 1 1"},{"path":"https://antrologos.github.io/interpElections/reference/sinkhorn_objective.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the per-bracket Sinkhorn-balanced interpolation objective — sinkhorn_objective","title":"Compute the per-bracket Sinkhorn-balanced interpolation objective — sinkhorn_objective","text":"Calculates sum squared errors per-bracket Sinkhorn-balanced IDW-interpolated values known population. R-level version loss function used optimize_alpha().","code":""},{"path":"https://antrologos.github.io/interpElections/reference/sinkhorn_objective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the per-bracket Sinkhorn-balanced interpolation objective — sinkhorn_objective","text":"","code":"sinkhorn_objective(   alpha,   time_matrix,   pop_matrix,   source_matrix,   row_targets,   sk_iter = 50L )"},{"path":"https://antrologos.github.io/interpElections/reference/sinkhorn_objective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the per-bracket Sinkhorn-balanced interpolation objective — sinkhorn_objective","text":"alpha Numeric vector length n. Decay parameters. time_matrix Numeric matrix [n x m]. Adjusted travel times (offset already applied). Must strictly positive. pop_matrix Numeric matrix [n x k]. Known population per zone. source_matrix Numeric matrix [m x k]. Known counts source points. row_targets Numeric vector length n. Desired row sums final aggregate Sinkhorn balancing. sk_iter Integer. Maximum Sinkhorn iterations per bracket final aggregate step. Default: 50.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/sinkhorn_objective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the per-bracket Sinkhorn-balanced interpolation objective — sinkhorn_objective","text":"Single numeric value: sum((W_balanced %*% source_matrix - pop_matrix)^2).","code":""},{"path":"https://antrologos.github.io/interpElections/reference/sinkhorn_objective.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute the per-bracket Sinkhorn-balanced interpolation objective — sinkhorn_objective","text":"Builds per-bracket weight matrix: demographic column, runs convergence-based Sinkhorn bracket-specific row/column targets, sums contributions applies final aggregate Sinkhorn enforce overall row column constraints. Computes calibration SSE known population. Note: time_matrix expected offset already applied (.e., time_matrix + offset). apply offset .","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/sinkhorn_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Sinkhorn-balanced IDW weights — sinkhorn_weights","title":"Compute Sinkhorn-balanced IDW weights — sinkhorn_weights","text":"Builds inverse distance weights travel-time matrix per-zone decay parameters, applies Sinkhorn balancing enforce row column marginal constraints.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/sinkhorn_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Sinkhorn-balanced IDW weights — sinkhorn_weights","text":"","code":"sinkhorn_weights(   time_matrix,   alpha,   offset = 1,   row_targets = NULL,   col_targets = NULL,   pop_matrix = NULL,   source_matrix = NULL,   max_iter = 1000L,   tol = 1e-10 )"},{"path":"https://antrologos.github.io/interpElections/reference/sinkhorn_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Sinkhorn-balanced IDW weights — sinkhorn_weights","text":"time_matrix Numeric matrix [n x m]. Raw travel times. Rows = target zones, columns = source points. alpha Numeric vector length n. Decay parameters per target zone. offset Numeric. Added travel times applying decay. Default: 1. row_targets Numeric vector length n. Desired row sums. electoral interpolation, use pop / sum(pop) * m pop population vector m = ncol(time_matrix). Default: NULL (uniform allocation). col_targets Numeric vector length m. Desired column sums. Default: NULL (rep(1, m) source conservation). pop_matrix Numeric matrix [n x k] NULL. Population per zone per demographic bracket. provided together source_matrix, enables per-bracket Sinkhorn mode. Default: NULL. source_matrix Numeric matrix [m x k] NULL. Source counts per demographic bracket. Must provided together pop_matrix. Default: NULL. max_iter Integer. Max Sinkhorn iterations. Default: 1000. tol Numeric. Convergence tolerance. Default: 1e-10.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/sinkhorn_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Sinkhorn-balanced IDW weights — sinkhorn_weights","text":"Numeric matrix [n x m]. Sinkhorn-balanced weights rowSums(W) approximately equal row_targets colSums(W) approximately equal col_targets. Preserves dimnames time_matrix. Carries attributes sinkhorn_balance().","code":""},{"path":"https://antrologos.github.io/interpElections/reference/sinkhorn_weights.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Sinkhorn-balanced IDW weights — sinkhorn_weights","text":"pop_matrix source_matrix provided, per-bracket Sinkhorn balancing used: demographic column gets Sinkhorn transport (row targets rescaled match source totals), bracket contributions summed final aggregate Sinkhorn enforces overall row_targets / col_targets constraints.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/sinkhorn_weights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Sinkhorn-balanced IDW weights — sinkhorn_weights","text":"","code":"tt <- matrix(c(2, 5, 3, 4, 6, 2), nrow = 2) alpha <- c(1, 1.5) pop <- c(100, 200) m <- ncol(tt) W <- sinkhorn_weights(tt, alpha, row_targets = pop / sum(pop) * m) colSums(W)  # approx 1 (source conservation) #> [1] 1 1 1 rowSums(W)  # proportional to population #> [1] 1 2"},{"path":"https://antrologos.github.io/interpElections/reference/summary.interpElections_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize an interpElections result — summary.interpElections_result","title":"Summarize an interpElections result — summary.interpElections_result","text":"Prints detailed summary including calibration information, optimization details, per-variable statistics.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/summary.interpElections_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize an interpElections result — summary.interpElections_result","text":"","code":"# S3 method for class 'interpElections_result' summary(object, ...)"},{"path":"https://antrologos.github.io/interpElections/reference/summary.interpElections_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize an interpElections result — summary.interpElections_result","text":"object interpElections_result object. ... Ignored.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/summary.interpElections_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize an interpElections result — summary.interpElections_result","text":"Invisibly returns object.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/use_gpu.html","id":null,"dir":"Reference","previous_headings":"","what":"Enable or disable GPU acceleration — use_gpu","title":"Enable or disable GPU acceleration — use_gpu","text":"Sets package-wide options controlling whether optimize_alpha() uses GPU-accelerated optimization (PB-SGD) CPU-methods.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/use_gpu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Enable or disable GPU acceleration — use_gpu","text":"","code":"use_gpu(enable = TRUE, device = NULL, dtype = \"float32\")"},{"path":"https://antrologos.github.io/interpElections/reference/use_gpu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Enable or disable GPU acceleration — use_gpu","text":"enable Logical. TRUE enable GPU, FALSE CPU . device Character NULL. Torch device: \"cuda\", \"mps\", \"cpu\". NULL = auto-detect. dtype Character. \"float32\" \"float64\". Default: \"float32\".","code":""},{"path":"https://antrologos.github.io/interpElections/reference/use_gpu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Enable or disable GPU acceleration — use_gpu","text":"Invisibly returns previous settings list.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/use_gpu.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Enable or disable GPU acceleration — use_gpu","text":"GPU enabled, optimize_alpha() uses torch-based PB-SGD (per-bracket stochastic gradient descent). requires torch package installed working GPU backend (CUDA NVIDIA, MPS Apple Silicon). per-call use_gpu parameter optimize_alpha() always overrides global setting.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/use_gpu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Enable or disable GPU acceleration — use_gpu","text":"","code":"use_gpu(FALSE) # ensure CPU mode #> GPU disabled. Using CPU optimization."}]
