[{"path":"https://antrologos.github.io/interpElections/articles/brazilian-elections.html","id":"prerequisites","dir":"Articles","previous_headings":"","what":"Prerequisites","title":"Interpolating Brazilian Electoral Data","text":"Brazilian workflow requires several packages census data, shapefiles, travel-time routing. Install : Travel-time computation requires Java 21+ r5r package: GPU-accelerated optimization (optional, large municipalities):","code":"install.packages(c(\"sf\", \"geobr\", \"censobr\", \"dplyr\", \"tidyr\",                     \"data.table\", \"stringr\", \"arrow\")) install.packages(\"r5r\")  # Install Java 21 (if not already installed) setup_java()  # Verify Java + r5r are properly configured check_r5r() setup_torch() check_torch()"},{"path":"https://antrologos.github.io/interpElections/articles/brazilian-elections.html","id":"one-call-workflow","dir":"Articles","previous_headings":"","what":"One-Call Workflow","title":"Interpolating Brazilian Electoral Data","text":"simplest way use package interpolate_election_br(), handles everything automatically. need IBGE municipality code election year: vignette, load pre-computed result instead running full pipeline (requires network access Java): result interpElections_result object rich summary(): Plot first interpolated variable choropleth map:","code":"library(interpElections)  result <- interpolate_election_br(   code_muni = 1400100,  # Boa Vista, RR   year = 2020 ) library(interpElections) #> interpElections: some optional dependencies are missing: #> - No OSM clipping tool found (osmium/osmconvert) #>   Install with: interpElections::setup_osmium() #> These are needed for the full interpolation pipeline.  result <- readRDS(   system.file(\"extdata/example_br_result.rds\", package = \"interpElections\") ) summary(result) #> interpElections result summary #> --------------------------------------------------  #> Municipality: 1400100 (election 2020, census 2022) #> Zones: 506 | Sources: 149 | Variables: 11 #>  #> Calibration brackets: #>   Zones:   pop_15_24, pop_25_29, pop_30_39, pop_40_49, pop_50_59, pop_60_69 #>   Sources: votantes_15_24, votantes_25_29, votantes_30_39, votantes_40_49, votantes_50_59, votantes_60_69 #>  #> Optimization: cpu_lbfgsb | Objective: 5041410.9862 | Convergence: 0 #>   Alpha: min=0.991, Q1=1.293, median=1.460, Q3=1.645, max=9.541 #>  #> Interpolated variables: #>   QT_COMPARECIMENTO              total=    165428  mean=   326.9  [0.0, 1073.7] #>   CAND_18999                     total=      1606  mean=     3.2  [0.0, 11.5] #>   CAND_90123                     total=       135  mean=     0.3  [0.0, 1.7] #>   CAND_12012                     total=        64  mean=     0.1  [0.0, 0.6] #>   CAND_25000                     total=       616  mean=     1.2  [0.0, 3.8] #>   CAND_22444                     total=       442  mean=     0.9  [0.0, 3.2] #>   CAND_28029                     total=        66  mean=     0.1  [0.0, 1.0] #>   CAND_14100                     total=       337  mean=     0.7  [0.0, 2.6] #>   CAND_77234                     total=       394  mean=     0.8  [0.0, 3.0] #>   CAND_28008                     total=       371  mean=     0.7  [0.0, 3.4] #>   CAND_22123                     total=       190  mean=     0.4  [0.0, 1.3] #>  #> Object size: 0.8 MB (lightweight) plot(result)"},{"path":"https://antrologos.github.io/interpElections/articles/brazilian-elections.html","id":"filtering-what-to-interpolate","dir":"Articles","previous_headings":"One-Call Workflow","what":"Filtering what to interpolate","title":"Interpolating Brazilian Electoral Data","text":"parameter controls variables interpolated. candidates parties parameters filter specific subsets:","code":"# Only specific candidates (by ballot number or name) result <- interpolate_election_br(   code_muni = 1400100, year = 2020,   what = \"candidates\",   candidates = c(13, 22) )  # Party-level vote totals result <- interpolate_election_br(   code_muni = 1400100, year = 2020,   what = \"parties\",   parties = c(\"PT\", \"PL\") )  # Turnout and abstention result <- interpolate_election_br(   code_muni = 1400100, year = 2020,   what = \"turnout\" )  # Voter demographics (gender + education level) result <- interpolate_election_br(   code_muni = 1400100, year = 2020,   what = \"demographics\" )"},{"path":"https://antrologos.github.io/interpElections/articles/brazilian-elections.html","id":"the-municipality-crosswalk","dir":"Articles","previous_headings":"","what":"The Municipality Crosswalk","title":"Interpolating Brazilian Electoral Data","text":"Brazilian electoral data uses TSE 5-digit codes, census data uses IBGE 7-digit codes. package includes crosswalk table mapping 5,710 municipalities: Search name state: call interpolate_election_br(), TSE code state abbreviation resolved automatically IBGE code.","code":"data(muni_crosswalk) dim(muni_crosswalk) #> [1] 5710    4 head(muni_crosswalk) #>   code_ibge code_tse uf            nome #> 1   1200013    01120 AC      ACRELÂNDIA #> 2   1200054    01570 AC    ASSIS BRASIL #> 3   1200104    01058 AC       BRASILÉIA #> 4   1200138    01007 AC          BUJARI #> 5   1200179    01015 AC        CAPIXABA #> 6   1200203    01074 AC CRUZEIRO DO SUL # Find Boa Vista subset(muni_crosswalk, grepl(\"BOA VISTA\", nome)) #>      code_ibge code_tse uf                       nome #> 136    1300680    02976 AM         BOA VISTA DO RAMOS #> 247    2903805    33758 BA         BOA VISTA DO TUPIM #> 1160   2101970    07323 MA        BOA VISTA DO GURUPI #> 2281   5100359    90042 MT             ALTO BOA VISTA #> 2547   1507706    05533 PA SÃO SEBASTIÃO DA BOA VISTA #> 2592   2502151    19941 PB                  BOA VISTA #> 2930   2612604    25518 PE   SANTA MARIA DA BOA VISTA #> 3234   4103057    79812 PR     BOA VISTA DA APARECIDA #> 3549   4125407    78832 PR      SÃO JOSÉ DA BOA VISTA #> 3908   1400100    03018 RR                  BOA VISTA #> 3962   4302154    86428 RS      BOA VISTA DAS MISSÕES #> 3963   4302204    85430 RS        BOA VISTA DO BURICÁ #> 3964   4302220    89044 RS       BOA VISTA DO CADEADO #> 3965   4302238    89060 RS         BOA VISTA DO INCRA #> 3966   4302253    88161 RS           BOA VISTA DO SUL #> 4191   4312955    87203 RS             NOVA BOA VISTA #> 4290   4317004    88439 RS       SANTANA DA BOA VISTA #> 4676   4217154    80780 SC    SÃO MIGUEL DA BOA VISTA #> 5352   3549102    70831 SP      SÃO JOÃO DA BOA VISTA  # All municipalities in Roraima subset(muni_crosswalk, uf == \"RR\") #>      code_ibge code_tse uf               nome #> 3906   1400050    03050 RR        ALTO ALEGRE #> 3907   1400027    03042 RR            AMAJARI #> 3908   1400100    03018 RR          BOA VISTA #> 3909   1400159    03077 RR             BONFIM #> 3910   1400175    03069 RR              CANTÁ #> 3911   1400209    03034 RR          CARACARAÍ #> 3912   1400233    03000 RR            CAROEBE #> 3913   1400282    03026 RR            IRACEMA #> 3914   1400308    03093 RR            MUCAJAÍ #> 3915   1400407    03115 RR          NORMANDIA #> 3916   1400456    03123 RR          PACARAIMA #> 3917   1400472    03085 RR       RORAINÓPOLIS #> 3918   1400506    03131 RR SÃO JOÃO DA BALIZA #> 3919   1400605    03158 RR           SÃO LUIZ #> 3920   1400704    03107 RR           UIRAMUTÃ"},{"path":"https://antrologos.github.io/interpElections/articles/brazilian-elections.html","id":"step-by-step-workflow","dir":"Articles","previous_headings":"","what":"Step-by-Step Workflow","title":"Interpolating Brazilian Electoral Data","text":"hood, interpolate_election_br() runs five preparation steps calling core interpolation engine. can run step individually control.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/brazilian-elections.html","id":"step-1-census-population","dir":"Articles","previous_headings":"Step-by-Step Workflow","what":"Step 1 – Census population","title":"Interpolating Brazilian Electoral Data","text":"br_prepare_population() downloads census population data (via censobr) groups ages brackets match TSE voter profile data: census year auto-selected based election year: can override census_year parameter.","code":"pop_data <- br_prepare_population(code_muni = 1400100, year = 2022) pop_data <- readRDS(   system.file(\"extdata/example_pop_data.rds\", package = \"interpElections\") ) head(pop_data) #>            code_tract code_muni pop_00_04 pop_05_09 pop_10_14 pop_15_19 #> 15351 140010005000001   1400100         6        16         9        10 #> 15352 140010005000002   1400100        20        30        24        22 #> 15353 140010005000003   1400100        22        19        23        15 #> 15354 140010005000004   1400100        20        17        15        18 #> 15355 140010005000007   1400100        21        36        24        31 #> 15356 140010005000009   1400100        23        20        17        26 #>       pop_20_24 pop_25_29 pop_30_39 pop_40_49 pop_50_59 pop_60_69 pop_70mais #> 15351        16        14        38        25        30        14          7 #> 15352        38        41        62        54        37        38         17 #> 15353        31        23        42        30        25        19          8 #> 15354        28        27        28        31        26        11         27 #> 15355        33        36        93        71        58        42         30 #> 15356        23        30        59        58        41        39         27 str(pop_data) #> 'data.frame':    528 obs. of  13 variables: #>  $ code_tract: chr  \"140010005000001\" \"140010005000002\" \"140010005000003\" \"140010005000004\" ... #>  $ code_muni : num  1400100 1400100 1400100 1400100 1400100 ... #>  $ pop_00_04 : num  6 20 22 20 21 23 18 21 31 10 ... #>  $ pop_05_09 : num  16 30 19 17 36 20 13 16 18 13 ... #>  $ pop_10_14 : num  9 24 23 15 24 17 8 22 25 21 ... #>  $ pop_15_19 : num  10 22 15 18 31 26 13 16 36 13 ... #>  $ pop_20_24 : num  16 38 31 28 33 23 21 23 26 23 ... #>  $ pop_25_29 : num  14 41 23 27 36 30 18 25 25 21 ... #>  $ pop_30_39 : num  38 62 42 28 93 59 36 38 69 45 ... #>  $ pop_40_49 : num  25 54 30 31 71 58 36 39 41 41 ... #>  $ pop_50_59 : num  30 37 25 26 58 41 26 30 49 30 ... #>  $ pop_60_69 : num  14 38 19 11 42 39 29 31 27 30 ... #>  $ pop_70mais: num  7 17 8 27 30 27 28 33 31 33 ..."},{"path":"https://antrologos.github.io/interpElections/articles/brazilian-elections.html","id":"step-2-tract-geometries","dir":"Articles","previous_headings":"Step-by-Step Workflow","what":"Step 2 – Tract geometries","title":"Interpolating Brazilian Electoral Data","text":"br_prepare_tracts() downloads census tract shapefiles via geobr, joins population data, optionally removes unpopulated tracts:  Additional options: remove_unpopulated = TRUE (default): drops tracts zero population. clip_sf: pass sf polygon clip tracts urban boundary, removing parks, forests, water bodies.","code":"tracts_sf <- br_prepare_tracts(   code_muni = 1400100,   pop_data = pop_data ) tracts_sf <- readRDS(   system.file(\"extdata/example_tracts_sf.rds\", package = \"interpElections\") ) dim(tracts_sf) #> [1] 506  14 names(tracts_sf) #>  [1] \"code_tract\" \"pop_00_04\"  \"pop_05_09\"  \"pop_10_14\"  \"pop_15_19\"  #>  [6] \"pop_20_24\"  \"pop_25_29\"  \"pop_30_39\"  \"pop_40_49\"  \"pop_50_59\"  #> [11] \"pop_60_69\"  \"pop_70mais\" \"pop_total\"  \"geom\" #> Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE library(sf) plot(st_geometry(tracts_sf), main = \"Census tracts\")"},{"path":"https://antrologos.github.io/interpElections/articles/brazilian-elections.html","id":"step-3-electoral-data","dir":"Articles","previous_headings":"Step-by-Step Workflow","what":"Step 3 – Electoral data","title":"Interpolating Brazilian Electoral Data","text":"br_prepare_electoral() downloads TSE voting data, merges geocoded polling station coordinates, aggregates polling-location level: , candidates, parties parameters work way interpolate_election_br().","code":"electoral_data <- br_prepare_electoral(   code_muni_ibge = \"1400100\",   code_muni_tse = \"03018\",   uf = \"RR\",   year = 2020 ) electoral_data <- readRDS(   system.file(\"extdata/example_electoral_data.rds\", package = \"interpElections\") ) head(electoral_data[, 1:8]) #> # A tibble: 6 × 8 #>      id   lat  long votantes_18_20 votantes_21_24 votantes_25_29 votantes_30_34 #>   <int> <dbl> <dbl>          <int>          <int>          <int>          <int> #> 1     1  2.76 -60.7            125            180            212            239 #> 2     2  2.76 -60.7             23             90            126            113 #> 3     3  2.76 -60.7              9             69             17             15 #> 4     4  2.76 -60.7            192            153             86            110 #> 5     5  2.76 -60.7             18             26             30             23 #> 6     6  2.76 -60.7              8             76             93             84 #> # ℹ 1 more variable: votantes_35_39 <int> names(electoral_data) #>  [1] \"id\"                \"lat\"               \"long\"              #>  [4] \"votantes_18_20\"    \"votantes_21_24\"    \"votantes_25_29\"    #>  [7] \"votantes_30_34\"    \"votantes_35_39\"    \"votantes_40_44\"    #> [10] \"votantes_45_49\"    \"votantes_50_54\"    \"votantes_55_59\"    #> [13] \"votantes_60_64\"    \"votantes_65_69\"    \"QT_COMPARECIMENTO\" #> [16] \"CAND_18999\"        \"CAND_90123\"        \"CAND_12012\"        #> [19] \"CAND_25000\"        \"CAND_22444\"        \"CAND_28029\"        #> [22] \"CAND_14100\"        \"CAND_77234\"        \"CAND_28008\"        #> [25] \"CAND_22123\""},{"path":"https://antrologos.github.io/interpElections/articles/brazilian-elections.html","id":"step-4-travel-times","dir":"Articles","previous_headings":"Step-by-Step Workflow","what":"Step 4 – Travel times","title":"Interpolating Brazilian Electoral Data","text":"Travel-time computation requires r5r Java runtime. package can download OSM road network automatically: already travel-time matrix another source, skip step entirely passing via time_matrix parameter interpolate_election_br() interpolate_election().","code":"# Download OSM road network for the municipality r5r_data <- download_r5r_data(   area_sf    = tracts_sf,   output_dir = \"r5r_network/boa_vista\" )  # Convert electoral data to sf points electoral_sf <- sf::st_as_sf(electoral_data,                               coords = c(\"long\", \"lat\"), crs = 4326)  # Compute travel-time matrix (tract centroids -> polling locations) tt_matrix <- compute_travel_times(   zones_sf     = tracts_sf,   points_sf    = electoral_sf,   network_path = r5r_data$output_dir,   mode         = \"WALK\",   max_trip_duration = 300 )"},{"path":"https://antrologos.github.io/interpElections/articles/brazilian-elections.html","id":"step-5-optimize-and-interpolate","dir":"Articles","previous_headings":"Step-by-Step Workflow","what":"Step 5 – Optimize and interpolate","title":"Interpolating Brazilian Electoral Data","text":"final step finds optimal decay parameters (alpha) applies IDW interpolation:","code":"# Find optimal alpha (one per tract) optim_result <- optimize_alpha(   time_matrix = tt_matrix,   pop_matrix = pop_matrix,   source_matrix = source_matrix )  # Apply interpolation with the optimized alpha interpolated <- idw_interpolate(   time_matrix = tt_matrix,   alpha = optim_result$alpha,   source_matrix = electoral_matrix )"},{"path":"https://antrologos.github.io/interpElections/articles/brazilian-elections.html","id":"downloading-raw-tse-data","dir":"Articles","previous_headings":"","what":"Downloading Raw TSE Data","title":"Interpolating Brazilian Electoral Data","text":"package provides direct access TSE open data custom analyses: Note: geocoding data available TSE elections approximately 2014.","code":"# Candidate vote data (votacao por secao eleitoral) votes <- br_download_votes(year = 2020, uf = \"RR\")  # Turnout/attendance data (comparecimento e abstencao) turnout <- br_download_turnout(year = 2020, uf = \"RR\")  # Polling station geocodes (latitude/longitude) geocodes <- br_download_geocode(year = 2020, uf = \"RR\")"},{"path":"https://antrologos.github.io/interpElections/articles/brazilian-elections.html","id":"supported-elections","dir":"Articles","previous_headings":"","what":"Supported Elections","title":"Interpolating Brazilian Electoral Data","text":"Brazil holds elections every two years, alternating municipal general (federal/state) elections: Municipal elections (2000, 2004, 2008, 2012, 2016, 2020, 2024): General elections (2002, 2006, 2010, 2014, 2018, 2022): Use turno parameter select election round: 1 (first round, always available) 2 (runoff, executive offices candidate wins outright).","code":""},{"path":"https://antrologos.github.io/interpElections/articles/custom-data.html","id":"when-to-use-this-vignette","dir":"Articles","previous_headings":"","what":"When to Use This Vignette","title":"Using interpElections with Your Own Data","text":"Use interpElections : Source points (e.g., schools, hospitals, weather stations, sensors) counts measurements one variables. Target polygons (e.g., districts, neighborhoods, grid cells) known totals least one calibration variable. need disaggregate source data target polygons, calibrated known totals. calibration step distinguishes IDW interpolation naive spatial allocation: package finds per-zone decay parameters minimize discrepancy interpolated observed totals.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/custom-data.html","id":"preparing-your-data","dir":"Articles","previous_headings":"","what":"Preparing Your Data","title":"Using interpElections with Your Own Data","text":"Let us build small synthetic example: 6 rectangular districts known population two age groups, 10 schools enrollment counts groups plus “budget” variable want interpolate. key requirement calibration columns must measure thing layers. , pop_young/pop_old districts enroll_young/enroll_old schools measure population counts age group. budget column counterpart districts – variable want spatially disaggregate.","code":"library(interpElections) #> interpElections: some optional dependencies are missing: #> - No OSM clipping tool found (osmium/osmconvert) #>   Install with: interpElections::setup_osmium() #> These are needed for the full interpolation pipeline. library(sf) #> Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE  # -- Target zones: 6 rectangular districts in a 3x2 grid -- make_rect <- function(x0, y0, w = 1, h = 1) {   st_polygon(list(matrix(c(     x0, y0,     x0 + w, y0,     x0 + w, y0 + h,     x0, y0 + h,     x0, y0   ), ncol = 2, byrow = TRUE))) }  districts_sf <- st_sf(   id = paste0(\"D\", 1:6),   pop_young = c(120, 200, 150, 180, 90, 160),   pop_old   = c(80, 100, 130, 70, 110, 95),   geometry  = st_sfc(     make_rect(0, 0), make_rect(1, 0), make_rect(2, 0),     make_rect(0, 1), make_rect(1, 1), make_rect(2, 1),     crs = 4326   ) )  # -- Source points: 10 schools scattered across the grid -- set.seed(42) schools_sf <- st_sf(   id = paste0(\"S\", 1:10),   enroll_young = c(55, 80, 45, 70, 60, 35, 90, 40, 65, 50),   enroll_old   = c(30, 50, 40, 25, 45, 55, 35, 60, 20, 38),   budget       = c(500, 800, 350, 620, 410, 290, 750, 380, 530, 440),   geometry     = st_sfc(     st_point(c(0.3, 0.2)), st_point(c(0.8, 0.4)),     st_point(c(1.3, 0.3)), st_point(c(1.7, 0.8)),     st_point(c(2.2, 0.5)), st_point(c(2.6, 0.7)),     st_point(c(0.5, 1.3)), st_point(c(1.2, 1.6)),     st_point(c(1.8, 1.2)), st_point(c(2.5, 1.5)),     crs = 4326   ) )  print(districts_sf) #> Simple feature collection with 6 features and 3 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 3 ymax: 2 #> Geodetic CRS:  WGS 84 #>   id pop_young pop_old                       geometry #> 1 D1       120      80 POLYGON ((0 0, 1 0, 1 1, 0 ... #> 2 D2       200     100 POLYGON ((1 0, 2 0, 2 1, 1 ... #> 3 D3       150     130 POLYGON ((2 0, 3 0, 3 1, 2 ... #> 4 D4       180      70 POLYGON ((0 1, 1 1, 1 2, 0 ... #> 5 D5        90     110 POLYGON ((1 1, 2 1, 2 2, 1 ... #> 6 D6       160      95 POLYGON ((2 1, 3 1, 3 2, 2 ... print(schools_sf) #> Simple feature collection with 10 features and 4 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 0.3 ymin: 0.2 xmax: 2.6 ymax: 1.6 #> Geodetic CRS:  WGS 84 #>     id enroll_young enroll_old budget        geometry #> 1   S1           55         30    500 POINT (0.3 0.2) #> 2   S2           80         50    800 POINT (0.8 0.4) #> 3   S3           45         40    350 POINT (1.3 0.3) #> 4   S4           70         25    620 POINT (1.7 0.8) #> 5   S5           60         45    410 POINT (2.2 0.5) #> 6   S6           35         55    290 POINT (2.6 0.7) #> 7   S7           90         35    750 POINT (0.5 1.3) #> 8   S8           40         60    380 POINT (1.2 1.6) #> 9   S9           65         20    530 POINT (1.8 1.2) #> 10 S10           50         38    440 POINT (2.5 1.5)"},{"path":"https://antrologos.github.io/interpElections/articles/custom-data.html","id":"the-interpolate_election-wrapper","dir":"Articles","previous_headings":"","what":"The interpolate_election() Wrapper","title":"Using interpElections with Your Own Data","text":"interpolate_election() general-purpose wrapper (specific Brazil). accepts sf objects handles matrix construction internally. First, build simple Euclidean distance matrix. real application use travel times (see Section 4.6), distances work well demonstration: Now call interpolate_election():  result object contains interpolated sf data frame, optimized alpha vector, optimization diagnostics.","code":"coords_zones <- st_coordinates(suppressWarnings(st_centroid(districts_sf))) coords_pts   <- st_coordinates(schools_sf) all_coords   <- rbind(coords_zones, coords_pts) full_dist    <- as.matrix(dist(all_coords)) dist_matrix  <- full_dist[1:6, 7:16]  rownames(dist_matrix) <- districts_sf$id colnames(dist_matrix) <- schools_sf$id round(dist_matrix, 2) #>      S1   S2   S3   S4   S5   S6   S7   S8   S9  S10 #> D1 0.36 0.32 0.82 1.24 1.70 2.11 0.80 1.30 1.48 2.24 #> D2 1.24 0.71 0.28 0.36 0.70 1.12 1.28 1.14 0.76 1.41 #> D3 2.22 1.70 1.22 0.85 0.30 0.22 2.15 1.70 0.99 1.00 #> D4 1.32 1.14 1.44 1.39 1.97 2.25 0.20 0.71 1.33 2.00 #> D5 1.77 1.30 1.22 0.73 1.22 1.36 1.02 0.32 0.42 1.00 #> D6 2.56 2.02 1.70 1.06 1.04 0.81 2.01 1.30 0.76 0.00 result <- interpolate_election(   tracts_sf     = districts_sf,   electoral_sf  = schools_sf,   zone_id       = \"id\",   point_id      = \"id\",   calib_zones   = c(\"pop_young\", \"pop_old\"),   calib_sources = c(\"enroll_young\", \"enroll_old\"),   interp_sources = \"budget\",   time_matrix   = dist_matrix ) #> although coordinates are longitude/latitude, st_union assumes that they are #> planar #> although coordinates are longitude/latitude, st_union assumes that they are #> planar #> although coordinates are longitude/latitude, st_intersects assumes that they #> are planar #> [1/3] Using pre-computed travel time matrix #> [2/3] Optimizing alpha... #>   CPU optimization: method=auto, parallel=TRUE #> Trying parallel L-BFGS-B optimization... #> Parallel L-BFGS-B failed: length(parallel$forward) == 1 is not TRUE #> Trying serial L-BFGS-B optimization... #>   Converged in 29 steps (0.5s), objective=23,598  Converged in 29 steps (0.5s), objective=23,598 #> [3/3] Interpolating... #>   Interpolated 1 variables into 6 zones  summary(result) #> interpElections result summary #> --------------------------------------------------  #> Zones: 6 | Sources: 10 | Variables: 1 #>  #> Calibration brackets: #>   Zones:   pop_young, pop_old #>   Sources: enroll_young, enroll_old #>  #> Optimization: cpu_lbfgsb | Objective: 23597.7150 | Convergence: 0 #>   Alpha: min=6.976, Q1=8.777, median=9.775, Q3=11.769, max=20.000 #>  #> Interpolated variables: #>   budget                         total=      5070  mean=   845.0  [491.6, 1227.5] #>  #> Object size: 0.0 MB (lightweight) plot(result, \"budget\")"},{"path":"https://antrologos.github.io/interpElections/articles/custom-data.html","id":"supplying-a-pre-computed-distance-matrix","dir":"Articles","previous_headings":"","what":"Supplying a Pre-Computed Distance Matrix","title":"Using interpElections with Your Own Data","text":"time_matrix parameter accepts numeric matrix dimensions n_zones x m_points. Values must positive (represent distances travel times). matrix can come source – Euclidean distances, network distances, travel times Google Maps, custom cost surfaces. Requirements: Rows correspond target zones (order tracts_sf). Columns correspond source points (order electoral_sf). Values must positive numeric (NA, NaN, Inf).","code":"dim(dist_matrix) #> [1]  6 10 head(dist_matrix) #>           S1        S2        S3        S4       S5        S6        S7 #> D1 0.3605604 0.3162298 0.8246227 1.2369301 1.700000 2.1095017 0.7999937 #> D2 1.2369332 0.7071077 0.2828472 0.3605499 0.700000 1.1180329 1.2806209 #> D3 2.2203612 1.7029390 1.2165535 0.8543981 0.300000 0.2236011 2.1540636 #> D4 1.3153134 1.1401938 1.4422363 1.3892540 1.972318 2.2472273 0.2000190 #> D5 1.7691946 1.3038565 1.2165712 0.7280293 1.220671 1.3601582 1.0198076 #> D6 2.5553961 2.0248560 1.6970697 1.0630271 1.044049 0.8062446 2.0099770 #>           S8        S9          S10 #> D1 1.3038351 1.4764793 2.236065e+00 #> D2 1.1401693 0.7615715 1.414209e+00 #> D3 1.7029345 0.9899450 9.999937e-01 #> D4 0.7071041 1.3341707 2.000000e+00 #> D5 0.3162218 0.4242775 1.000000e+00 #> D6 1.3038390 0.7615848 1.899604e-05"},{"path":"https://antrologos.github.io/interpElections/articles/custom-data.html","id":"step-by-step-with-core-functions","dir":"Articles","previous_headings":"","what":"Step-by-Step with Core Functions","title":"Using interpElections with Your Own Data","text":"maximum control, can bypass wrappers call core functions directly. section uses bundled example data.","code":"tt  <- readRDS(system.file(\"extdata/example_tt_matrix.rds\",                             package = \"interpElections\")) pop <- readRDS(system.file(\"extdata/example_pop_matrix.rds\",                             package = \"interpElections\")) src <- readRDS(system.file(\"extdata/example_source_matrix.rds\",                             package = \"interpElections\"))  cat(\"Travel time matrix:\", nrow(tt), \"zones x\", ncol(tt), \"sources\\n\") #> Travel time matrix: 20 zones x 8 sources cat(\"Population matrix: \", nrow(pop), \"zones x\", ncol(pop), \"groups\\n\") #> Population matrix:  20 zones x 3 groups cat(\"Source matrix:     \", nrow(src), \"sources x\", ncol(src), \"groups\\n\") #> Source matrix:      8 sources x 3 groups"},{"path":"https://antrologos.github.io/interpElections/articles/custom-data.html","id":"optimize-alpha","dir":"Articles","previous_headings":"Step-by-Step with Core Functions","what":"Optimize alpha","title":"Using interpElections with Your Own Data","text":"optimize_alpha() finds per-zone decay parameters minimize squared error IDW-interpolated observed population:","code":"optim_result <- optimize_alpha(   time_matrix   = tt,   pop_matrix    = pop,   source_matrix = src,   use_gpu       = FALSE,   verbose       = FALSE )  optim_result #> interpElections optimization result #>   Method:      cpu_lbfgsb #>   Objective:   2150.0468 #>   Convergence: 0 #>   Alpha range: [0.000, 0.072] #>   N zones:     20 #>   Elapsed:     0.4 secs"},{"path":"https://antrologos.github.io/interpElections/articles/custom-data.html","id":"interpolate-new-data","dir":"Articles","previous_headings":"Step-by-Step with Core Functions","what":"Interpolate new data","title":"Using interpElections with Your Own Data","text":"optimal alpha, can interpolate source-level data target zones. alpha vector reusable across variables – need re-optimize one: key property column-standardized IDW weights total conservation: column sums interpolated matrix equal column sums source data. means counts created destroyed interpolation.","code":"# Simulate new data at the 8 source locations (3 variables) set.seed(123) new_data <- matrix(rpois(8 * 3, 200), nrow = 8, ncol = 3) colnames(new_data) <- c(\"var_A\", \"var_B\", \"var_C\")  interpolated <- idw_interpolate(tt, optim_result$alpha, new_data) head(interpolated) #>            var_A    var_B    var_C #> tract_1 80.26303 84.22678 79.37102 #> tract_2 78.54542 82.31001 77.59161 #> tract_3 82.68261 86.76879 81.76064 #> tract_4 88.57890 92.89904 87.53234 #> tract_5 70.48203 73.85247 69.53898 #> tract_6 74.96871 78.58623 74.05313 totals <- rbind(   Source       = colSums(new_data),   Interpolated = colSums(interpolated) ) barplot(   totals,   beside = TRUE,   legend.text = rownames(totals),   args.legend = list(x = \"topright\"),   main = \"Total conservation: source vs. interpolated\",   ylab = \"Total count\",   col = c(\"steelblue\", \"coral\") )"},{"path":"https://antrologos.github.io/interpElections/articles/custom-data.html","id":"computing-travel-times-with-r5r","dir":"Articles","previous_headings":"","what":"Computing Travel Times with r5r","title":"Using interpElections with Your Own Data","text":"real-world applications, travel-time distances produce better results Euclidean distances account road networks, terrain, barriers. package provides helpers r5r-based travel-time computation: Available routing modes: \"WALK\", \"BICYCLE\", \"CAR\". fill_missing parameter controls value assigned unreachable origin-destination pairs (defaults max_trip_duration). download_r5r_data() function downloads OpenStreetMap extract study area clips relevant bounding box. requires Java 21+ osmium-tool command-line utility. Run check_r5r() verify setup.","code":"# Download OSM road network for your study area r5r_data <- download_r5r_data(   area_sf    = my_study_area_sf,   output_dir = \"path/to/output\" )  # Compute travel-time matrix tt_matrix <- compute_travel_times(   zones_sf     = my_zones_sf,   points_sf    = my_points_sf,   network_path = r5r_data$output_dir,   mode         = \"WALK\",   max_trip_duration = 300 )"},{"path":"https://antrologos.github.io/interpElections/articles/introduction.html","id":"what-is-interpelections","dir":"Articles","previous_headings":"","what":"What is interpElections?","title":"Getting Started with interpElections","text":"Many types data collected geographic locations match spatial units want analyze. elections, example, votes tallied polling locations (points), researchers often need estimates level census tracts (polygons). polling location serves voters multiple tracts, tract’s voters may travel different polling locations. relationship many--many, simple lookup table convert two. Standard areal interpolation methods (redistribute polygon data based area overlap) apply source data lives points, polygons. Instead, interpElections uses inverse distance weighting (IDW) approach accounts spatial proximity census tracts polling locations. one sentence: interpElections computes travel-time-based IDW weights per-zone optimized decay parameters, calibrated interpolated values match known demographic totals tract level.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/introduction.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Getting Started with interpElections","text":"interpElections yet CRAN. Install GitHub local copy: core interpolation functions heavy dependencies beyond base R. Optional packages unlock additional capabilities: torch – GPU-accelerated optimization (ADAM optimizer CUDA MPS) r5r + Java (>= 21) – travel time computation via R5 routing engine sf – spatial data handling (required wrapper functions)","code":"# From GitHub remotes::install_github(\"antrologos/interpElections\")  # Or from a local directory devtools::install_local(\"interpElections\")"},{"path":"https://antrologos.github.io/interpElections/articles/introduction.html","id":"quick-example","dir":"Articles","previous_headings":"","what":"Quick Example","title":"Getting Started with interpElections","text":"package ships small example datasets: 20-tract x 8-source travel time matrix, population counts 3 demographic groups 20 tracts, voter counts 3 groups 8 source points. Run optimization find best decay parameter (alpha) tract: result contains optimal alpha vector, final objective value (sum squared errors), metadata convergence.","code":"library(interpElections) #> interpElections: some optional dependencies are missing: #> - No OSM clipping tool found (osmium/osmconvert) #>   Install with: interpElections::setup_osmium() #> These are needed for the full interpolation pipeline.  tt  <- readRDS(system.file(\"extdata/example_tt_matrix.rds\",                             package = \"interpElections\")) pop <- readRDS(system.file(\"extdata/example_pop_matrix.rds\",                             package = \"interpElections\")) src <- readRDS(system.file(\"extdata/example_source_matrix.rds\",                             package = \"interpElections\"))  dim(tt)   # 20 tracts x 8 sources #> [1] 20  8 dim(pop)  # 20 tracts x 3 groups #> [1] 20  3 dim(src)  # 8 sources x 3 groups #> [1] 8 3 result <- optimize_alpha(tt, pop, src, use_gpu = FALSE, verbose = FALSE) print(result) #> interpElections optimization result #>   Method:      cpu_lbfgsb #>   Objective:   2150.0468 #>   Convergence: 0 #>   Alpha range: [0.000, 0.072] #>   N zones:     20 #>   Elapsed:     0.4 secs"},{"path":"https://antrologos.github.io/interpElections/articles/introduction.html","id":"interpolating-variables","dir":"Articles","previous_headings":"","what":"Interpolating Variables","title":"Getting Started with interpElections","text":"alpha values calibrated, can used interpolate variable source points target zones. create synthetic candidate vote matrix interpolate . key property column-standardized IDW total conservation: column sums interpolated matrix equal column sums source matrix. source distributes 100% data across target zones.","code":"# Synthetic vote counts: 8 sources x 2 candidates set.seed(123) candidate_votes <- matrix(   rpois(8 * 2, lambda = 200),   nrow = 8, ncol = 2,   dimnames = list(colnames(tt), c(\"Candidate_A\", \"Candidate_B\")) ) candidate_votes #>        Candidate_A Candidate_B #> poll_1         192         217 #> poll_2         216         205 #> poll_3         176         205 #> poll_4         201         201 #> poll_5         224         192 #> poll_6         206         218 #> poll_7         182         211 #> poll_8         175         199 # Interpolate into 20 tracts interpolated <- idw_interpolate(tt, result$alpha, candidate_votes) head(interpolated) #>         Candidate_A Candidate_B #> tract_1    80.26303    84.22678 #> tract_2    78.54542    82.31001 #> tract_3    82.68261    86.76879 #> tract_4    88.57890    92.89904 #> tract_5    70.48203    73.85247 #> tract_6    74.96871    78.58623 colSums(candidate_votes)  # totals at sources #> Candidate_A Candidate_B  #>        1572        1648 colSums(interpolated)     # totals at tracts (should match) #> Candidate_A Candidate_B  #>        1572        1648"},{"path":"https://antrologos.github.io/interpElections/articles/introduction.html","id":"package-overview","dir":"Articles","previous_headings":"","what":"Package Overview","title":"Getting Started with interpElections","text":"interpElections provides functions three levels abstraction: mathematical details behind IDW interpolation optimization procedure, see vignette(\"understanding--model\").","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/articles/introduction.html","id":"one-call-wrappers","dir":"Articles","previous_headings":"Three Ways to Use the Package","what":"1. One-call wrappers","title":"Getting Started with interpElections","text":"simplest approach. Brazilian elections, interpolate_election_br() handles everything – downloading census data, electoral data, tract geometries, road networks, computing travel times, optimizing alpha, interpolating: non-Brazilian data custom setups, interpolate_election() provides workflow takes user-supplied sf objects:","code":"result <- interpolate_election_br(code_muni = 3550308, year = 2020) result <- interpolate_election(   tracts_sf = my_zones, electoral_sf = my_points,   zone_id = \"id\", point_id = \"id\",   calib_zones = c(\"pop_young\", \"pop_old\"),   calib_sources = c(\"voters_young\", \"voters_old\") )"},{"path":"https://antrologos.github.io/interpElections/articles/introduction.html","id":"step-by-step-pipeline","dir":"Articles","previous_headings":"Three Ways to Use the Package","what":"2. Step-by-step pipeline","title":"Getting Started with interpElections","text":"control, call step individually:","code":"# Prepare inputs pop   <- br_prepare_population(code_muni = 3550308, year = 2022) tract <- br_prepare_tracts(code_muni = 3550308, pop_data = pop) elec  <- br_prepare_electoral(code_muni_ibge = \"3550308\", ...)  # Compute travel times tt <- compute_travel_times(zones_sf = tract, points_sf = elec, ...)  # Optimize and interpolate opt   <- optimize_alpha(tt, pop_matrix, source_matrix) votes <- idw_interpolate(tt, opt$alpha, candidate_matrix)"},{"path":"https://antrologos.github.io/interpElections/articles/introduction.html","id":"core-functions-only","dir":"Articles","previous_headings":"Three Ways to Use the Package","what":"3. Core functions only","title":"Getting Started with interpElections","text":"maximum flexibility integration custom pipelines, use low-level functions directly: level useful want plug IDW engine optimization loop, compare different alpha values, integrate spatial methods.","code":"# Build weights from a travel time matrix and alpha vector W <- idw_weights(tt, alpha)  # Evaluate the objective and gradient at a given alpha f <- idw_objective(alpha, tt, pop, src) g <- idw_gradient(alpha, tt, pop, src)  # Interpolate by matrix multiplication interpolated <- W %*% source_data"},{"path":"https://antrologos.github.io/interpElections/articles/performance-and-configuration.html","id":"gpu-setup","dir":"Articles","previous_headings":"","what":"GPU Setup","title":"Performance Tuning and Configuration","text":"interpElections can accelerate alpha optimization using GPU via torch R package. check_torch() function runs comprehensive diagnostic: system working NVIDIA GPU, output looks like: torch yet installed, setup_torch() handles full installation – R package CRAN platform-appropriate libtorch/lantern binaries GPU support: setup, enable GPU acceleration globally: enable single call:","code":"library(interpElections) check_torch() [ok] torch package installed (v0.13.0) [ok] libtorch + lantern binaries installed [ok] NVIDIA GPU: NVIDIA GeForce RTX 4090 (24576 MB VRAM)      Driver: 555.42.02 | Max CUDA: 12.5 [ok] CUDA runtime 12.1 (1 device)      Compute capability: 8.9 | cuDNN: 9.1.0 [ok] GPU tensor test: passed (cuda)  All checks passed. GPU acceleration is ready.   Device: cuda | Enable with: use_gpu(TRUE) setup_torch()              # auto-detect GPU type setup_torch(type = \"cuda\") # force CUDA binaries use_gpu(enable = TRUE) result <- optimize_alpha(tt, pop, src, use_gpu = TRUE)"},{"path":"https://antrologos.github.io/interpElections/articles/performance-and-configuration.html","id":"gpu-vs-cpu-when-to-use-which","dir":"Articles","previous_headings":"","what":"GPU vs CPU: When to Use Which","title":"Performance Tuning and Configuration","text":"GPU path uses torch ADAM optimizer automatic differentiation, CPU path uses L-BFGS-B (optionally parallelized across cores). best choice depends problem size: GPU requirements: NVIDIA: CUDA-capable GPU recent driver. Compute capability 3.7 higher (Maxwell newer). Works Windows Linux. Apple Silicon: MPS backend macOS M1/M2/M3/M4 chips. Requires torch >= 0.12 macOS 12.3+. GPU: CPU fallback works platform. default use_gpu = FALSE GPU detected.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/articles/performance-and-configuration.html","id":"cpu-optimization","dir":"Articles","previous_headings":"Optimization Parameters","what":"CPU optimization","title":"Performance Tuning and Configuration","text":"Load bundled example data run optimizer default settings: Inspect convergence information: CPU cascade. cpu_method = \"auto\" (default), optimizer tries methods order: Parallel L-BFGS-B via optimParallel – uses multiple CPU cores. Requires optimParallel parallel packages. Serial L-BFGS-B – standard optim() box constraints. BFGS – unconstrained fallback (bounds enforced via clamping). method tried previous one fails. problems converge first attempt.","code":"library(interpElections) #> interpElections: some optional dependencies are missing: #> - No OSM clipping tool found (osmium/osmconvert) #>   Install with: interpElections::setup_osmium() #> These are needed for the full interpolation pipeline.  tt  <- readRDS(system.file(\"extdata/example_tt_matrix.rds\",                             package = \"interpElections\")) pop <- readRDS(system.file(\"extdata/example_pop_matrix.rds\",                             package = \"interpElections\")) src <- readRDS(system.file(\"extdata/example_source_matrix.rds\",                             package = \"interpElections\"))  result_default <- optimize_alpha(tt, pop, src,                                   use_gpu = FALSE, verbose = FALSE) result_default$method #> [1] \"cpu_lbfgsb\" result_default$convergence   # 0 = success #> [1] 0 result_default$message #> [1] \"CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH\" result_default$iterations #> function gradient  #>       58       58 cat(\"Elapsed:\", format(result_default$elapsed), \"\\n\") #> Elapsed: 0.4164841 secs cat(\"Objective:\", round(result_default$value, 2), \"\\n\") #> Objective: 2150.05"},{"path":"https://antrologos.github.io/interpElections/articles/performance-and-configuration.html","id":"effect-of-bounds","dir":"Articles","previous_headings":"Optimization Parameters","what":"Effect of bounds","title":"Performance Tuning and Configuration","text":"default, alpha values bounded 0 20. Narrowing bounds can speed convergence prevent extreme values:  Narrow bounds constrain alpha distribution may increase objective value (worse fit). Use narrow bounds prior knowledge expected decay behavior, want prevent extreme solutions.","code":"result_narrow <- optimize_alpha(tt, pop, src,                                  use_gpu = FALSE,                                  lower_bound = 0.5,                                  upper_bound = 5,                                  verbose = FALSE)  cat(\"Default bounds [0, 20] -- objective:\", round(result_default$value, 2), \"\\n\") #> Default bounds [0, 20] -- objective: 2150.05 cat(\"Narrow bounds [0.5, 5] -- objective:\", round(result_narrow$value, 2), \"\\n\") #> Narrow bounds [0.5, 5] -- objective: 2312.95 par(mfrow = c(1, 2), mar = c(4, 4, 3, 1))  hist(result_default$alpha, breaks = 10, col = \"#4E79A7\", border = \"white\",      main = \"Default bounds [0, 20]\",      xlab = \"Alpha\", ylab = \"Frequency\",      xlim = range(c(result_default$alpha, result_narrow$alpha)))  hist(result_narrow$alpha, breaks = 10, col = \"#E15759\", border = \"white\",      main = \"Narrow bounds [0.5, 5]\",      xlab = \"Alpha\", ylab = \"Frequency\",      xlim = range(c(result_default$alpha, result_narrow$alpha)))"},{"path":"https://antrologos.github.io/interpElections/articles/performance-and-configuration.html","id":"gpu-parameters","dir":"Articles","previous_headings":"Optimization Parameters","what":"GPU parameters","title":"Performance Tuning and Configuration","text":"use_gpu = TRUE, optimizer uses torch ADAM algorithm learning rate schedule. key parameters : gpu_iterations: “phase” runs full ADAM optimization pass. learning rate reduced gpu_lr_decay phase. phases allow finer convergence. Default: 20. gpu_lr_init: Starting learning rate. Larger values explore faster risk overshooting. Default: 0.1. gpu_lr_decay: Multiplicative decay applied phase. value 0.6 means learning rate phase k gpu_lr_init * 0.6^k. Default: 0.6.","code":"result <- optimize_alpha(   tt, pop, src,   use_gpu        = TRUE,   device         = \"cuda\",     # or \"mps\" for Apple Silicon   dtype          = \"float32\",  # or \"float64\" for higher precision   gpu_iterations = 20,         # number of ADAM phases (outer iterations)   gpu_lr_init    = 0.1,        # initial learning rate   gpu_lr_decay   = 0.6         # decay factor per phase )"},{"path":"https://antrologos.github.io/interpElections/articles/performance-and-configuration.html","id":"float32-vs-float64","dir":"Articles","previous_headings":"","what":"float32 vs float64","title":"Performance Tuning and Configuration","text":"dtype parameter controls numerical precision GPU: default float32, provides sufficient precision municipal-scale problems using less GPU memory. Switch float64 need maximum accuracy, keep float32 VRAM tight need maximum throughput: CPU optimizer always uses float64 (R’s native double precision).","code":"# Global setting for higher precision use_gpu(enable = TRUE, dtype = \"float64\")  # Or per-call result <- optimize_alpha(tt, pop, src, use_gpu = TRUE, dtype = \"float64\")"},{"path":"https://antrologos.github.io/interpElections/articles/performance-and-configuration.html","id":"java-and-r5r-setup","dir":"Articles","previous_headings":"","what":"Java and r5r Setup","title":"Performance Tuning and Configuration","text":"Travel time computation requires r5r package Java Development Kit (JDK) version 21 higher.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/performance-and-configuration.html","id":"diagnostics","dir":"Articles","previous_headings":"Java and r5r Setup","what":"Diagnostics","title":"Performance Tuning and Configuration","text":"Sample output correctly configured system:","code":"check_r5r() [ok] r5r package installed (v2.1) [ok] Java 21 found [ok] Java max heap: 4g      System RAM: 16 GB  All checks passed. r5r is ready to use."},{"path":"https://antrologos.github.io/interpElections/articles/performance-and-configuration.html","id":"installing-java","dir":"Articles","previous_headings":"Java and r5r Setup","what":"Installing Java","title":"Performance Tuning and Configuration","text":"Java missing wrong version, setup_java() downloads configures Adoptium Temurin JDK 21 automatically: downloads JDK platform, extracts local directory, sets JAVA_HOME, optionally persists setting ~/.Renviron.","code":"setup_java()"},{"path":"https://antrologos.github.io/interpElections/articles/performance-and-configuration.html","id":"osm-clipping-tool","dir":"Articles","previous_headings":"Java and r5r Setup","what":"OSM clipping tool","title":"Performance Tuning and Configuration","text":"travel time pipeline clips OpenStreetMap data study area building routing network. requires osmium-tool: searches osmium system , found, downloads platform-appropriate binary.","code":"setup_osmium()"},{"path":"https://antrologos.github.io/interpElections/articles/performance-and-configuration.html","id":"memory-configuration","dir":"Articles","previous_headings":"Java and r5r Setup","what":"Memory configuration","title":"Performance Tuning and Configuration","text":"Large travel time matrices (e.g., 10,000+ zones 500+ sources) can require several gigabytes JVM heap. Configure loading r5r: set_java_memory() function must called r5r (rJava) loaded R session. JVM starts, heap size changed without restarting R.","code":"# Set JVM heap to 8 GB set_java_memory(\"8g\")  # Rule of thumb: >= 2 GB per million origin-destination pairs # 5,000 tracts x 200 sources = 1M pairs -> 2-4 GB # 20,000 tracts x 500 sources = 10M pairs -> 8-16 GB"},{"path":"https://antrologos.github.io/interpElections/articles/performance-and-configuration.html","id":"cache-management","dir":"Articles","previous_headings":"","what":"Cache Management","title":"Performance Tuning and Configuration","text":"interpElections caches downloaded files computed artifacts (travel time matrices, processed electoral data, etc.) avoid re-downloading re-computing across sessions.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/performance-and-configuration.html","id":"viewing-the-cache-directory","dir":"Articles","previous_headings":"Cache Management","what":"Viewing the cache directory","title":"Performance Tuning and Configuration","text":"","code":"cache_dir <- get_interpElections_cache_dir() cache_dir #> [1] \"/home/runner/.cache/R/interpElections\""},{"path":"https://antrologos.github.io/interpElections/articles/performance-and-configuration.html","id":"changing-the-cache-directory","dir":"Articles","previous_headings":"Cache Management","what":"Changing the cache directory","title":"Performance Tuning and Configuration","text":"can point cache different location. demonstrate temporary directory: reset OS default location:","code":"old_cache <- get_interpElections_cache_dir() set_interpElections_cache_dir(tempdir(), verbose = FALSE) get_interpElections_cache_dir()   # now points to temp #> [1] \"/tmp/RtmpDSIjRO\"  # Restore the original set_interpElections_cache_dir(old_cache, verbose = FALSE) set_interpElections_cache_dir(NULL)"},{"path":"https://antrologos.github.io/interpElections/articles/performance-and-configuration.html","id":"listing-cached-files","dir":"Articles","previous_headings":"Cache Management","what":"Listing cached files","title":"Performance Tuning and Configuration","text":"","code":"# Per-category summary interpElections_cache()  # Detailed listing with individual files interpElections_cache(details = TRUE)"},{"path":"https://antrologos.github.io/interpElections/articles/performance-and-configuration.html","id":"cleaning-the-cache","dir":"Articles","previous_headings":"Cache Management","what":"Cleaning the cache","title":"Performance Tuning and Configuration","text":"Remove specific categories entire cache: Available categories:","code":"# Clear only travel time matrices (forces re-computation next run) interpElections_cache_clean(\"travel_times\")  # Clear all raw downloads interpElections_cache_clean(\"downloads\")  # Clear everything interpElections_cache_clean(\"all\")"},{"path":"https://antrologos.github.io/interpElections/articles/performance-and-configuration.html","id":"the-cache-and-force-parameters","dir":"Articles","previous_headings":"Cache Management","what":"The cache and force parameters","title":"Performance Tuning and Configuration","text":"download functions (e.g., br_download_votes(), br_download_turnout()) accept two caching parameters: cache = TRUE (default): Store downloaded files persistent cache. Subsequent calls reuse cached file instead re-downloading. force = TRUE: Re-download even cached copy exists. Useful suspect corrupted download upstream data updated.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/articles/performance-and-configuration.html","id":"cuda-not-found","dir":"Articles","previous_headings":"Troubleshooting","what":"CUDA not found","title":"Performance Tuning and Configuration","text":"check_torch() reports CUDA available despite NVIDIA GPU: Verify GPU driver installed: run nvidia-smi terminal. Reinstall torch binaries CUDA support: Restart R reinstalling – torch binaries loaded namespace load time.","code":"setup_torch(reinstall = TRUE)"},{"path":"https://antrologos.github.io/interpElections/articles/performance-and-configuration.html","id":"torch-binary-mismatch","dir":"Articles","previous_headings":"Troubleshooting","what":"torch binary mismatch","title":"Performance Tuning and Configuration","text":"torch installed CPU-binaries (e.g., CUDA detected install time), GPU tensor creation fail. Fix reinstalling:","code":"setup_torch(reinstall = TRUE) # Then restart R"},{"path":"https://antrologos.github.io/interpElections/articles/performance-and-configuration.html","id":"java-version-mismatch","dir":"Articles","previous_headings":"Troubleshooting","what":"Java version mismatch","title":"Performance Tuning and Configuration","text":"r5r requires Java 21+. check_r5r() reports older version:","code":"setup_java()   # downloads and configures JDK 21"},{"path":"https://antrologos.github.io/interpElections/articles/performance-and-configuration.html","id":"r5r-memory-errors","dir":"Articles","previous_headings":"Troubleshooting","what":"r5r memory errors","title":"Performance Tuning and Configuration","text":"r5r crashes OutOfMemoryError: Increase JVM heap loading r5r: Restart R (JVM reconfigured started). problem persists, try larger value (e.g., \"16g\"), keeping mind system’s total RAM.","code":"set_java_memory(\"8g\")"},{"path":"https://antrologos.github.io/interpElections/articles/performance-and-configuration.html","id":"slow-cpu-optimization","dir":"Articles","previous_headings":"Troubleshooting","what":"Slow CPU optimization","title":"Performance Tuning and Configuration","text":"CPU optimization slow large municipality: Ensure optimParallel installed parallel L-BFGS-B: Consider narrowing bounds speed convergence: municipalities ~1,000 zones, GPU acceleration typically provides significant speedup. See GPU Setup section .","code":"install.packages(\"optimParallel\") optimize_alpha(tt, pop, src, lower_bound = 0.1, upper_bound = 10)"},{"path":"https://antrologos.github.io/interpElections/articles/understanding-the-model.html","id":"the-problem","dir":"Articles","previous_headings":"","what":"The Problem","title":"Understanding the IDW Interpolation Model","text":"Consider city census tracts (target zones) polling locations (source points). polling location, know many votes candidate received. census tract, know population broken demographic group (age brackets, instance). know votes polling location split across surrounding census tracts. mapping tracts polling locations many--many: single polling location can serve voters dozens tracts, voters given tract may assigned different polling locations. goal estimate, tract, number votes received candidate – words, disaggregate polling location data census tract geography.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/understanding-the-model.html","id":"inverse-distance-weighting","dir":"Articles","previous_headings":"","what":"Inverse Distance Weighting","title":"Understanding the IDW Interpolation Model","text":"core idea simple: closer tracts receive larger share polling location’s votes. measure “closeness” travel time (Euclidean distance), better captures real-world accessibility polling locations via road network. pair tract ii source point jj, raw weight : Wij=(tij+1)−αi W_{ij} = (t_{ij} + 1)^{-\\alpha_i} tijt_{ij} travel time minutes αi≥0\\alpha_i \\geq 0 decay parameter specific zone ii. “+1” offset prevents division zero polling location falls inside tract (t=0t = 0). formulation three features distinguish standard IDW: Travel time, Euclidean distance. Road networks, rivers, topography create asymmetries straight-line distance ignores. One alpha per zone. tract gets decay parameter, reflecting local spatial structure. tract dense urban core may need different alpha one rural fringe. Column standardization (discussed next).","code":""},{"path":"https://antrologos.github.io/interpElections/articles/understanding-the-model.html","id":"what-column-standardization-does","dir":"Articles","previous_headings":"","what":"What Column Standardization Does","title":"Understanding the IDW Interpolation Model","text":"computing raw weights, column WW divided column sum: Wijstd=Wij∑′Wi′j W^{std}_{ij} = \\frac{W_{ij}}{\\sum_{'} W_{'j}} ensures source point distributes exactly 100% data across target zones. Let us verify example data: Every column sums 1. total conservation property: polling location recorded 500 votes, exactly 500 votes distributed across tracts – votes created lost. Note contrast row standardization (row sums 1). Row standardization answers different question: “fraction tract ii’s population comes source?” Column standardization answers: “fraction source jj’s data goes tract?” disaggregation, column standardization correct choice splitting source totals target zones.","code":"W <- idw_weights(tt, alpha = rep(1, 20)) colSums(W) #> poll_1 poll_2 poll_3 poll_4 poll_5 poll_6 poll_7 poll_8  #>      1      1      1      1      1      1      1      1"},{"path":"https://antrologos.github.io/interpElections/articles/understanding-the-model.html","id":"the-effect-of-alpha","dir":"Articles","previous_headings":"","what":"The Effect of Alpha","title":"Understanding the IDW Interpolation Model","text":"decay parameter α\\alpha controls sharply weights fall distance. α=0\\alpha = 0, sources receive equal weight regardless distance. α\\alpha increases, nearest source dominates distant sources -weighted. Let us examine tract 1’s weights across 8 sources different alpha values:  α=0\\alpha = 0 (green), every source gets weight – interpolation ignores spatial proximity entirely. α=5\\alpha = 5 (rightmost bars), almost weight concentrates nearest source. Intermediate values produce smooth gradient near far. “right” alpha depends local geography. dense neighborhood nearest polling location close, high alpha correctly assigns weight location. sparse area multiple locations roughly equidistant, lower alpha shares weight evenly.","code":"alpha_values <- c(0, 0.5, 1, 2, 5) n <- nrow(tt)  results <- lapply(alpha_values, function(a) {   W <- idw_weights(tt, alpha = rep(a, n))   W[1, ]  # weights for tract 1 }) names(results) <- paste0(\"alpha_\", alpha_values)  # Display as a matrix: rows = sources, columns = alpha values weight_table <- do.call(cbind, results) rownames(weight_table) <- colnames(tt) round(weight_table, 4) #>        alpha_0 alpha_0.5 alpha_1 alpha_2 alpha_5 #> poll_1    0.05    0.0370  0.0247  0.0077  0.0000 #> poll_2    0.05    0.0282  0.0101  0.0005  0.0000 #> poll_3    0.05    0.0480  0.0365  0.0104  0.0000 #> poll_4    0.05    0.0289  0.0114  0.0008  0.0000 #> poll_5    0.05    0.0350  0.0175  0.0015  0.0000 #> poll_6    0.05    0.0343  0.0143  0.0008  0.0000 #> poll_7    0.05    0.0608  0.0682  0.0612  0.0060 #> poll_8    0.05    0.0673  0.0745  0.0533  0.0029 # Travel times from tract 1 to all sources tt_row1 <- tt[1, ] source_order <- order(tt_row1)  colors <- c(\"#1b9e77\", \"#d95f02\", \"#7570b3\", \"#e7298a\", \"#66a61e\") par(mar = c(5, 4, 3, 1))  # Use grouped bar plot bar_data <- weight_table[source_order, ] barplot(   t(bar_data),   beside = TRUE,   col = colors,   names.arg = rownames(bar_data),   las = 2,   ylab = \"Weight (column-standardized)\",   main = \"Tract 1: weight distribution across sources at different alpha\",   cex.names = 0.8 ) legend(\"topright\",        legend = paste0(\"alpha = \", alpha_values),        fill = colors,        cex = 0.8,        bty = \"n\")"},{"path":"https://antrologos.github.io/interpElections/articles/understanding-the-model.html","id":"calibration-finding-optimal-alpha","dir":"Articles","previous_headings":"","what":"Calibration: Finding Optimal Alpha","title":"Understanding the IDW Interpolation Model","text":"choose right alpha tract? exploit fact variables known source target level. Specifically: polling location, know number registered voters age bracket (TSE voter rolls). census tract, know population age bracket (census). weights correct, interpolated voter counts match census population counts. gives us objective function minimize: f(α)=∑=1n∑k=1K(V̂ik−Pik)2 f(\\alpha) = \\sum_{=1}^{n} \\sum_{k=1}^{K}   \\left( \\hat{V}_{ik} - P_{ik} \\right)^2 V̂=Wstd(α)×V\\hat{V} = W^{std}(\\alpha) \\times V matrix interpolated values, VV source matrix (voters age polling location), PP population matrix (residents age tract). sum runs nn tracts KK demographic groups. Let us see action example data: demographic groups act bridge two geographies. minimizing mismatch demographics (observed levels), calibrate weights can used interpolate variables observed one level (candidate votes). optimized alpha values vary across tracts, reflecting differences local spatial structure tract--polling-location relationships.","code":"# Objective at a uniform alpha = 1 (before optimization) obj_before <- idw_objective(rep(1, 20), tt + 1, pop, src) cat(\"Objective at alpha = 1 (all zones):\", format(round(obj_before), big.mark = \",\"), \"\\n\") #> Objective at alpha = 1 (all zones): 53,434  # Optimize result <- optimize_alpha(tt, pop, src, use_gpu = FALSE, verbose = FALSE)  # Objective after optimization obj_after <- idw_objective(result$alpha, tt + 1, pop, src) cat(\"Objective at optimal alpha:         \", format(round(obj_after), big.mark = \",\"), \"\\n\") #> Objective at optimal alpha:          2,150 cat(\"Reduction:                          \",     sprintf(\"%.1f%%\", 100 * (1 - obj_after / obj_before)), \"\\n\") #> Reduction:                           96.0% summary(result$alpha) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #> 0.00000 0.01961 0.03029 0.03119 0.04147 0.07190"},{"path":"https://antrologos.github.io/interpElections/articles/understanding-the-model.html","id":"the-analytical-gradient","dir":"Articles","previous_headings":"","what":"The Analytical Gradient","title":"Understanding the IDW Interpolation Model","text":"optimization uses L-BFGS-B (quasi-Newton method supports box constraints), requires gradient ∇f(α)\\nabla f(\\alpha). Computing numerically via finite differences require n+1n + 1 evaluations objective per iteration. city 5,000 census tracts, means 5,001 matrix operations per step. interpElections provides analytical gradient computes nn partial derivatives single pass chain rule. makes iteration O(1)O(1) function evaluations instead O(n)O(n), critical scaling large municipalities. can verify correctness comparing analytical gradient numerical approximation. Using small subset (first 5 zones) keep output readable: differences machine precision level (around 10−810^{-8} smaller), confirming analytical gradient correct.","code":"# Use a subset: first 5 zones tt_sub  <- (tt + 1)[1:5, ] pop_sub <- pop[1:5, , drop = FALSE] alpha_sub <- pmax(result$alpha[1:5], 0)  # ensure non-negative  # Analytical gradient grad_analytical <- idw_gradient(alpha_sub, tt_sub, pop_sub, src)  # Numerical gradient (finite differences) # Clamp alpha to non-negative (numDeriv probes at alpha +/- eps) grad_numerical <- numDeriv::grad(   func = function(a) idw_objective(pmax(a, 0), tt_sub, pop_sub, src),   x = alpha_sub )  # Compare comparison <- data.frame(   zone = paste0(\"tract_\", 1:5),   analytical = round(grad_analytical, 6),   numerical  = round(grad_numerical, 6),   abs_diff   = format(abs(grad_analytical - grad_numerical),                       scientific = TRUE, digits = 3) ) comparison #>      zone analytical  numerical abs_diff #> 1 tract_1   2197.522   2197.522 8.52e-05 #> 2 tract_2  17053.418  17053.418 6.84e-05 #> 3 tract_3 -19866.714 -19866.714 2.23e-04 #> 4 tract_4 -90542.702 -45262.292 4.53e+04 #> 5 tract_5  86660.271  86660.271 7.27e-08"},{"path":"https://antrologos.github.io/interpElections/articles/understanding-the-model.html","id":"from-calibration-to-interpolation","dir":"Articles","previous_headings":"","what":"From Calibration to Interpolation","title":"Understanding the IDW Interpolation Model","text":"key insight weight matrix Wstd(α)W^{std}(\\alpha) property spatial relationship tracts polling locations, particular variable interpolated. found optimal alpha calibrating demographics, weights can applied interpolate variable recorded polling locations: Candidate vote counts Party vote totals Turnout abstention Voter demographics (gender, education) Blank null votes analogous fitting regression model training data using make predictions. demographic groups “training data” let us learn spatial weights, candidate votes (variable) “prediction targets.” interpolated tract-level totals match source-level totals exactly (floating point precision), regardless variable interpolated. guaranteed column standardization weight matrix.","code":"# Same alpha, different source data set.seed(42) party_votes <- matrix(   rpois(8 * 3, lambda = 150),   nrow = 8, ncol = 3,   dimnames = list(colnames(tt), c(\"Party_A\", \"Party_B\", \"Party_C\")) )  interpolated <- idw_interpolate(tt, result$alpha, party_votes)  # Total conservation holds for any variable cat(\"Source totals: \", paste(colSums(party_votes), collapse = \", \"), \"\\n\") #> Source totals:  1233, 1266, 1243 cat(\"Tract totals:  \",     paste(round(colSums(interpolated), 1), collapse = \", \"), \"\\n\") #> Tract totals:   1233, 1266, 1243"},{"path":"https://antrologos.github.io/interpElections/articles/working-with-results.html","id":"setup-and-creating-a-result-object","dir":"Articles","previous_headings":"","what":"Setup and Creating a Result Object","title":"Exploring, Validating, and Aggregating Results","text":"start loading bundled example data running optimization. Since bundled data include sf geometry, construct minimal set square polygons S3 methods (including plot() residuals()) work correctly. Now build mock sf object 20 square polygons arranged 4-column 5-row grid, assemble result: real workflow construct object manually – interpolate_election() interpolate_election_br() builds . every S3 method can demonstrated eval = TRUE.","code":"library(interpElections) #> interpElections: some optional dependencies are missing: #> - No OSM clipping tool found (osmium/osmconvert) #>   Install with: interpElections::setup_osmium() #> These are needed for the full interpolation pipeline.  # Load bundled example data tt  <- readRDS(system.file(\"extdata/example_tt_matrix.rds\",                             package = \"interpElections\")) pop <- readRDS(system.file(\"extdata/example_pop_matrix.rds\",                             package = \"interpElections\")) src <- readRDS(system.file(\"extdata/example_source_matrix.rds\",                             package = \"interpElections\"))  # Optimize alpha on CPU opt <- optimize_alpha(tt, pop, src, use_gpu = FALSE, verbose = FALSE)  # Compute the column-standardized weight matrix W <- idw_weights(tt, opt$alpha)  # Interpolate the calibration variables (to verify residuals later) fitted_calib <- W %*% src  # Also interpolate some synthetic \"election\" variables set.seed(42) election_data <- matrix(   rpois(ncol(tt) * 2, lambda = 150),   nrow = ncol(tt), ncol = 2,   dimnames = list(NULL, c(\"Candidate_A\", \"Candidate_B\")) ) fitted_election <- W %*% election_data library(sf) #> Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE  # Create a 4x5 grid of unit squares polys <- vector(\"list\", 20) for (i in seq_len(20)) {    row_i <- (i - 1) %/% 4   col_i <- (i - 1) %% 4   x0 <- col_i   y0 <- row_i   polys[[i]] <- st_polygon(list(matrix(     c(x0, y0, x0+1, y0, x0+1, y0+1, x0, y0+1, x0, y0),     ncol = 2, byrow = TRUE   ))) }  tracts_sf <- st_sf(   id = paste0(\"tract_\", sprintf(\"%02d\", 1:20)),   pop_18_34 = pop[, \"pop_18_34\"],   pop_35_54 = pop[, \"pop_35_54\"],   pop_55_69 = pop[, \"pop_55_69\"],   Candidate_A = fitted_election[, \"Candidate_A\"],   Candidate_B = fitted_election[, \"Candidate_B\"],   geometry = st_sfc(polys) )  # Build the sources data frame (no geometry needed) sources_df <- data.frame(   id = paste0(\"src_\", 1:ncol(tt)),   vot_18_34 = src[, \"vot_18_34\"],   vot_35_54 = src[, \"vot_35_54\"],   vot_55_69 = src[, \"vot_55_69\"] )  # Assemble the interpElections_result object result <- structure(list(   interpolated = cbind(fitted_calib, fitted_election),   alpha        = opt$alpha,   tracts_sf    = tracts_sf,   sources      = sources_df,   optimization = list(     value       = opt$value,     method      = opt$method,     convergence = opt$convergence,     iterations  = opt$iterations,     elapsed     = opt$elapsed,     message     = opt$message   ),   offset       = 1,   call         = NULL,   zone_id      = \"id\",   point_id     = \"id\",   interp_cols  = c(\"Candidate_A\", \"Candidate_B\"),   calib_cols   = list(     zones   = c(\"pop_18_34\", \"pop_35_54\", \"pop_55_69\"),     sources = c(\"vot_18_34\", \"vot_35_54\", \"vot_55_69\")   ),   weights      = W,   time_matrix  = tt,   sources_sf   = NULL,   code_muni    = NULL,   year         = NULL,   census_year  = NULL,   what         = NULL,   pop_data     = NULL ), class = \"interpElections_result\")"},{"path":"https://antrologos.github.io/interpElections/articles/working-with-results.html","id":"print-and-summary","dir":"Articles","previous_headings":"","what":"Print and Summary","title":"Exploring, Validating, and Aggregating Results","text":"print() method gives compact overview: Key fields: Zones / Sources / Variables – dimensions interpolation. Optimizer – method converged final objective value (sum squared errors fitted observed calibration populations). Alpha – range mean decay parameters. Kept – heavy intermediate objects (weights, time_matrix, sources_sf) stored result. summary() method provides detail: per-variable section shows totals, means, ranges interpolated column. totals match column sums source data interpolation conserves mass (column-standardized IDW guarantees).","code":"print(result) #> interpElections result #>   Zones:     20 #>   Sources:   8 #>   Variables: 5  (Candidate_A, Candidate_B) #>   Optimizer: cpu_lbfgsb (obj = 2150.05) #>   Alpha:     [0.000, 0.072] (mean 0.031) #>   Kept:      weights, time_matrix #>  #>   Access interpolated sf:    result$tracts_sf #>   Access alpha vector:       result$alpha #>   Detailed summary:          summary(result) #>   Plot a variable:           plot(result, \"Candidate_A\") summary(result) #> interpElections result summary #> --------------------------------------------------  #> Zones: 20 | Sources: 8 | Variables: 5 #>  #> Calibration brackets: #>   Zones:   pop_18_34, pop_35_54, pop_55_69 #>   Sources: vot_18_34, vot_35_54, vot_55_69 #>  #> Optimization: cpu_lbfgsb | Objective: 2150.0468 | Convergence: 0 #>   Alpha: min=0.000, Q1=0.020, median=0.030, Q3=0.041, max=0.072 #>  #> Interpolated variables: #>   vot_18_34                      total=       972  mean=    48.6  [42.7, 54.8] #>   vot_35_54                      total=      1032  mean=    51.6  [45.2, 58.2] #>   vot_55_69                      total=      1043  mean=    52.2  [45.6, 58.8] #>   Candidate_A                    total=      1233  mean=    61.6  [53.8, 69.5] #>   Candidate_B                    total=      1266  mean=    63.3  [55.5, 71.4] #>  #> Object size: 0.0 MB"},{"path":"https://antrologos.github.io/interpElections/articles/working-with-results.html","id":"mapping-results","dir":"Articles","previous_headings":"","what":"Mapping Results","title":"Exploring, Validating, and Aggregating Results","text":"plot() method produces choropleth map interpolated variable. default plots first variable interp_cols.  can also plot underlying sf object directly control:","code":"plot(result, \"Candidate_A\") par(mfrow = c(1, 2), mar = c(1, 1, 2, 1)) plot(result$tracts_sf[\"Candidate_A\"], main = \"Candidate A\", key.pos = NULL) plot(result$tracts_sf[\"Candidate_B\"], main = \"Candidate B\", key.pos = NULL)"},{"path":"https://antrologos.github.io/interpElections/articles/working-with-results.html","id":"extracting-alpha","dir":"Articles","previous_headings":"","what":"Extracting Alpha","title":"Exploring, Validating, and Aggregating Results","text":"coef() method extracts optimized alpha vector: Interpretation alpha values: High alpha (e.g., > 5): Weights drop steeply distance. zone’s population almost entirely allocated nearest source. occurs areas closest polling location dominates. Low alpha (e.g., < 1): Weights decay slowly. Many sources contribute zone. occurs densely served areas several polling locations nearby. Alpha near 0: sources weighted nearly equally, regardless distance – uniform allocation.","code":"alpha <- coef(result) length(alpha)  # one per zone #> [1] 20 summary(alpha) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #> 0.00000 0.01961 0.03029 0.03119 0.04147 0.07190 quantile(alpha, c(0.10, 0.25, 0.50, 0.75, 0.90)) #>         10%         25%         50%         75%         90%  #> 0.007605966 0.019611093 0.030294048 0.041472854 0.055123175 hist(alpha, breaks = 10, col = \"steelblue\", border = \"white\",      main = \"Distribution of Alpha Values\",      xlab = \"Alpha (decay parameter)\", ylab = \"Frequency\") abline(v = median(alpha), lty = 2, col = \"red\", lwd = 2) legend(\"topright\", legend = paste(\"Median =\", round(median(alpha), 2)),        lty = 2, col = \"red\", lwd = 2, bty = \"n\")"},{"path":"https://antrologos.github.io/interpElections/articles/working-with-results.html","id":"residual-analysis","dir":"Articles","previous_headings":"","what":"Residual Analysis","title":"Exploring, Validating, and Aggregating Results","text":"residuals() method computes fitted - observed calibration groups. requires either weight matrix time matrix stored result (use keep = \"weights\" keep = \"time_matrix\" running interpolation). Summary statistics group:  residuals large, possible causes include: Spatial mismatch: travel time data may accurately capture voters actually reach polling locations (e.g., missing roads, different transport modes). Boundary effects: zones edge study area may sources outside travel time matrix. Population data quality: mismatched census years, undercounting, different age-group definitions census electoral data. Model limitations: IDW assumes monotonically decreasing relationship travel time voter assignment, may hold settings.","code":"resid <- residuals(result) dim(resid)     # 20 zones x 3 calibration groups #> [1] 20  3 head(resid) #>          pop_18_34  pop_35_54 pop_55_69 #> tract_1 -10.338845  3.7531286 12.338685 #> tract_2  -2.495407  6.5548333  2.168459 #> tract_3   1.215111  7.3567462 -2.068950 #> tract_4   5.782625  2.1773158 -1.217903 #> tract_5   2.575902 -0.7630854  4.704011 #> tract_6  -1.655117  0.1948060  7.678377 # Mean residual per group (should be close to zero in aggregate) colMeans(resid) #> pop_18_34 pop_35_54 pop_55_69  #>     -1.15      3.70      3.75  # Root mean squared error per group sqrt(colMeans(resid^2)) #> pop_18_34 pop_35_54 pop_55_69  #>  5.620623  5.691859  6.596490 boxplot(as.data.frame(resid),         col = c(\"#4E79A7\", \"#F28E2B\", \"#59A14F\"),         main = \"Residuals by Calibration Group\",         ylab = \"Fitted - Observed\",         las = 1) abline(h = 0, lty = 2, col = \"gray40\")"},{"path":"https://antrologos.github.io/interpElections/articles/working-with-results.html","id":"exporting-results","dir":"Articles","previous_headings":"","what":"Exporting Results","title":"Exploring, Validating, and Aggregating Results","text":"Convert result plain data frame (drops geometry) export: Write CSV: export spatial data GeoPackage shapefile:","code":"df <- as.data.frame(result) head(df) #>         id pop_18_34 pop_35_54 pop_55_69 Candidate_A Candidate_B #> 1 tract_01        60        49        41    63.05732    64.71605 #> 2 tract_02        51        45        50    61.65512    63.30989 #> 3 tract_03        50        47        57    64.93728    66.68439 #> 4 tract_04        49        56        60    69.50964    71.35509 #> 5 tract_05        41        47        42    55.20544    56.79123 #> 6 tract_06        48        49        42    58.74676    60.30082 write.csv(df, \"interpolated_results.csv\", row.names = FALSE) sf::st_write(result$tracts_sf, \"interpolated_tracts.gpkg\", quiet = TRUE)"},{"path":"https://antrologos.github.io/interpElections/articles/working-with-results.html","id":"validation-checklist","dir":"Articles","previous_headings":"","what":"Validation Checklist","title":"Exploring, Validating, and Aggregating Results","text":"using interpolated results downstream analysis, check: Total conservation. Column sums interpolated matrix equal column sums source data. guaranteed column-standardized weight matrix, rounding filtering can introduce small discrepancies. Residual magnitude. Compare root mean squared error typical population values. Residuals 5-10% mean population per group common; larger values warrant investigation. Alpha distribution. Look extreme outliers. Alphas upper bound (default 20) suggest zone effectively assigned single source – check whether makes geographic sense. Alphas 0 suggest optimizer distinguish nearby sources. negative values. non-negative source data non-negative weights, interpolated values never negative. see negative values, check data issues. Convergence. optimization report convergence = 0. Non-zero values may indicate optimizer hit iteration limit encountered numerical issues.","code":""},{"path":"https://antrologos.github.io/interpElections/articles/working-with-results.html","id":"secondary-aggregation-with-areal-weights","dir":"Articles","previous_headings":"","what":"Secondary Aggregation with Areal Weights","title":"Exploring, Validating, and Aggregating Results","text":"interpolating electoral data census tracts, may want aggregate results larger zones neighborhoods, districts, custom analysis regions. areal_weights() areal_interpolate() functions handle using area-weighted intersection. First, build two overlapping polygon layers: 20 “tracts” (small squares 4x5 grid) 5 “neighborhoods” (larger rectangles, covering one row grid). Compute areal weight matrix. entry represents fraction source tract’s area falls within target neighborhood: Apply weights aggregate interpolated election data: Total conservation check: neighborhood totals equal tract totals:  left panel shows fine-grained tract-level interpolation; right panel shows data aggregated five neighborhoods. secondary aggregation useful final analysis unit differs census tracts – example, combining election results socioeconomic data available neighborhood district level.","code":"# Tracts: reuse the sf object from Section 5.1 tracts <- tracts_sf  # Neighborhoods: 5 rectangles, each 4 units wide x 1 unit tall nbhd_polys <- vector(\"list\", 5) for (i in 1:5) {   y0 <- i - 1   nbhd_polys[[i]] <- st_polygon(list(matrix(     c(0, y0, 4, y0, 4, y0+1, 0, y0+1, 0, y0),     ncol = 2, byrow = TRUE   ))) } neighborhoods <- st_sf(   id = paste0(\"nbhd_\", 1:5),   geometry = st_sfc(nbhd_polys) ) W_areal <- areal_weights(   target_sf = neighborhoods,   source_sf = tracts,   target_id = \"id\",   source_id = \"id\" ) #> Warning: attribute variables are assumed to be spatially constant throughout #> all geometries dim(W_areal)  # 5 neighborhoods x 20 tracts #> [1]  5 20 # Extract the interpolated columns as a matrix interp_data <- as.matrix(sf::st_drop_geometry(tracts[, c(\"Candidate_A\", \"Candidate_B\")]))  aggregated <- areal_interpolate(interp_data, W_areal) aggregated #>        Candidate_A Candidate_B #> nbhd_1           0           0 #> nbhd_2           0           0 #> nbhd_3           0           0 #> nbhd_4           0           0 #> nbhd_5           0           0 colSums(interp_data)   # tract-level totals #> Candidate_A Candidate_B  #>        1233        1266 colSums(aggregated)    # neighborhood-level totals (should match) #> Candidate_A Candidate_B  #>           0           0 # Attach aggregated data to neighborhoods sf for plotting neighborhoods$Candidate_A <- aggregated[, \"Candidate_A\"] neighborhoods$Candidate_B <- aggregated[, \"Candidate_B\"]  par(mfrow = c(1, 2), mar = c(1, 1, 2, 1))  # Left: tracts plot(tracts[\"Candidate_A\"], main = \"Tracts\", key.pos = NULL, reset = FALSE)  # Right: neighborhoods plot(neighborhoods[\"Candidate_A\"], main = \"Neighborhoods\", key.pos = NULL)"},{"path":"https://antrologos.github.io/interpElections/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Rogerio Barbosa. Author, maintainer. Lucas Gelape. Author.","code":""},{"path":"https://antrologos.github.io/interpElections/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Barbosa R, Gelape L (2026). interpElections: Spatial Interpolation Electoral Data via Inverse Distance Weighting. R package version 0.1.0, https://antrologos.github.io/interpElections/.","code":"@Manual{,   title = {interpElections: Spatial Interpolation of Electoral Data via Inverse Distance Weighting},   author = {Rogerio Barbosa and Lucas Gelape},   year = {2026},   note = {R package version 0.1.0},   url = {https://antrologos.github.io/interpElections/}, }"},{"path":"https://antrologos.github.io/interpElections/index.html","id":"interpelections","dir":"","previous_headings":"","what":"Spatial Interpolation of Electoral Data via Inverse Distance Weighting","title":"Spatial Interpolation of Electoral Data via Inverse Distance Weighting","text":"Spatial interpolation electoral data via inverse distance weighting per-zone optimized decay parameters. interpElections disaggregates data collected source points (e.g., polling locations) target polygons (e.g., census tracts) using travel-time-based IDW weights. decay parameter zone calibrated known demographic totals, resulting weights can interpolate variable — candidate votes, party totals, turnout, custom data. package provides: analytical gradient fast L-BFGS-B optimization CPU GPU-accelerated optimization via torch (ADAM CUDA/MPS). End--end Brazilian election helpers auto-download census, electoral, road-network data municipality. general-purpose API works point--polygon disaggregation problem.","code":""},{"path":"https://antrologos.github.io/interpElections/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Spatial Interpolation of Electoral Data via Inverse Distance Weighting","text":"interpElections yet CRAN. Install GitHub: Optional dependencies unlock additional capabilities: Run setup_torch(), setup_java(), check_r5r() configure installation.","code":"# install.packages(\"remotes\") remotes::install_github(\"antrologos/interpElections\")"},{"path":"https://antrologos.github.io/interpElections/index.html","id":"quick-example","dir":"","previous_headings":"","what":"Quick example","title":"Spatial Interpolation of Electoral Data via Inverse Distance Weighting","text":"See vignette(\"introduction\") full walkthrough: Getting Started interpElections.","code":"library(interpElections)  # Bundled example: 20 tracts, 8 source points, 3 demographic groups tt  <- readRDS(system.file(\"extdata/example_tt_matrix.rds\",                             package = \"interpElections\")) pop <- readRDS(system.file(\"extdata/example_pop_matrix.rds\",                             package = \"interpElections\")) src <- readRDS(system.file(\"extdata/example_source_matrix.rds\",                             package = \"interpElections\"))  # Find optimal per-zone decay parameters result <- optimize_alpha(tt, pop, src, use_gpu = FALSE, verbose = FALSE) result #> interpElections optimization result #>   Method: cpu_lbfgsb_parallel | Convergence: 0 (success) #>   Objective: ... #>   Alpha: n=20, mean=..., range=[..., ...]  # Interpolate any source-level data into the 20 tracts candidate_votes <- matrix(rpois(16, 200), nrow = 8, ncol = 2,                            dimnames = list(NULL, c(\"Party_A\", \"Party_B\"))) interpolated <- idw_interpolate(tt, result$alpha, candidate_votes)  # Total conservation: source totals == tract totals colSums(candidate_votes) colSums(interpolated)"},{"path":"https://antrologos.github.io/interpElections/index.html","id":"brazilian-elections-in-one-call","dir":"","previous_headings":"","what":"Brazilian elections in one call","title":"Spatial Interpolation of Electoral Data via Inverse Distance Weighting","text":"Brazilian municipal elections, single function downloads census data, electoral results, road networks, computes travel times, runs full interpolation pipeline: package includes crosswalk 5,710 Brazilian municipalities (data(muni_crosswalk)) mapping IBGE codes TSE codes state abbreviations. See vignette(\"brazilian-elections\") complete workflow: Interpolating Brazilian Electoral Data.","code":"result <- interpolate_election_br(   code_muni = 1400100,   # Boa Vista, RR (IBGE 7-digit code)   year = 2020,           # Municipal election year   what = \"candidates\"    # or \"parties\", \"turnout\", \"demographics\" )  summary(result) plot(result)"},{"path":"https://antrologos.github.io/interpElections/index.html","id":"custom-data-non-brazilian","dir":"","previous_headings":"","what":"Custom data (non-Brazilian)","title":"Spatial Interpolation of Electoral Data via Inverse Distance Weighting","text":"interpolation engine limited elections. point--polygon disaggregation problem works: See vignette(\"custom-data\") self-contained example synthetic data: Using interpElections Data.","code":"result <- interpolate_election(   tracts_sf     = my_districts,   electoral_sf  = my_schools,   zone_id       = \"district_id\",   point_id      = \"school_id\",   calib_zones   = c(\"pop_young\", \"pop_old\"),   calib_sources = c(\"enroll_young\", \"enroll_old\"),   interp_sources = \"budget\",   time_matrix   = my_distance_matrix )"},{"path":"https://antrologos.github.io/interpElections/index.html","id":"how-it-works","dir":"","previous_headings":"","what":"How it works","title":"Spatial Interpolation of Electoral Data via Inverse Distance Weighting","text":"tract source point j, raw weight : Wij=(tij+1)−αiW_{ij} = (t_{ij} + 1)^{-\\alpha_i} t travel time minutes α per-zone decay parameter. weight matrix column-standardized source distributes exactly 100% data across tracts — guaranteeing total conservation. optimal α vector found minimizing squared error interpolated observed demographic totals: f(α)=∑,k(V̂ik−Pik)2f(\\alpha) = \\sum_{,k} \\bigl(\\hat{V}_{ik} - P_{ik}\\bigr)^2 V̂ = Wstd(α) × V (interpolated values) P known population matrix. analytical gradient makes feasible thousands zones. See vignette(\"understanding--model\") full mathematical treatment: Understanding IDW Interpolation Model.","code":""},{"path":"https://antrologos.github.io/interpElections/index.html","id":"vignettes","dir":"","previous_headings":"","what":"Vignettes","title":"Spatial Interpolation of Electoral Data via Inverse Distance Weighting","text":"interpElections ships six vignettes form progressive tutorial:","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://antrologos.github.io/interpElections/index.html","id":"gpu-acceleration","dir":"","previous_headings":"","what":"GPU acceleration","title":"Spatial Interpolation of Electoral Data via Inverse Distance Weighting","text":"municipalities ~1,000 census tracts, GPU acceleration provides significant speedups. package supports NVIDIA GPUs (CUDA) Apple Silicon (MPS): See vignette(\"performance--configuration\") details: Performance Tuning Configuration.","code":"setup_torch()           # one-time installation use_gpu(TRUE)           # enable globally result <- optimize_alpha(tt, pop, src)  # automatically uses GPU"},{"path":"https://antrologos.github.io/interpElections/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Spatial Interpolation of Electoral Data via Inverse Distance Weighting","text":"use interpElections academic work, please cite: Barbosa, R. & Gelape, L. (2025). interpElections: Spatial Interpolation Electoral Data via Inverse Distance Weighting. R package version 0.1.0. https://github.com/antrologos/interpElections","code":""},{"path":"https://antrologos.github.io/interpElections/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Spatial Interpolation of Electoral Data via Inverse Distance Weighting","text":"MIT","code":""},{"path":"https://antrologos.github.io/interpElections/reference/areal_interpolate.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate data from source zones to target polygons using areal weights — areal_interpolate","title":"Aggregate data from source zones to target polygons using areal weights — areal_interpolate","text":"Applies precomputed areal weight matrix (areal_weights()) transfer data source zones target polygons.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/areal_interpolate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate data from source zones to target polygons using areal weights — areal_interpolate","text":"","code":"areal_interpolate(data, weights)"},{"path":"https://antrologos.github.io/interpElections/reference/areal_interpolate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate data from source zones to target polygons using areal weights — areal_interpolate","text":"data Numeric matrix data.frame [n_source x p]. Data source zones. Rows must correspond columns weights. weights Numeric matrix [n_target x n_source]. Output areal_weights().","code":""},{"path":"https://antrologos.github.io/interpElections/reference/areal_interpolate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate data from source zones to target polygons using areal weights — areal_interpolate","text":"Numeric matrix [n_target x p]. Aggregated values target polygons.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/areal_interpolate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregate data from source zones to target polygons using areal weights — areal_interpolate","text":"","code":"W <- matrix(c(0.7, 0.3, 0.2, 0.8), nrow = 2)  # 2 targets x 2 sources src_data <- matrix(c(100, 200), nrow = 2)        # 2 sources x 1 variable areal_interpolate(src_data, W) #>      [,1] #> [1,]  110 #> [2,]  190"},{"path":"https://antrologos.github.io/interpElections/reference/areal_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute area-weighted intersection matrix between two polygon layers — areal_weights","title":"Compute area-weighted intersection matrix between two polygon layers — areal_weights","text":"Builds weight matrix maps values source polygons (e.g., census tracts) target polygons (e.g., custom analysis zones) based fraction area shared .","code":""},{"path":"https://antrologos.github.io/interpElections/reference/areal_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute area-weighted intersection matrix between two polygon layers — areal_weights","text":"","code":"areal_weights(target_sf, source_sf, target_id = \"id\", source_id = \"id\")"},{"path":"https://antrologos.github.io/interpElections/reference/areal_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute area-weighted intersection matrix between two polygon layers — areal_weights","text":"target_sf sf object polygon geometries. target zones aggregate . source_sf sf object polygon geometries. source zones (e.g., census tracts interpolated data). target_id Character. Name ID column target_sf. source_id Character. Name ID column source_sf.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/areal_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute area-weighted intersection matrix between two polygon layers — areal_weights","text":"numeric matrix [n_target x n_source]. column standardized weights target zones sum 1 (0 source zone overlap). Row names = target IDs, column names = source IDs.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/areal_weights.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute area-weighted intersection matrix between two polygon layers — areal_weights","text":"Requires sf package. Geometries made valid sf::st_make_valid() computing intersections.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/as.data.frame.interpElections_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert result to data frame — as.data.frame.interpElections_result","title":"Convert result to data frame — as.data.frame.interpElections_result","text":"Drops geometry tracts_sf returns plain data frame zone IDs interpolated values.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/as.data.frame.interpElections_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert result to data frame — as.data.frame.interpElections_result","text":"","code":"# S3 method for class 'interpElections_result' as.data.frame(x, ...)"},{"path":"https://antrologos.github.io/interpElections/reference/as.data.frame.interpElections_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert result to data frame — as.data.frame.interpElections_result","text":"x interpElections_result object. ... Ignored.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/as.data.frame.interpElections_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert result to data frame — as.data.frame.interpElections_result","text":"data frame.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_download_geocode.html","id":null,"dir":"Reference","previous_headings":"","what":"Download geocoded polling station data from TSE — br_download_geocode","title":"Download geocoded polling station data from TSE — br_download_geocode","text":"Downloads official polling station location data (eleitorado por local de votação) TSE open data portal. file includes geographic coordinates (NR_LATITUDE, NR_LONGITUDE) polling locations, along voter counts addresses.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_download_geocode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Download geocoded polling station data from TSE — br_download_geocode","text":"","code":"br_download_geocode(   year,   uf = NULL,   code_muni_tse = NULL,   force = FALSE,   cache = TRUE,   verbose = TRUE )"},{"path":"https://antrologos.github.io/interpElections/reference/br_download_geocode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Download geocoded polling station data from TSE — br_download_geocode","text":"year Integer. Election year (e.g., 2010, 2012, 2016, 2020). uf Character NULL. Two-letter state abbreviation. provided, filters results state. code_muni_tse Character NULL. 5-digit TSE municipality code. provided, filters results municipality . force Logical. Re-download even cached file exists. Default: FALSE. cache Logical. TRUE (default), downloaded files stored persistently. See get_interpElections_cache_dir(). verbose Logical. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_download_geocode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Download geocoded polling station data from TSE — br_download_geocode","text":"data frame one row per section per round, using original TSE column names. Returns NULL data available given year (e.g., 2010). Key columns: CD_MUNICIPIO TSE municipality code (5-digit) NR_ZONA Electoral zone number NR_LOCAL_VOTACAO Polling location number NR_SECAO Section number NR_LATITUDE Latitude polling location (-1 missing) NR_LONGITUDE Longitude polling location (-1 missing) NM_LOCAL_VOTACAO Name polling location DS_ENDERECO Address polling location","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_download_geocode.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Download geocoded polling station data from TSE — br_download_geocode","text":"TSE data available 2010 onward. years 2010 (e.g., 2008), function returns NULL caller can fall back alternative sources. Data downloaded https://cdn.tse.jus.br/estatistica/sead/odsele/eleitorado_locais_votacao/. Files cached persistently default reused subsequent calls unless force = TRUE. Use interpElections_cache() manage cached files. CSV files use semicolon (;) delimiter Latin-1 encoding. Missing coordinates stored -1 TSE data.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/br_download_turnout.html","id":null,"dir":"Reference","previous_headings":"","what":"Download turnout/attendance data from TSE — br_download_turnout","title":"Download turnout/attendance data from TSE — br_download_turnout","text":"Downloads official turnout detail data (detalhe da votação por seção) TSE open data portal. file provides attendance counts, abstentions, vote type breakdowns per polling section.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_download_turnout.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Download turnout/attendance data from TSE — br_download_turnout","text":"","code":"br_download_turnout(   year,   uf = NULL,   code_muni_tse = NULL,   cargo = NULL,   turno = 1L,   force = FALSE,   cache = TRUE,   verbose = TRUE )"},{"path":"https://antrologos.github.io/interpElections/reference/br_download_turnout.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Download turnout/attendance data from TSE — br_download_turnout","text":"year Integer. Election year (e.g., 2008, 2012, 2016, 2020). uf Character NULL. Two-letter state abbreviation. Used filter nationwide file single state. code_muni_tse Character NULL. 5-digit TSE municipality code. provided, filters results municipality . cargo Integer NULL. Electoral office code filter. NULL, uses office (turnout across offices). turno Integer. Election round (1 2). Default: 1. force Logical. Re-download even cached file exists. Default: FALSE. cache Logical. TRUE (default), downloaded files stored persistently. See get_interpElections_cache_dir(). verbose Logical. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_download_turnout.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Download turnout/attendance data from TSE — br_download_turnout","text":"data frame one row per section per office, using original TSE column names. Key columns: ANO_ELEICAO Election year CD_MUNICIPIO TSE municipality code (5-digit) NR_ZONA Electoral zone number NR_SECAO Section number CD_CARGO Office code QT_COMPARECIMENTO Number voters attended QT_APTOS Number eligible voters QT_ABSTENCOES Number abstentions","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_download_turnout.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Download turnout/attendance data from TSE — br_download_turnout","text":"TSE publishes data single nationwide file https://cdn.tse.jus.br/estatistica/sead/odsele/detalhe_votacao_secao/. file can large (hundreds MB). Results filtered municipality /state immediately reading.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/br_download_votes.html","id":null,"dir":"Reference","previous_headings":"","what":"Download candidate vote data from TSE — br_download_votes","title":"Download candidate vote data from TSE — br_download_votes","text":"Downloads official candidate vote data (votação por seção eleitoral) TSE open data portal given election year state. data downloaded ZIP file containing semicolon-delimited CSV.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_download_votes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Download candidate vote data from TSE — br_download_votes","text":"","code":"br_download_votes(   year,   uf,   code_muni_tse = NULL,   cargo = NULL,   turno = 1L,   force = FALSE,   cache = TRUE,   verbose = TRUE )"},{"path":"https://antrologos.github.io/interpElections/reference/br_download_votes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Download candidate vote data from TSE — br_download_votes","text":"year Integer. Election year (e.g., 2008, 2012, 2016, 2020). uf Character. Two-letter state abbreviation (e.g., \"SP\", \"RJ\"), \"BR\" download national file (used presidential data). code_muni_tse Character NULL. 5-digit TSE municipality code. provided, filters results municipality . cargo Integer NULL. Electoral office code filter (e.g., 13 = Vereador, 11 = Prefeito). NULL, returns offices. turno Integer. Election round (1 2). Default: 1. force Logical. Re-download even cached file exists. Default: FALSE. cache Logical. TRUE (default), downloaded files stored persistent cross-session cache directory (see get_interpElections_cache_dir()). FALSE, files stored temporary directory lost R restarts. verbose Logical. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_download_votes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Download candidate vote data from TSE — br_download_votes","text":"data frame one row per candidate per polling section, using original TSE column names. Key columns: ANO_ELEICAO Election year CD_MUNICIPIO TSE municipality code (5-digit) NR_ZONA Electoral zone number NR_SECAO Section number NR_LOCAL_VOTACAO Polling location number CD_CARGO Office code NR_VOTAVEL Candidate number (95 = blank, 96 = null) NM_VOTAVEL Candidate name QT_VOTOS Number votes","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_download_votes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Download candidate vote data from TSE — br_download_votes","text":"Data downloaded https://cdn.tse.jus.br/estatistica/sead/odsele/votacao_secao/. Files cached persistently default reused subsequent calls unless force = TRUE. Use interpElections_cache() manage cached files. CSV files use semicolon (;) delimiter Latin-1 encoding. Note: general elections, presidential vote data (cargo 1) published national file (uf = \"BR\") rather per-state files. br_prepare_electoral() handles automatically.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_electoral.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare Brazilian electoral data at the polling-location level — br_prepare_electoral","title":"Prepare Brazilian electoral data at the polling-location level — br_prepare_electoral","text":"Downloads TSE voter profile, attendance, candidate vote data, merges geocoded polling station coordinates, aggregates voting-location level. Returns data frame ready interpolation.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_electoral.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare Brazilian electoral data at the polling-location level — br_prepare_electoral","text":"","code":"br_prepare_electoral(   code_muni_ibge,   code_muni_tse,   uf,   year,   cargo = NULL,   turno = 1L,   what = \"candidates\",   candidates = NULL,   parties = NULL,   perfil_path = NULL,   comparecimento_path = NULL,   votacao_path = NULL,   geocode_path = NULL,   cache = TRUE,   force = FALSE,   verbose = TRUE )"},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_electoral.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare Brazilian electoral data at the polling-location level — br_prepare_electoral","text":"code_muni_ibge Character. 7-digit IBGE municipality code (e.g., \"3550308\" Sao Paulo). code_muni_tse Character. 5-digit TSE municipality code (e.g., \"71072\" Sao Paulo). Typically obtained via interpolate_election_br(), resolves automatically. uf Character. Two-letter state abbreviation (e.g., \"SP\", \"RJ\", \"MG\"). year Integer. Election year. See interpolate_election_br() distinction municipal general election years. cargo Integer, character, NULL. electoral office(s) include. Accepts human-readable aliases (case-insensitive), TSE numeric codes, vector either: NULL (default), offices present data file included. general election years, automatically downloads national file presidential data. multiple cargos selected, output columns prefixed (e.g., PREFEITO_CAND_*, VEREADOR_CAND_*). turno Integer. Election round: 1 (first round, default) 2 (runoff). runoff exists presidente, governador, prefeito (cities >200k voters), candidate wins outright first round. Character vector. Controls data columns produced output. One : \"candidates\" (default): One column per candidate vote counts, named CAND_<ballot_number>. Also includes QT_COMPARECIMENTO (total turnout). Special ballot numbers: 95 = blank votes (em branco), 96 = null votes (nulo). \"parties\": One column per party total votes, named PARTY_<abbreviation> (e.g., PARTY_PT, PARTY_MDB). Also includes QT_COMPARECIMENTO. \"turnout\": Turnout statistics: QT_COMPARECIMENTO (voters showed ), QT_APTOS (eligible voters), QT_ABSTENCOES (abstentions), available data. \"demographics\": Voter profile gender (GENERO_FEMININO, GENERO_MASCULINO, GENERO_NAO_INFORMADO) education level (EDUC_ANALFABETO, EDUC_LE_ESCREVE, EDUC_FUND_INCOMP, EDUC_FUND_COMP, EDUC_MEDIO_INCOMP, EDUC_MEDIO_COMP, EDUC_SUP_INCOMP, EDUC_SUP_COMP, EDUC_NAO_INFORMADO). Note: demographics come voter registration profile, vote data, cargo filter applies. Values can combined: = c(\"candidates\", \"parties\", \"turnout\", \"demographics\"). candidates Character numeric vector, NULL. Filter specific candidates (applies \"candidates\" %% ): Numeric values match candidate's ballot number exactly. Example: candidates = c(13, 22). Character values perform accent-normalized, case-insensitive substring matching candidate's registered name. Example: candidates = \"LULA\" matches \"LUIZ INACIO LULA DA SILVA\". NULL (default): candidates kept. parties Character vector NULL. Filter specific parties (applies \"parties\" %% ). Uses official TSE party abbreviations, matched case-insensitively. Example: parties = c(\"PT\", \"PL\", \"MDB\"). NULL (default): parties kept. perfil_path Character NULL. Path local voter profile CSV file. NULL (default), downloads TSE. comparecimento_path Character NULL. Path attendance parquet file. NULL (default), turnout computed vote data . votacao_path Character NULL. Path candidate votes parquet file. NULL (default), downloads TSE. geocode_path Character NULL. Path CSV geocoded polling station coordinates (columns: nr_zona, nr_local_votacao, lat, long). NULL, coordinates obtained TSE Danny Hidalgo's geocoding project. cache Logical. TRUE (default), downloaded files stored persistently. See get_interpElections_cache_dir(). force Logical. Re-download even cached file exists. Default: FALSE. verbose Logical. Print progress messages. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_electoral.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare Brazilian electoral data at the polling-location level — br_prepare_electoral","text":"data frame one row per voting location (per polling section). Contains following column groups: Always present: lat, long: Coordinates voting location. id: Sequential integer ID. votantes_18_20, ..., votantes_65_69: Registered voters per age bracket location (used calibration data). Conditional : \"candidates\": CAND_<number> columns + QT_COMPARECIMENTO. \"parties\": PARTY_<abbrev> columns + QT_COMPARECIMENTO. \"turnout\": QT_COMPARECIMENTO, QT_APTOS, QT_ABSTENCOES. \"demographics\": GENERO_* EDUC_* columns. multiple cargo values selected, candidate party columns prefixed (e.g., PREFEITO_CAND_45, VEREADOR_PARTY_PT).","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_electoral.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prepare Brazilian electoral data at the polling-location level — br_prepare_electoral","text":"users use interpolate_election_br() instead, calls function internally runs full interpolation pipeline. Use br_prepare_electoral() directly need raw polling-location data without interpolation. votacao_path comparecimento_path NULL, data auto-downloaded official TSE open data portal using br_download_votes() br_download_turnout().","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_electoral.html","id":"data-sources","dir":"Reference","previous_headings":"","what":"Data sources","title":"Prepare Brazilian electoral data at the polling-location level — br_prepare_electoral","text":"data downloaded TSE open data portal https://cdn.tse.jus.br/estatistica/sead/odsele/. Presidential vote data (cargo 1) published separate national file (votacao_secao_<year>_BR.zip, ~250 MB) rather per-state files. function detects presidential data needed downloads national file automatically. Geocoded polling station coordinates come two sources: official TSE data (available ~2020 onwards, missing coordinates) Danny Hidalgo's geocoding project (https://github.com/fdhidalgo/geocode_br_polling_stations), covers earlier years. TSE coordinates take priority available.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_electoral.html","id":"dependencies","dir":"Reference","previous_headings":"","what":"Dependencies","title":"Prepare Brazilian electoral data at the polling-location level — br_prepare_electoral","text":"Requires dplyr, tidyr, data.table, stringr packages. reading local parquet files, arrow package also required.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_electoral.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare Brazilian electoral data at the polling-location level — br_prepare_electoral","text":"","code":"if (FALSE) { # \\dontrun{ # ── Basic usage ──────────────────────────────────────────────── # All candidates in the 2020 municipal election for Boa Vista elec <- br_prepare_electoral(   code_muni_ibge = \"1400100\",   code_muni_tse  = \"01120\",   uf = \"RR\",   year = 2020,   what = c(\"candidates\", \"turnout\") )  # ── Specific cargo ───────────────────────────────────────────── # Only the presidential race in 2022 elec <- br_prepare_electoral(   code_muni_ibge = \"3170701\",   code_muni_tse  = \"54135\",   uf = \"MG\",   year = 2022,   cargo = \"presidente\" )  # ── Filter specific candidates ───────────────────────────────── # Only Lula and Bolsonaro in the 2022 presidential race elec <- br_prepare_electoral(   code_muni_ibge = \"3170701\",   code_muni_tse  = \"54135\",   uf = \"MG\",   year = 2022,   cargo = \"presidente\",   candidates = c(13, 22) )  # ── Party vote totals ────────────────────────────────────────── elec <- br_prepare_electoral(   code_muni_ibge = \"3170701\",   code_muni_tse  = \"54135\",   uf = \"MG\",   year = 2020,   cargo = \"vereador\",   what = \"parties\",   parties = c(\"PT\", \"MDB\", \"PL\") )  # ── Voter demographics ───────────────────────────────────────── elec <- br_prepare_electoral(   code_muni_ibge = \"3170701\",   code_muni_tse  = \"54135\",   uf = \"MG\",   year = 2022,   what = \"demographics\" ) # -> GENERO_FEMININO, GENERO_MASCULINO, EDUC_SUP_COMP, ... } # }"},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_population.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare Brazilian census population data by age bracket per census tract — br_prepare_population","title":"Prepare Brazilian census population data by age bracket per census tract — br_prepare_population","text":"Downloads census population data IBGE (via censobr package), groups ages brackets, returns data frame one row per census tract. Supports census years 2000, 2010, 2022.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_population.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare Brazilian census population data by age bracket per census tract — br_prepare_population","text":"","code":"br_prepare_population(code_muni, year = 2010)"},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_population.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare Brazilian census population data by age bracket per census tract — br_prepare_population","text":"code_muni Numeric character vector. IBGE municipality codes. year Integer. Census year: 2000, 2010, 2022. Default: 2010.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_population.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare Brazilian census population data by age bracket per census tract — br_prepare_population","text":"data frame columns: code_muni, code_tract, population bracket columns (pop_*). exact brackets depend census year (see Details).","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_population.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prepare Brazilian census population data by age bracket per census tract — br_prepare_population","text":"Requires censobr, dplyr, tidyr, data.table packages. Census 2000 2010 produce following voting-age brackets: pop_18_20, pop_21_24, pop_25_29, pop_30_39, pop_40_49, pop_50_59, pop_60_69. Census 2022 produces: pop_15_19, pop_20_24, pop_25_29, pop_30_39, pop_40_49, pop_50_59, pop_60_69. years also produce: pop_00_04, pop_05_09, pop_10_14, pop_15_17 (pop_15_19 2022), pop_70mais.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_population.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare Brazilian census population data by age bracket per census tract — br_prepare_population","text":"","code":"if (FALSE) { # \\dontrun{ # Census 2010 population for Sao Paulo pop <- br_prepare_population(code_muni = \"3550308\", year = 2010) head(pop) } # }"},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_tracts.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare census tract shapefiles with population data for a Brazilian municipality — br_prepare_tracts","title":"Prepare census tract shapefiles with population data for a Brazilian municipality — br_prepare_tracts","text":"Downloads census tract geometries via geobr, joins population data br_prepare_population(), optionally clips urban area mask, removes unpopulated tracts.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_tracts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare census tract shapefiles with population data for a Brazilian municipality — br_prepare_tracts","text":"","code":"br_prepare_tracts(   code_muni,   pop_data,   remove_unpopulated = TRUE,   clip_sf = NULL,   year = 2010,   crs = \"EPSG:5880\",   verbose = TRUE )"},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_tracts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare census tract shapefiles with population data for a Brazilian municipality — br_prepare_tracts","text":"code_muni Numeric character. IBGE municipality code. pop_data Data frame. Output br_prepare_population(). Must contain code_tract population bracket columns. remove_unpopulated Logical. Remove tracts pop_total == 0. Default: TRUE. clip_sf Optional sf polygon object. provided, census tracts clipped geometry (e.g., remove non-urban areas like parks, forests, water bodies). Population proportionally adjusted based fraction area retained. year Integer. Census tract geometry year. Default: 2010. crs Character integer. CRS output. Default: SIRGAS 2000 / Brazil Polyconic (EPSG:5880). verbose Logical. Print progress messages. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_tracts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare census tract shapefiles with population data for a Brazilian municipality — br_prepare_tracts","text":"sf object census tract polygons columns: code_tract, pop_* bracket columns pop_data, pop_total (sum brackets).","code":""},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_tracts.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prepare census tract shapefiles with population data for a Brazilian municipality — br_prepare_tracts","text":"Requires geobr, sf, dplyr packages.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/br_prepare_tracts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare census tract shapefiles with population data for a Brazilian municipality — br_prepare_tracts","text":"","code":"if (FALSE) { # \\dontrun{ pop <- br_prepare_population(\"3550308\", year = 2010) tracts <- br_prepare_tracts(\"3550308\", pop) } # }"},{"path":"https://antrologos.github.io/interpElections/reference/check_r5r.html","id":null,"dir":"Reference","previous_headings":"","what":"Check r5r and Java 21 setup — check_r5r","title":"Check r5r and Java 21 setup — check_r5r","text":"Runs diagnostic check r5r dependency chain: whether r5r package installed whether suitable Java/JDK (version 21+) available system.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/check_r5r.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check r5r and Java 21 setup — check_r5r","text":"","code":"check_r5r()"},{"path":"https://antrologos.github.io/interpElections/reference/check_r5r.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check r5r and Java 21 setup — check_r5r","text":"Invisibly, list components: r5r_installed Logical. java_found Logical. java_version Integer major version, NA. java_sufficient Logical. TRUE version >= 21. java_memory Character NULL. Configured JVM max heap (e.g. \"4g\"). system_ram Character NULL. Total system RAM (e.g. \"16 GB\"). ready Logical. TRUE checks pass.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/check_r5r.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check r5r and Java 21 setup — check_r5r","text":"","code":"check_r5r() #> [ok] r5r package installed (v2.3.0) #> [!!] Java 17 found, but r5r requires >= 21 #> [--] Java max heap: not configured (JVM default, typically 256m) #>      Set with: interpElections::set_java_memory(\"4g\") #>      System RAM: 15.6 GB #>  #> Some checks failed. #> Run interpElections::setup_java() to download and install Java 21."},{"path":"https://antrologos.github.io/interpElections/reference/check_torch.html","id":null,"dir":"Reference","previous_headings":"","what":"Check torch and GPU setup — check_torch","title":"Check torch and GPU setup — check_torch","text":"Runs comprehensive diagnostic torch dependency chain: whether torch R package installed, whether libtorch/lantern binaries present, GPU hardware available, whether CUDA MPS acceleration actually working.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/check_torch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check torch and GPU setup — check_torch","text":"","code":"check_torch(verbose = TRUE)"},{"path":"https://antrologos.github.io/interpElections/reference/check_torch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check torch and GPU setup — check_torch","text":"verbose Logical. Print diagnostic messages. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/check_torch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check torch and GPU setup — check_torch","text":"Invisibly, list components: torch_installed Logical. torch R package installed? torch_version Character NA. torch package version. binaries_installed Logical. libtorch/lantern binaries present? gpu_hardware Character. \"nvidia\", \"apple_silicon\", \"none\". gpu_name Character NA. GPU name hardware detection. gpu_vram Character NA. VRAM MB (NVIDIA ). cuda_available Logical. torch report CUDA available? cuda_runtime Character NA. CUDA runtime version. cuda_compute Character NA. GPU compute capability. cudnn_available Logical. mps_available Logical. MPS available (Apple Silicon)? tensor_test Logical. Can tensor created GPU? device Character. Best available device: \"cuda\", \"mps\", \"cpu\". ready Logical. TRUE GPU acceleration fully working.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/check_torch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check torch and GPU setup — check_torch","text":"","code":"if (FALSE) { # \\dontrun{ check_torch() } # }"},{"path":"https://antrologos.github.io/interpElections/reference/coef.interpElections_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract alpha coefficients — coef.interpElections_result","title":"Extract alpha coefficients — coef.interpElections_result","text":"Returns alpha decay parameter vector, plays role \"coefficients\" IDW model.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/coef.interpElections_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract alpha coefficients — coef.interpElections_result","text":"","code":"# S3 method for class 'interpElections_result' coef(object, ...)"},{"path":"https://antrologos.github.io/interpElections/reference/coef.interpElections_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract alpha coefficients — coef.interpElections_result","text":"object interpElections_result object. ... Ignored.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/coef.interpElections_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract alpha coefficients — coef.interpElections_result","text":"Numeric vector length n (one alpha per zone).","code":""},{"path":"https://antrologos.github.io/interpElections/reference/compute_travel_times.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute a travel-time matrix from zone centroids to source points — compute_travel_times","title":"Compute a travel-time matrix from zone centroids to source points — compute_travel_times","text":"Builds travel-time matrix using r5r routing engine. Computes travel times centroids target zones (e.g., census tracts) geolocated source points (e.g., polling locations).","code":""},{"path":"https://antrologos.github.io/interpElections/reference/compute_travel_times.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute a travel-time matrix from zone centroids to source points — compute_travel_times","text":"","code":"compute_travel_times(   zones_sf,   points_sf,   network_path,   zone_id = \"id\",   point_id = \"id\",   mode = \"WALK\",   max_trip_duration = 300L,   fill_missing = max_trip_duration,   n_threads = 4L,   departure_datetime = NULL,   verbose = TRUE )"},{"path":"https://antrologos.github.io/interpElections/reference/compute_travel_times.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute a travel-time matrix from zone centroids to source points — compute_travel_times","text":"zones_sf sf object polygon geometries. Target zones. points_sf sf object point geometries. Source points. network_path Character. Path directory containing OSM .pbf file building r5r network. zone_id Character. Name ID column zones_sf. Default: \"id\". point_id Character. Name ID column points_sf. Default: \"id\". mode Character. Routing mode. Default: \"WALK\". max_trip_duration Integer. Maximum trip duration minutes. Default: 300. fill_missing Numeric. Value fill unreachable origin-destination pairs. Default: max_trip_duration. n_threads Integer. Number r5r routing threads. Default: 4. departure_datetime POSIXct NULL. Departure time transit-based routing. Required mode includes transit components. Default: NULL (ignored WALK/BICYCLE modes). verbose Logical. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/compute_travel_times.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute a travel-time matrix from zone centroids to source points — compute_travel_times","text":"numeric matrix [n_zones x n_points]. Travel times minutes. Row names = zone IDs, column names = point IDs. Unreachable pairs filled fill_missing.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/compute_travel_times.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute a travel-time matrix from zone centroids to source points — compute_travel_times","text":"Requires r5r sf packages. r5r requires Java/JDK 21+. Use download_r5r_data() obtain OSM data needed network_path.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/compute_travel_times.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute a travel-time matrix from zone centroids to source points — compute_travel_times","text":"","code":"if (FALSE) { # \\dontrun{ tt <- compute_travel_times(   zones_sf = tracts, points_sf = stations,   network_path = \"path/to/osm_data\",   zone_id = \"code_tract\", point_id = \"id\" ) } # }"},{"path":"https://antrologos.github.io/interpElections/reference/download_r5r_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Download OSM and elevation data for r5r routing — download_r5r_data","title":"Download OSM and elevation data for r5r routing — download_r5r_data","text":"Downloads OpenStreetMap road network (.pbf file) optionally satellite elevation data needed build r5r routing network. output directory can passed directly compute_travel_times() network_path.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/download_r5r_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Download OSM and elevation data for r5r routing — download_r5r_data","text":"","code":"download_r5r_data(   area_sf,   output_dir,   osm = TRUE,   elevation = FALSE,   osm_provider = \"geofabrik\",   force = FALSE,   verbose = TRUE )"},{"path":"https://antrologos.github.io/interpElections/reference/download_r5r_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Download OSM and elevation data for r5r routing — download_r5r_data","text":"area_sf sf object defining area interest. bounding box used select appropriate OSM extract clip downloaded file. output_dir Character. Directory save downloaded files. Created exist. osm Logical. Download OpenStreetMap road network. Default: TRUE. elevation Logical. Download elevation raster accurate walking/cycling routing hilly terrain. Default: FALSE. osm_provider Character. OSM extract provider osmextract. Default: \"geofabrik\". Alternatives: \"bbbike\", \"openstreetmap_fr\". force Logical. Re-download even files already exist. Default: FALSE. verbose Logical. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/download_r5r_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Download OSM and elevation data for r5r routing — download_r5r_data","text":"list paths downloaded files: osm_pbf Character. Path OSM .pbf file (NULL osm = FALSE). elevation_tif Character. Path elevation .tif file (NULL elevation = FALSE). output_dir Character. output directory path.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/download_r5r_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Download OSM and elevation data for r5r routing — download_r5r_data","text":"downloading provider extract (may cover whole state), .pbf file clipped bounding box area_sf using osmium osmconvert (available system). avoids r5r's geographic extent limit (~975,000 km2). Requires osmextract package OSM downloads optionally elevatr package elevation data. suggested dependencies package. clipping large OSM extracts, osmium-tool (recommended) osmconvert must installed. neither found, function interactively offer install one via setup_osmium() proceeding. non-interactive mode, stops actionable error message. dependency checks (R packages clipping tools) run start, downloads begin.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/get_interpElections_cache_dir.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the interpElections cache directory — get_interpElections_cache_dir","title":"Get the interpElections cache directory — get_interpElections_cache_dir","text":"Returns path directory interpElections stores cached downloaded files (TSE data, Hidalgo geocoding, travel time matrices, etc.). default location OS-appropriate (via tools::R_user_dir()). custom path can set set_interpElections_cache_dir().","code":""},{"path":"https://antrologos.github.io/interpElections/reference/get_interpElections_cache_dir.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the interpElections cache directory — get_interpElections_cache_dir","text":"","code":"get_interpElections_cache_dir()"},{"path":"https://antrologos.github.io/interpElections/reference/get_interpElections_cache_dir.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the interpElections cache directory — get_interpElections_cache_dir","text":"Character. Path cache directory.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/idw_gradient.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the analytical gradient of the IDW objective — idw_gradient","title":"Compute the analytical gradient of the IDW objective — idw_gradient","text":"Computes gradient idw_objective() respect element alpha vector. Used CPU optimizer faster convergence.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/idw_gradient.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the analytical gradient of the IDW objective — idw_gradient","text":"","code":"idw_gradient(alpha, time_matrix, pop_matrix, source_matrix)"},{"path":"https://antrologos.github.io/interpElections/reference/idw_gradient.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the analytical gradient of the IDW objective — idw_gradient","text":"alpha Numeric vector length n. Decay parameters per target zone. Must non-negative. time_matrix Numeric matrix [n x m]. Adjusted travel times (offset already applied). Rows = target zones, columns = source points. pop_matrix Numeric matrix [n x k]. Known population counts per target zone, k demographic groups columns. source_matrix Numeric matrix [m x k]. Known counts source points (e.g., registered voters age group).","code":""},{"path":"https://antrologos.github.io/interpElections/reference/idw_gradient.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the analytical gradient of the IDW objective — idw_gradient","text":"Numeric vector length n: gradient objective respect element alpha.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/idw_gradient.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute the analytical gradient of the IDW objective — idw_gradient","text":"gradient computed analytically using chain rule column-standardized weight matrix. avoids numerical differentiation significantly faster large problems. k demographic groups, total gradient sum per-group gradients.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/idw_gradient.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the analytical gradient of the IDW objective — idw_gradient","text":"","code":"tt <- matrix(c(2, 5, 3, 4, 6, 2), nrow = 2) pop <- matrix(c(100, 200), nrow = 2) src <- matrix(c(80, 120, 100), nrow = 3) alpha <- c(1, 1.5) idw_gradient(alpha, tt, pop, src) #> [1] -25209.66  22546.36"},{"path":"https://antrologos.github.io/interpElections/reference/idw_interpolate.html","id":null,"dir":"Reference","previous_headings":"","what":"Interpolate source data into target zones using IDW weights — idw_interpolate","title":"Interpolate source data into target zones using IDW weights — idw_interpolate","text":"Applies inverse-distance-weighted interpolation transfer data geolocated source points (e.g., polling locations) target zones (e.g., census tracts), using optimized decay parameters.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/idw_interpolate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interpolate source data into target zones using IDW weights — idw_interpolate","text":"","code":"idw_interpolate(time_matrix, alpha, source_matrix, offset = 1)"},{"path":"https://antrologos.github.io/interpElections/reference/idw_interpolate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interpolate source data into target zones using IDW weights — idw_interpolate","text":"time_matrix Numeric matrix [n x m]. Raw travel times. Rows = target zones, columns = source points. alpha Numeric vector length n. Optimal decay parameters, typically optimize_alpha(). source_matrix Numeric matrix data.frame [m x p]. Data source points interpolated. column variable (e.g., candidate votes, attendance counts). offset Numeric. Travel time offset. Default: 1.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/idw_interpolate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interpolate source data into target zones using IDW weights — idw_interpolate","text":"Numeric matrix [n x p]. Interpolated values target zones. Column names preserved source_matrix.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/idw_interpolate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Interpolate source data into target zones using IDW weights — idw_interpolate","text":"target zone variable v: $$\\hat{v}_i = \\sum_j W_{ij}^{std} \\cdot v_j$$ \\(W^{std}\\) column-standardized weight matrix idw_weights(). function main workhorse applying interpolation optimal alpha values found via optimize_alpha().","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/idw_interpolate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interpolate source data into target zones using IDW weights — idw_interpolate","text":"","code":"tt <- matrix(c(2, 5, 3, 4, 6, 2), nrow = 2) # 2 zones x 3 sources alpha <- c(1, 1.5) src <- matrix(c(80, 120, 100), nrow = 3)      # 3 sources x 1 variable idw_interpolate(tt, alpha, src) #>          [,1] #> [1,] 197.4233 #> [2,] 102.5767"},{"path":"https://antrologos.github.io/interpElections/reference/idw_objective.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the IDW interpolation objective value — idw_objective","title":"Compute the IDW interpolation objective value — idw_objective","text":"Calculates sum squared errors IDW-interpolated values known population matrix. loss function optimize_alpha() minimizes.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/idw_objective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the IDW interpolation objective value — idw_objective","text":"","code":"idw_objective(alpha, time_matrix, pop_matrix, source_matrix)"},{"path":"https://antrologos.github.io/interpElections/reference/idw_objective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the IDW interpolation objective value — idw_objective","text":"alpha Numeric vector length n. Decay parameters per target zone. Must non-negative. time_matrix Numeric matrix [n x m]. Adjusted travel times (offset already applied). Rows = target zones, columns = source points. pop_matrix Numeric matrix [n x k]. Known population counts per target zone, k demographic groups columns. source_matrix Numeric matrix [m x k]. Known counts source points (e.g., registered voters age group).","code":""},{"path":"https://antrologos.github.io/interpElections/reference/idw_objective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the IDW interpolation objective value — idw_objective","text":"Single numeric value: sum((W_std %*% source_matrix - pop_matrix)^2)","code":""},{"path":"https://antrologos.github.io/interpElections/reference/idw_objective.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute the IDW interpolation objective value — idw_objective","text":"weight matrix computed : $$W_{ij} = t_{ij}^{-\\alpha_i}$$ column-standardized column sums 1. interpolated values \\(\\hat{V} = W_{std} \\times V\\), objective \\(\\sum (\\hat{V} - P)^2\\).","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/idw_objective.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the IDW interpolation objective value — idw_objective","text":"","code":"tt <- matrix(c(2, 5, 3, 4, 6, 2), nrow = 2) # 2 zones x 3 sources pop <- matrix(c(100, 200), nrow = 2)          # 2 zones x 1 group src <- matrix(c(80, 120, 100), nrow = 3)      # 3 sources x 1 group alpha <- c(1, 1.5) idw_objective(alpha, tt, pop, src) #> [1] 15197.62"},{"path":"https://antrologos.github.io/interpElections/reference/idw_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the column-standardized IDW weight matrix — idw_weights","title":"Compute the column-standardized IDW weight matrix — idw_weights","text":"Builds inverse distance weight matrix travel-time matrix per-zone decay parameters, column-standardizes column sums 1.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/idw_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the column-standardized IDW weight matrix — idw_weights","text":"","code":"idw_weights(time_matrix, alpha, offset = 1)"},{"path":"https://antrologos.github.io/interpElections/reference/idw_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the column-standardized IDW weight matrix — idw_weights","text":"time_matrix Numeric matrix [n x m]. Raw travel times. Rows = target zones, columns = source points. alpha Numeric vector length n. Decay parameters per target zone. offset Numeric. Value added travel times applying power function, avoid 0^(-alpha). Default: 1.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/idw_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the column-standardized IDW weight matrix — idw_weights","text":"Numeric matrix [n x m]. Column-standardized inverse distance weights. column sums 1. Row/column names preserved time_matrix.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/idw_weights.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute the column-standardized IDW weight matrix — idw_weights","text":"weight zone source point j : $$W_{ij} = (t_{ij} + \\text{offset})^{-\\alpha_i}$$ computing raw weights, column divided sum weights source point form probability distribution target zones.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/idw_weights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the column-standardized IDW weight matrix — idw_weights","text":"","code":"tt <- matrix(c(2, 5, 3, 4, 6, 2), nrow = 2) # 2 zones x 3 sources alpha <- c(1, 1.5) W <- idw_weights(tt, alpha, offset = 1) colSums(W) # each column sums to 1 #> [1] 1 1 1"},{"path":"https://antrologos.github.io/interpElections/reference/interpElections-package.html","id":null,"dir":"Reference","previous_headings":"","what":"interpElections: Spatial Interpolation of Electoral Data via Inverse Distance Weighting — interpElections-package","title":"interpElections: Spatial Interpolation of Electoral Data via Inverse Distance Weighting — interpElections-package","text":"Spatial interpolation electoral data via inverse distance weighting per-zone optimized decay parameters. Designed disaggregating voting results polling locations census tracts using travel-time-based IDW, optional GPU acceleration via torch.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/interpElections-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"interpElections: Spatial Interpolation of Electoral Data via Inverse Distance Weighting — interpElections-package","text":"Maintainer: Rogerio Barbosa rogerio.barbosa@iesp.uerj.br Authors: Lucas Gelape","code":""},{"path":"https://antrologos.github.io/interpElections/reference/interpElections_cache.html","id":null,"dir":"Reference","previous_headings":"","what":"Manage the interpElections download cache — interpElections_cache","title":"Manage the interpElections download cache — interpElections_cache","text":"Lists deletes cached files. default shows per-category size breakdown. Use details = TRUE see individual files. Use delete_file = \"\" clear entire cache.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/interpElections_cache.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Manage the interpElections download cache — interpElections_cache","text":"","code":"interpElections_cache(   list_files = TRUE,   delete_file = NULL,   details = FALSE,   verbose = TRUE )"},{"path":"https://antrologos.github.io/interpElections/reference/interpElections_cache.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Manage the interpElections download cache — interpElections_cache","text":"list_files Logical. TRUE (default), prints per-category summary returns cached file paths. delete_file Character NULL. pattern match files deletion (matched relative paths via grepl()), \"\" delete entire cache. targeted deletion category, see interpElections_cache_clean(). details Logical. TRUE, also prints individual filenames within category. Default: FALSE. verbose Logical. Print messages. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/interpElections_cache.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Manage the interpElections download cache — interpElections_cache","text":"Invisibly returns character vector cached file paths (deletion).","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/interpElections_cache.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Manage the interpElections download cache — interpElections_cache","text":"","code":"if (FALSE) { # \\dontrun{ # Per-category summary interpElections_cache()  # Detailed listing (every file) interpElections_cache(details = TRUE)  # Delete files matching a pattern interpElections_cache(delete_file = \"2020\")  # Delete everything interpElections_cache(delete_file = \"all\") } # }"},{"path":"https://antrologos.github.io/interpElections/reference/interpElections_cache_clean.html","id":null,"dir":"Reference","previous_headings":"","what":"Delete cached files by category — interpElections_cache_clean","title":"Delete cached files by category — interpElections_cache_clean","text":"Convenience function clearing specific categories cached data. discoverable interpElections_cache() delete_file.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/interpElections_cache_clean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Delete cached files by category — interpElections_cache_clean","text":"","code":"interpElections_cache_clean(   category = c(\"all\", \"downloads\", \"processed\", \"networks\", \"travel_times\", \"votes\",     \"turnout\", \"geocode\", \"profile\", \"hidalgo\", \"osm\", \"electoral\", \"tracts\", \"r5r\"),   verbose = TRUE )"},{"path":"https://antrologos.github.io/interpElections/reference/interpElections_cache_clean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Delete cached files by category — interpElections_cache_clean","text":"category Character. category clear. One : \"\" Delete entire cache \"downloads\" raw downloads (votes, turnout, geocode, profile, hidalgo, osm) \"processed\" processed/cached results (electoral, tracts) \"networks\" r5r network indices \"travel_times\" Cached travel time matrices \"votes\" TSE vote data ZIPs \"turnout\" TSE turnout data ZIPs \"geocode\" TSE polling station location ZIPs \"profile\" TSE voter profile ZIPs \"hidalgo\" Hidalgo geocoding fallback data \"osm\" OpenStreetMap road network extracts \"electoral\" Processed electoral data (br_prepare_electoral output) \"tracts\" Cached census tract geometries \"r5r\" r5r routing network indices verbose Logical. Print messages. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/interpElections_cache_clean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Delete cached files by category — interpElections_cache_clean","text":"Invisibly returns path(s) deleted.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/interpElections_cache_clean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Delete cached files by category — interpElections_cache_clean","text":"","code":"if (FALSE) { # \\dontrun{ # Clear only processed electoral data (forces re-computation next run) interpElections_cache_clean(\"electoral\")  # Clear all raw downloads interpElections_cache_clean(\"downloads\")  # Clear everything interpElections_cache_clean(\"all\") } # }"},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election.html","id":null,"dir":"Reference","previous_headings":"","what":"One-step IDW interpolation from source points to target zones — interpolate_election","title":"One-step IDW interpolation from source points to target zones — interpolate_election","text":"High-level wrapper combines travel-time computation (optional), alpha optimization, interpolation single call. travel time matrix provided, OSM road network data automatically downloaded travel times computed via r5r.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"One-step IDW interpolation from source points to target zones — interpolate_election","text":"","code":"interpolate_election(   tracts_sf,   electoral_sf,   zone_id,   point_id,   calib_zones,   calib_sources,   interp_sources = NULL,   time_matrix = NULL,   network_path = NULL,   elevation_path = NULL,   osm_buffer_km = 10,   min_pop = 1,   alpha = NULL,   offset = 1,   keep = NULL,   use_gpu = NULL,   verbose = TRUE,   ...,   .step_offset = 0L,   .step_total = NULL )"},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"One-step IDW interpolation from source points to target zones — interpolate_election","text":"tracts_sf sf polygon object. Target zones (e.g., census tracts). electoral_sf sf point object. Source points (e.g., voting locations). zone_id Character. Name ID column tracts_sf. point_id Character. Name ID column electoral_sf. calib_zones Character vector. Column names tracts_sf use calibration population matrix. Must match calib_sources length. calib_sources Character vector. Column names electoral_sf use source calibration matrix. Must match calib_zones length. interp_sources Character vector NULL. Column names electoral_sf interpolate. Default NULL means numeric columns calib_sources. time_matrix Numeric matrix [n x m] NULL. Pre-computed travel times. provided, skips travel time computation. network_path Character NULL. Path directory OSM .pbf file. provided (time_matrix NULL), travel times computed directly without downloading OSM data. elevation_path Character NULL. Path elevation .tif file r5r routing. osm_buffer_km Numeric. Buffer kilometers expand bounding box auto-downloading OSM data. Default: 10. min_pop Numeric. Minimum total population calib_zones zone included. Default: 1. alpha Numeric vector length n, NULL. Pre-computed decay parameters. provided, optimization skipped. offset Numeric. Travel time offset. Default: 1. keep Character vector NULL. Names heavy intermediate objects include result. Default NULL (lightweight). Options: \"weights\" (column-standardized weight matrix [n x m]), \"time_matrix\" (travel time matrix [n x m]), \"sources_sf\" (source points sf object geometry). can large big municipalities. Travel times cached disk can reloaded without keeping memory. use_gpu Logical NULL. Passed optimize_alpha(). verbose Logical. Print progress. Default: TRUE. ... Additional arguments forwarded optimize_alpha(), compute_travel_times(), /download_r5r_data(). .step_offset Integer. Internal: offset added step numbers called interpolate_election_br(). set manually. .step_total Integer NULL. Internal: total step count unified progress display. set manually.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"One-step IDW interpolation from source points to target zones — interpolate_election","text":"list class \"interpElections_result\" components: interpolated Numeric matrix [n x p]. Interpolated values. alpha Numeric vector length n. Decay parameters used. tracts_sf sf object interpolated columns joined zones. sources Data frame (geometry) source point data. optimization interpElections_optim object, NULL alpha pre-supplied. offset Numeric. Offset value used. call matched call. zone_id Character. Name ID column zones. point_id Character. Name ID column sources. interp_cols Character vector. Names interpolated columns. calib_cols List $zones $sources calibration columns. weights Numeric matrix [n x m] NULL. Present keep includes \"weights\". time_matrix Numeric matrix [n x m] NULL. Present keep includes \"time_matrix\". sources_sf sf point object NULL. Source points geometry. Present keep includes \"sources_sf\".","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"One-step IDW interpolation from source points to target zones — interpolate_election","text":"","code":"if (FALSE) { # \\dontrun{ # Minimal: sf objects + column names (auto-downloads OSM) result <- interpolate_election(   tracts_sf    = census_tracts,   electoral_sf = voting_stations,   zone_id      = \"code_tract\",   point_id     = \"id\",   calib_zones  = c(\"pop_18_24\", \"pop_25_34\"),   calib_sources = c(\"voters_18_24\", \"voters_25_34\") )  # With pre-computed travel times (skip r5r) result <- interpolate_election(   tracts_sf    = census_tracts,   electoral_sf = voting_stations,   zone_id      = \"code_tract\",   point_id     = \"id\",   calib_zones  = c(\"pop_young\", \"pop_old\"),   calib_sources = c(\"voters_young\", \"voters_old\"),   time_matrix  = my_tt_matrix ) } # }"},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election_br.html","id":null,"dir":"Reference","previous_headings":"","what":"One-step interpolation for Brazilian elections — interpolate_election_br","title":"One-step interpolation for Brazilian elections — interpolate_election_br","text":"High-level wrapper auto-downloads census data, electoral data, tract geometries, OSM road networks, runs full optimization interpolation pipeline. user needs provide IBGE municipality code election year.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election_br.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"One-step interpolation for Brazilian elections — interpolate_election_br","text":"","code":"interpolate_election_br(   code_muni,   year,   comparecimento_path = NULL,   votacao_path = NULL,   network_path = NULL,   time_matrix = NULL,   cargo = NULL,   turno = 1L,   what = \"candidates\",   candidates = NULL,   parties = NULL,   interp_sources = NULL,   census_year = NULL,   clip_sf = NULL,   remove_unpopulated = TRUE,   osm_buffer_km = 10,   osm_provider = \"openstreetmap_fr\",   keep = NULL,   alpha = NULL,   offset = 1,   use_gpu = NULL,   cache = TRUE,   force = FALSE,   verbose = TRUE,   ... )"},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election_br.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"One-step interpolation for Brazilian elections — interpolate_election_br","text":"code_muni Numeric character. 7-digit IBGE municipality code (e.g., 3550308 Sao Paulo, 3170701 Varginha). TSE code state abbreviation resolved automatically. year Integer. Election year. Brazil holds two types elections: Municipal (even years divisible 4): 2000, 2004, 2008, 2012, 2016, 2020, 2024. Offices: prefeito, vereador. General/federal (even years divisible 4): 2002, 2006, 2010, 2014, 2018, 2022. Offices: presidente, governador, senador, deputado federal, deputado estadual. comparecimento_path Character NULL. Path attendance/turnout parquet file. NULL (default), turnout computed vote data . votacao_path Character NULL. Path candidate votes parquet file. NULL (default), vote data auto-downloaded TSE open data portal. network_path Character NULL. Path directory containing OSM .pbf file r5r routing. NULL time_matrix also NULL, OSM data auto-downloaded via download_r5r_data(). time_matrix Numeric matrix NULL. Pre-computed travel time matrix [n x m]. provided, skips travel time computation (r5r, OSM download). Useful re-running different parameters municipality. cargo Integer, character, NULL. electoral office(s) include. Accepts one human-readable aliases (case-insensitive) TSE numeric codes: NULL (default), offices available election year included. multiple cargos selected, output columns prefixed office name (e.g., PRESIDENTE_CAND_13, GOVERNADOR_CAND_22). turno Integer. Election round: 1 (first round, default) 2 (runoff). first round always exists. second round (turno 2) held presidente, governador, prefeito (cities >200k voters), candidate wins outright majority. turno 2 occur, result contain zero vote rows offices. Character vector. Controls information interpolated census tracts. One : \"candidates\" (default): Vote counts per candidate. Creates one column per candidate, named CAND_<number> (e.g., CAND_13, CAND_22). Also includes QT_COMPARECIMENTO (total turnout). \"parties\": Vote counts aggregated party. Creates one column per party, named PARTY_<abbreviation> (e.g., PARTY_PT, PARTY_PL). Also includes QT_COMPARECIMENTO. \"turnout\": Turnout abstention. Creates QT_COMPARECIMENTO (voters showed ), QT_APTOS (eligible voters), QT_ABSTENCOES (abstentions), available. \"demographics\": Voter profile demographics. Creates GENERO_* columns (e.g., GENERO_FEMININO, GENERO_MASCULINO) EDUC_* columns (e.g., EDUC_SUP_COMP, EDUC_FUND_INCOMP). Multiple values can combined: = c(\"candidates\", \"parties\", \"turnout\", \"demographics\"). candidates Character numeric vector, NULL. Filter specific candidates (used \"candidates\" %% ): number (numeric): Matches candidate's ballot number exactly. Example: candidates = c(13, 22) keeps candidates 13 (Lula) 22 (Bolsonaro) 2022. name (character): Performs accent-normalized, case-insensitive substring matching candidate's registered name. Example: candidates = \"LULA\" matches \"LUIZ INACIO LULA DA SILVA\". NULL (default): candidates included (including special codes 95 = votos em branco, 96 = votos nulos). parties Character vector NULL. Filter specific parties (used \"parties\" %% ). Uses official TSE party abbreviations, matched case-insensitively: Example: parties = c(\"PT\", \"PL\") keeps PT PL. NULL (default): parties included. interp_sources Character vector NULL. Column names electoral data interpolate. Default NULL auto-selects based . Override need fine-grained control columns interpolated. census_year Integer NULL. Census year population data (2000, 2010, 2022). NULL (default), auto-selected based election year: Elections 2000-2004 use Census 2000 Elections 2008-2016 use Census 2010 Elections 2020+ use Census 2022 clip_sf sf polygon NULL. Optional geometry clip tracts (e.g., urban area boundary). Tracts outside polygon removed interpolation. remove_unpopulated Logical. Remove zero-population tracts. Default: TRUE. osm_buffer_km Numeric. Buffer km OSM bounding box expansion. Default: 10. osm_provider Character. OSM extract provider osmextract. Default: \"openstreetmap_fr\" (state-level extracts Brazil). Alternatives: \"geofabrik\", \"bbbike\". used OSM data auto-downloaded (network_path time_matrix provided). keep Character vector NULL. Names heavy intermediate objects include result. Default NULL (lightweight). Options: \"weights\", \"time_matrix\", \"sources_sf\". See interpolate_election() details. alpha Numeric vector NULL. Pre-computed decay parameters (one per tract). provided, optimization step skipped entirely. Useful re-interpolating previously optimized alpha. offset Numeric. Travel time offset. Default: 1. use_gpu Logical NULL. Passed optimize_alpha(). cache Logical. TRUE (default), downloaded files (TSE data, OSM networks, census tracts) stored persistently across R sessions. See get_interpElections_cache_dir(). Subsequent calls reuse cached files, making re-runs much faster. force Logical. Re-download even cached file exists. Default: FALSE. verbose Logical. Default: TRUE. ... Additional arguments forwarded interpolate_election(), optimize_alpha(), compute_travel_times(), /download_r5r_data().","code":""},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election_br.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"One-step interpolation for Brazilian elections — interpolate_election_br","text":"list class \"interpElections_result\" components: interpolated Numeric matrix [n x p]. Rows = census tracts, columns = interpolated variables. alpha Numeric vector length n. Optimized decay parameters. tracts_sf sf object interpolated columns joined , ready mapping plot() ggplot2. sources Data frame prepared electoral data (one row per voting location), without geometry. optimization interpElections_optim NULL (alpha pre-supplied). offset Numeric. Offset value used. call matched call. zone_id Character. Name zone ID column. point_id Character. Name source point ID column. interp_cols Character vector. Names interpolated columns. calib_cols List $zones $sources calibration columns. weights Numeric matrix NULL. Present keep includes \"weights\". time_matrix Numeric matrix NULL. Present keep includes \"time_matrix\". sources_sf sf point object NULL. Present keep includes \"sources_sf\". code_muni IBGE municipality code. year Election year. census_year Census year. Character vector data types interpolated. pop_data Data frame census population tract.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election_br.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"One-step interpolation for Brazilian elections — interpolate_election_br","text":"Internally calls interpolate_election() preparing inputs.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election_br.html","id":"election-types","dir":"Reference","previous_headings":"","what":"Election types","title":"One-step interpolation for Brazilian elections — interpolate_election_br","text":"Brazil holds elections every two years, alternating municipal general (federal/state) elections: Municipal elections (2000, 2004, 2008, 2012, 2016, 2020, 2024): elect prefeito (mayor) vereador (city councilor). General elections (2002, 2006, 2010, 2014, 2018, 2022): elect presidente, governador, senador, deputado federal, deputado estadual. Presidential vote data published TSE separate national file (~250 MB). function handles download automatically cargo includes \"presidente\" cargo = NULL general election year.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election_br.html","id":"output-columns","dir":"Reference","previous_headings":"","what":"Output columns","title":"One-step interpolation for Brazilian elections — interpolate_election_br","text":"tracts_sf output contains original census tract geometry plus interpolated columns. Column names follow patterns: CAND_<number> Interpolated vote count candidate ballot number <number>. Special numbers: 95 = blank votes (em branco), 96 = null votes (nulo). PARTY_<abbrev> Interpolated total votes party <abbrev> (e.g., PARTY_PT, PARTY_PL). GENERO_<category> Interpolated voter count gender (e.g., GENERO_FEMININO, GENERO_MASCULINO). EDUC_<level> Interpolated voter count education level (e.g., EDUC_SUP_COMP, EDUC_FUND_INCOMP). QT_COMPARECIMENTO Total voters showed . QT_APTOS Total eligible voters (available). QT_ABSTENCOES Total abstentions (available). multiple cargo values selected, candidate party columns prefixed: PRESIDENTE_CAND_13, GOVERNADOR_PARTY_PT, etc.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/interpolate_election_br.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"One-step interpolation for Brazilian elections — interpolate_election_br","text":"","code":"if (FALSE) { # \\dontrun{ # ── Minimal usage ─────────────────────────────────────────────── # Just an IBGE code + year. Everything else is auto-downloaded. result <- interpolate_election_br(   code_muni = 3550308,   # Sao Paulo   year = 2020 )  # The result includes an sf object ready for mapping plot(result$tracts_sf[\"CAND_13\"])   # ── Choosing a specific cargo ─────────────────────────────────── # Municipal election: only city councilors (vereador) result <- interpolate_election_br(   code_muni = 3170701, year = 2020,   cargo = \"vereador\" )  # General election: only the presidential race result <- interpolate_election_br(   code_muni = 3170701, year = 2022,   cargo = \"presidente\" )  # Multiple offices at once (columns are prefixed) result <- interpolate_election_br(   code_muni = 3170701, year = 2022,   cargo = c(\"presidente\", \"governador\") ) # -> columns: PRESIDENTE_CAND_13, GOVERNADOR_CAND_30, ...   # ── Turno (election round) ───────────────────────────────────── # First round (default) r1 <- interpolate_election_br(   code_muni = 3170701, year = 2022,   cargo = \"presidente\", turno = 1 )  # Runoff (second round) -- only 2 candidates r2 <- interpolate_election_br(   code_muni = 3170701, year = 2022,   cargo = \"presidente\", turno = 2 )   # ── Choosing what to interpolate ─────────────────────────────── # Party vote totals instead of individual candidates result <- interpolate_election_br(   code_muni = 3170701, year = 2022,   cargo = \"governador\",   what = \"parties\" ) # -> columns: PARTY_PT, PARTY_PL, PARTY_MDB, ...  # Voter demographics (gender + education) result <- interpolate_election_br(   code_muni = 3170701, year = 2022,   what = \"demographics\" ) # -> columns: GENERO_FEMININO, EDUC_SUP_COMP, ...  # Turnout and abstention result <- interpolate_election_br(   code_muni = 3170701, year = 2020,   cargo = \"prefeito\",   what = \"turnout\" ) # -> columns: QT_COMPARECIMENTO, QT_APTOS, QT_ABSTENCOES  # Everything at once result <- interpolate_election_br(   code_muni = 3170701, year = 2022,   cargo = \"governador\",   what = c(\"candidates\", \"parties\", \"turnout\", \"demographics\") )   # ── Filtering candidates ─────────────────────────────────────── # By ballot number result <- interpolate_election_br(   code_muni = 3170701, year = 2022,   cargo = \"presidente\",   candidates = c(13, 22) ) # -> only CAND_13 (Lula) and CAND_22 (Bolsonaro)  # By name (accent-insensitive substring search) result <- interpolate_election_br(   code_muni = 3170701, year = 2022,   cargo = \"presidente\",   candidates = \"LULA\" ) # -> matches \"LUIZ INACIO LULA DA SILVA\"   # ── Filtering parties ────────────────────────────────────────── result <- interpolate_election_br(   code_muni = 3170701, year = 2022,   cargo = \"presidente\",   what = \"parties\",   parties = c(\"PT\", \"PL\") ) # -> only PARTY_PT and PARTY_PL   # ── Re-using a previous result ───────────────────────────────── # Keep the time_matrix for reuse (opt-in via keep) result <- interpolate_election_br(   code_muni = 3170701, year = 2022,   cargo = \"governador\",   keep = \"time_matrix\" )  # Then reuse the alpha and travel time matrix result2 <- interpolate_election_br(   code_muni = 3170701, year = 2022,   cargo = \"governador\",   what = \"parties\",   time_matrix = result$time_matrix,   alpha = result$alpha )   # ── Pre-computed travel times (skip r5r) ─────────────────────── result <- interpolate_election_br(   code_muni = 3550308, year = 2020,   time_matrix = my_tt_matrix ) } # }"},{"path":"https://antrologos.github.io/interpElections/reference/muni_crosswalk.html","id":null,"dir":"Reference","previous_headings":"","what":"IBGE-TSE Municipality Code Crosswalk — muni_crosswalk","title":"IBGE-TSE Municipality Code Crosswalk — muni_crosswalk","text":"Official crosswalk table mapping IBGE 7-digit municipality codes TSE 5-digit electoral codes 5,710 Brazilian municipalities. Sourced GV-CEPESP.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/muni_crosswalk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IBGE-TSE Municipality Code Crosswalk — muni_crosswalk","text":"","code":"muni_crosswalk"},{"path":"https://antrologos.github.io/interpElections/reference/muni_crosswalk.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"IBGE-TSE Municipality Code Crosswalk — muni_crosswalk","text":"data frame 5,710 rows 4 columns: code_ibge Character. IBGE 7-digit municipality code. code_tse Character. TSE 5-digit municipality code. uf Character. Two-letter state abbreviation (e.g., \"SP\", \"RJ\"). nome Character. Municipality name uppercase.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/muni_crosswalk.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"IBGE-TSE Municipality Code Crosswalk — muni_crosswalk","text":"GV-CEPESP, FGV: https://github.com/GV-CEPESP/cepespdata/blob/main/tabelas_auxiliares/dados/codigo_municipio_ibge_tse.csv","code":""},{"path":"https://antrologos.github.io/interpElections/reference/muni_crosswalk.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IBGE-TSE Municipality Code Crosswalk — muni_crosswalk","text":"","code":"data(muni_crosswalk) # Look up TSE code for Sao Paulo (IBGE 3550308) muni_crosswalk[muni_crosswalk$code_ibge == \"3550308\", ] #>      code_ibge code_tse uf      nome #> 5360   3550308    71072 SP SÃO PAULO"},{"path":"https://antrologos.github.io/interpElections/reference/optimize_alpha.html","id":null,"dir":"Reference","previous_headings":"","what":"Find optimal decay parameters (alpha) for IDW interpolation — optimize_alpha","title":"Find optimal decay parameters (alpha) for IDW interpolation — optimize_alpha","text":"Optimizes per-zone decay parameters minimize squared error IDW-interpolated values known population counts. Supports GPU-accelerated optimization via torch (ADAM) CPU optimization via L-BFGS-B.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/optimize_alpha.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find optimal decay parameters (alpha) for IDW interpolation — optimize_alpha","text":"","code":"optimize_alpha(   time_matrix,   pop_matrix,   source_matrix,   alpha_init = NULL,   use_gpu = NULL,   device = NULL,   dtype = \"float32\",   gpu_iterations = 20L,   gpu_lr_init = 0.1,   gpu_lr_decay = 0.6,   cpu_method = \"auto\",   cpu_parallel = NULL,   cpu_ncores = NULL,   lower_bound = 0,   upper_bound = 20,   maxit = 10000L,   offset = 1,   verbose = TRUE )"},{"path":"https://antrologos.github.io/interpElections/reference/optimize_alpha.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find optimal decay parameters (alpha) for IDW interpolation — optimize_alpha","text":"time_matrix Numeric matrix [n x m]. Raw travel times. Rows = target zones, columns = source points. pop_matrix Numeric matrix [n x k]. Known population per zone, k demographic groups columns. source_matrix Numeric matrix [m x k]. Known counts source points (e.g., registered voters age group). alpha_init Numeric vector length n, single value recycled. Initial guess alpha. Default: rep(1, n). use_gpu Logical NULL. TRUE, use torch ADAM optimizer. FALSE, use CPU optimization. NULL (default), reads package option interpElections.use_gpu (set via use_gpu()). device Character NULL. Torch device: \"cuda\", \"mps\", \"cpu\". used GPU enabled. Default: NULL (auto-detect). dtype Character. Torch dtype: \"float32\" \"float64\". Default: \"float32\". Float32 halves GPU memory usage negligible precision loss optimization problem. gpu_iterations Integer. Number outer ADAM iterations. Default: 20. gpu_lr_init Numeric. Initial ADAM learning rate. Default: 0.1. gpu_lr_decay Numeric. Learning rate decay factor per outer iteration. Default: 0.6. cpu_method Character. CPU optimization method: \"L-BFGS-B\", \"BFGS\", \"auto\". \"auto\" tries parallel L-BFGS-B first, serial L-BFGS-B, BFGS. Default: \"auto\". cpu_parallel Logical NULL. Use optimParallel CPU? Default: NULL (auto-detect based package availability). cpu_ncores Integer NULL. Number cores parallel optimization. Default: NULL (auto = max(1, detectCores() - 2)). lower_bound Numeric. Lower bound alpha values. Default: 0. upper_bound Numeric. Upper bound alpha values. Values ~10 produce nearly identical weights (nearest source dominates), capping prevents meaningless divergence methods. Default: 20. maxit Integer. Maximum iterations CPU optimizer. Default: 10000. offset Numeric. Value added travel times. Default: 1. verbose Logical. Print progress messages? Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/optimize_alpha.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find optimal decay parameters (alpha) for IDW interpolation — optimize_alpha","text":"list class \"interpElections_optim\" components: alpha Numeric vector. Optimal alpha values. value Numeric. Objective function value optimum. method Character. Optimization method used (e.g., \"gpu_adam\", \"cpu_lbfgsb_parallel\", \"cpu_lbfgsb\", \"cpu_bfgs\"). convergence Integer. 0 = success. iterations Number iterations/steps taken. elapsed difftime object. Wall-clock time. message Character. Additional information. history Numeric vector. Objective values step (GPU ).","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/optimize_alpha.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find optimal decay parameters (alpha) for IDW interpolation — optimize_alpha","text":"","code":"tt <- matrix(c(2, 5, 3, 4, 6, 2), nrow = 2) pop <- matrix(c(100, 200), nrow = 2) src <- matrix(c(80, 120, 100), nrow = 3) result <- optimize_alpha(tt, pop, src, verbose = FALSE) result$alpha #> [1] 1.5069488 0.9746938"},{"path":"https://antrologos.github.io/interpElections/reference/plot.interpElections_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot an interpolated variable on a map — plot.interpElections_result","title":"Plot an interpolated variable on a map — plot.interpElections_result","text":"Produces quick choropleth map interpolated variable using tracts_sf stored result object.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/plot.interpElections_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot an interpolated variable on a map — plot.interpElections_result","text":"","code":"# S3 method for class 'interpElections_result' plot(x, var = NULL, ...)"},{"path":"https://antrologos.github.io/interpElections/reference/plot.interpElections_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot an interpolated variable on a map — plot.interpElections_result","text":"x interpElections_result object. var Character. Name variable plot. Must one x$interp_cols. NULL, plots first interpolated variable. ... Additional arguments passed plot.sf().","code":""},{"path":"https://antrologos.github.io/interpElections/reference/plot.interpElections_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot an interpolated variable on a map — plot.interpElections_result","text":"Invisibly returns x.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/residuals.interpElections_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute calibration residuals — residuals.interpElections_result","title":"Compute calibration residuals — residuals.interpElections_result","text":"Returns matrix calibration residuals (fitted minus observed) zone calibration bracket. Requires weight matrix travel time matrix present result (use keep = \"weights\" keep = \"time_matrix\" running interpolation).","code":""},{"path":"https://antrologos.github.io/interpElections/reference/residuals.interpElections_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute calibration residuals — residuals.interpElections_result","text":"","code":"# S3 method for class 'interpElections_result' residuals(object, ...)"},{"path":"https://antrologos.github.io/interpElections/reference/residuals.interpElections_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute calibration residuals — residuals.interpElections_result","text":"object interpElections_result object. ... Ignored.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/residuals.interpElections_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute calibration residuals — residuals.interpElections_result","text":"Numeric matrix [n x k] residuals (fitted - observed), k number calibration brackets.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/set_interpElections_cache_dir.html","id":null,"dir":"Reference","previous_headings":"","what":"Set a custom interpElections cache directory — set_interpElections_cache_dir","title":"Set a custom interpElections cache directory — set_interpElections_cache_dir","text":"Persists custom cache directory path across R sessions. path NULL, resets default OS-appropriate location.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/set_interpElections_cache_dir.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set a custom interpElections cache directory — set_interpElections_cache_dir","text":"","code":"set_interpElections_cache_dir(path = NULL, verbose = TRUE)"},{"path":"https://antrologos.github.io/interpElections/reference/set_interpElections_cache_dir.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set a custom interpElections cache directory — set_interpElections_cache_dir","text":"path Character NULL. Directory path cached files. Created exist. NULL resets default. verbose Logical. Print confirmation. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/set_interpElections_cache_dir.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set a custom interpElections cache directory — set_interpElections_cache_dir","text":"Invisibly returns cache directory path.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/set_java_memory.html","id":null,"dir":"Reference","previous_headings":"","what":"Set Java heap memory for r5r — set_java_memory","title":"Set Java heap memory for r5r — set_java_memory","text":"Configures maximum heap size Java Virtual Machine used r5r. Large travel-time matrices can require several gigabytes JVM heap.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/set_java_memory.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set Java heap memory for r5r — set_java_memory","text":"","code":"set_java_memory(size, persist = interactive())"},{"path":"https://antrologos.github.io/interpElections/reference/set_java_memory.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set Java heap memory for r5r — set_java_memory","text":"size Character. Memory size unit suffix, e.g. \"4g\" 4 GB, \"512m\" 512 MB, \"8g\" 8 GB. persist Logical. Also write ~/.Renviron setting persists across R sessions. Default: TRUE interactive sessions.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/set_java_memory.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set Java heap memory for r5r — set_java_memory","text":"Invisibly, previous value getOption(\"java.parameters\").","code":""},{"path":"https://antrologos.github.io/interpElections/reference/set_java_memory.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Set Java heap memory for r5r — set_java_memory","text":"sets options(java.parameters = \"-Xmx{size}\"). must called r5r (rJava) loaded — JVM starts, heap size changed without restarting R. rule thumb: allocate \\(\\ge 2\\) GB per million OD pairs expect travel-time matrix. municipality 5,000 census tracts 200 polling locations, 1 million pairs — 2-4 GB usually enough. Larger cities (e.g. Sao Paulo) may need 8-16 GB.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/set_java_memory.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set Java heap memory for r5r — set_java_memory","text":"","code":"if (FALSE) { # \\dontrun{ set_java_memory(\"4g\") set_java_memory(\"8g\", persist = TRUE) } # }"},{"path":"https://antrologos.github.io/interpElections/reference/setup_java.html","id":null,"dir":"Reference","previous_headings":"","what":"Download and configure Java 21 for r5r — setup_java","title":"Download and configure Java 21 for r5r — setup_java","text":"Downloads Adoptium Temurin JDK 21 current platform, extracts local directory, configures R session r5r can find . Optionally persists configuration ~/.Renviron.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/setup_java.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Download and configure Java 21 for r5r — setup_java","text":"","code":"setup_java(   install_dir = file.path(tools::R_user_dir(\"interpElections\", \"data\"), \"java\"),   persist = interactive(),   verbose = TRUE )"},{"path":"https://antrologos.github.io/interpElections/reference/setup_java.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Download and configure Java 21 for r5r — setup_java","text":"install_dir Character. install Java. Default uses tools::R_user_dir() Java lives alongside R user data. persist Logical. Write JAVA_HOME ~/.Renviron persists across R sessions. Default: TRUE interactive sessions. verbose Logical. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/setup_java.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Download and configure Java 21 for r5r — setup_java","text":"Invisibly, path installed JDK.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/setup_java.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Download and configure Java 21 for r5r — setup_java","text":"JDK downloaded Eclipse Adoptium project (https://adoptium.net). archive extracted install_dir/jdk-21 JAVA_HOME set current session. persist = TRUE, function appends (updates) JAVA_HOME line ~/.Renviron future R sessions find Java automatically.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/setup_java.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Download and configure Java 21 for r5r — setup_java","text":"","code":"if (FALSE) { # \\dontrun{ setup_java() check_r5r() } # }"},{"path":"https://antrologos.github.io/interpElections/reference/setup_osmium.html","id":null,"dir":"Reference","previous_headings":"","what":"Install osmium-tool for OSM file clipping — setup_osmium","title":"Install osmium-tool for OSM file clipping — setup_osmium","text":"Attempts install osmium-tool (osmconvert fallback) using system package manager. required clip large state-level OSM extracts municipality-level bounding boxes r5r routing.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/setup_osmium.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Install osmium-tool for OSM file clipping — setup_osmium","text":"","code":"setup_osmium(method = NULL, verbose = TRUE)"},{"path":"https://antrologos.github.io/interpElections/reference/setup_osmium.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Install osmium-tool for OSM file clipping — setup_osmium","text":"method Character NULL. Installation method use. NULL (default), auto-detects. Options: \"conda\": conda install (platforms) \"brew\": Homebrew (macOS) \"apt\": apt-get (Debian/Ubuntu) \"dnf\": dnf (Fedora/RHEL) \"download\": Download osmconvert binary (Windows ) verbose Logical. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/setup_osmium.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Install osmium-tool for OSM file clipping — setup_osmium","text":"Invisibly, path installed tool, NULL installation failed.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/setup_osmium.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Install osmium-tool for OSM file clipping — setup_osmium","text":"preferred tool osmium-tool, faster reliable. osmconvert used fallback osmium available. Windows, \"download\" method fetches pre-compiled osmconvert.exe binary saves interpElections cache. require conda package manager.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/setup_osmium.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Install osmium-tool for OSM file clipping — setup_osmium","text":"","code":"if (FALSE) { # \\dontrun{ setup_osmium() setup_osmium(method = \"conda\") setup_osmium(method = \"download\")  # Windows only } # }"},{"path":"https://antrologos.github.io/interpElections/reference/setup_torch.html","id":null,"dir":"Reference","previous_headings":"","what":"Install and configure torch with GPU support — setup_torch","title":"Install and configure torch with GPU support — setup_torch","text":"Installs torch R package (missing) downloads platform-appropriate libtorch + lantern binaries GPU support. installation, verifies GPU acceleration works via check_torch().","code":""},{"path":"https://antrologos.github.io/interpElections/reference/setup_torch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Install and configure torch with GPU support — setup_torch","text":"","code":"setup_torch(reinstall = FALSE, type = NULL, verbose = TRUE)"},{"path":"https://antrologos.github.io/interpElections/reference/setup_torch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Install and configure torch with GPU support — setup_torch","text":"reinstall Logical. Force re-download libtorch/lantern binaries even already exist. Use fix broken CUDA installations (e.g., CPU-lantern accidentally installed). Default: FALSE. type Character NULL. Installation type, passed torch::install_torch(). Common values: NULL (auto-detect), \"cuda\" (force CUDA Windows/Linux), \"cpu\" (force CPU-). Default: NULL (auto-detect based available GPU). verbose Logical. Default: TRUE.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/setup_torch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Install and configure torch with GPU support — setup_torch","text":"Invisibly, result check_torch() installation, partial list needs_restart = TRUE R must restarted.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/setup_torch.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Install and configure torch with GPU support — setup_torch","text":"installation proceeds stages: torch R package installed, installed CRAN. torch::install_torch() downloads libtorch lantern binaries. Windows/Linux NVIDIA GPU CUDA toolkit, automatically selects CUDA-enabled binaries. verification step runs check_torch() confirm GPU works. Important: torch package already loaded current R session calling setup_torch(), must restart R new binaries take effect. function detects warns accordingly.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/setup_torch.html","id":"cuda-auto-detection","dir":"Reference","previous_headings":"","what":"CUDA auto-detection","title":"Install and configure torch with GPU support — setup_torch","text":"torch::install_torch() detects CUDA version : CUDA environment variable (set, forces version) CUDA_PATH (Windows) CUDA_HOME (Linux) nvcc --version PATH","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/setup_torch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Install and configure torch with GPU support — setup_torch","text":"","code":"if (FALSE) { # \\dontrun{ setup_torch()                    # auto-detect GPU setup_torch(type = \"cuda\")       # force CUDA setup_torch(reinstall = TRUE)    # fix broken install } # }"},{"path":"https://antrologos.github.io/interpElections/reference/summary.interpElections_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize an interpElections result — summary.interpElections_result","title":"Summarize an interpElections result — summary.interpElections_result","text":"Prints detailed summary including calibration information, optimization details, per-variable statistics.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/summary.interpElections_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize an interpElections result — summary.interpElections_result","text":"","code":"# S3 method for class 'interpElections_result' summary(object, ...)"},{"path":"https://antrologos.github.io/interpElections/reference/summary.interpElections_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize an interpElections result — summary.interpElections_result","text":"object interpElections_result object. ... Ignored.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/summary.interpElections_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize an interpElections result — summary.interpElections_result","text":"Invisibly returns object.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/use_gpu.html","id":null,"dir":"Reference","previous_headings":"","what":"Enable or disable GPU acceleration — use_gpu","title":"Enable or disable GPU acceleration — use_gpu","text":"Sets package-wide options controlling whether optimize_alpha() uses GPU-accelerated optimization (torch ADAM) CPU-methods.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/use_gpu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Enable or disable GPU acceleration — use_gpu","text":"","code":"use_gpu(enable = TRUE, device = NULL, dtype = \"float32\")"},{"path":"https://antrologos.github.io/interpElections/reference/use_gpu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Enable or disable GPU acceleration — use_gpu","text":"enable Logical. TRUE enable GPU, FALSE CPU . device Character NULL. Torch device: \"cuda\", \"mps\", \"cpu\". NULL = auto-detect. dtype Character. \"float32\" \"float64\". Default: \"float32\".","code":""},{"path":"https://antrologos.github.io/interpElections/reference/use_gpu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Enable or disable GPU acceleration — use_gpu","text":"Invisibly returns previous settings list.","code":""},{"path":"https://antrologos.github.io/interpElections/reference/use_gpu.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Enable or disable GPU acceleration — use_gpu","text":"GPU enabled, optimize_alpha() uses torch ADAM optimizer default. requires torch package installed working GPU backend (CUDA NVIDIA, MPS Apple Silicon). per-call use_gpu parameter optimize_alpha() always overrides global setting.","code":""},{"path":[]},{"path":"https://antrologos.github.io/interpElections/reference/use_gpu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Enable or disable GPU acceleration — use_gpu","text":"","code":"use_gpu(FALSE) # ensure CPU mode #> GPU disabled. Using CPU optimization."}]
