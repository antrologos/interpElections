% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interpolate-wrapper.R
\name{interpolate_election}
\alias{interpolate_election}
\title{One-step IDW interpolation from source points to census tracts}
\usage{
interpolate_election(
  tracts_sf,
  electoral_sf,
  calib_tracts,
  calib_sources,
  interp_sources = NULL,
  tract_id = "id",
  point_id = "id",
  time_matrix = NULL,
  max_epochs = 2000L,
  alpha_min = 1,
  mode = "WALK",
  gtfs_zip_path = NULL,
  max_trip_duration = 300L,
  point_method = "pop_weighted",
  min_area_for_pop_weight = 1,
  min_tract_pop = 1,
  offset = 1,
  use_gpu = NULL,
  keep = NULL,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{tracts_sf}{An \code{sf} polygon object. Target census tracts.}

\item{electoral_sf}{An \code{sf} point object. Source points (e.g., voting
locations).}

\item{calib_tracts}{Character vector. Column names in \code{tracts_sf} to use
as the calibration population matrix. Must match \code{calib_sources} in
length.}

\item{calib_sources}{Character vector. Column names in \code{electoral_sf} to
use as the source calibration matrix. Must match \code{calib_tracts} in
length.}

\item{interp_sources}{Character vector or NULL. Column names in
\code{electoral_sf} to interpolate. Default NULL means all numeric columns
not in \code{calib_sources}.}

\item{tract_id}{Character. Name of the ID column in \code{tracts_sf}.
Default: \code{"id"}.}

\item{point_id}{Character. Name of the ID column in \code{electoral_sf}.
Default: \code{"id"}.}

\item{time_matrix}{Numeric matrix [n x m] or NULL. Pre-computed travel
times. If provided, skips all travel time computation.}

\item{max_epochs}{Integer. Maximum optimizer epochs. Default: 2000.
See \code{\link[=optimize_alpha]{optimize_alpha()}}.}

\item{alpha_min}{Numeric. Lower bound for decay parameters. Default: 1.
See \code{\link[=optimize_alpha]{optimize_alpha()}}.}

\item{mode}{Character. Routing mode: \code{"WALK"} (default), \code{"BICYCLE"},
\code{"CAR"}, or transit combos like \code{"WALK;TRANSIT"}.}

\item{gtfs_zip_path}{Character or NULL. Path to a GTFS \code{.zip} file for
transit routing. Default: NULL.}

\item{max_trip_duration}{Integer. Maximum trip duration in minutes.
Also used as fill value for unreachable pairs. Default: 300.}

\item{point_method}{Character. Method for tract representative points:
\code{"pop_weighted"} (default), \code{"point_on_surface"}, or \code{"centroid"}.
See \code{\link[=compute_representative_points]{compute_representative_points()}}.}

\item{min_area_for_pop_weight}{Numeric. Minimum tract area in km2
for the pop_weighted method. Smaller tracts use point_on_surface.
Default: 1.}

\item{min_tract_pop}{Numeric. Minimum total population in
\code{calib_tracts} for a census tract to be included. Default: 1.}

\item{offset}{Numeric. Travel time offset. Default: 1.}

\item{use_gpu}{Logical or NULL. Passed to \code{\link[=optimize_alpha]{optimize_alpha()}}.}

\item{keep}{Character vector or NULL. Names of extra intermediate
objects to include in the result. \code{weights} and \code{time_matrix} are
always kept. Options: \code{"electoral_sf"}, \code{"pop_raster"},
\code{"rep_points"}.}

\item{verbose}{Logical. Print progress. Default: TRUE.}

\item{...}{Advanced tuning. See \link{interpElections-passthrough}.}
}
\value{
A list of class \code{"interpElections_result"} with components:
\describe{
\item{interpolated}{Numeric matrix [n x p]. Interpolated values.}
\item{alpha}{Decay parameters used.}
\item{tracts_sf}{\code{sf} object with interpolated columns joined.}
\item{sources}{Data frame (no geometry) of source point data.}
\item{optimization}{\code{interpElections_optim} object.}
\item{offset}{Numeric. Offset value used.}
\item{call}{The matched call.}
\item{tract_id, point_id}{ID column names.}
\item{interp_cols}{Character vector. Interpolated column names.}
\item{calib_cols}{List with \verb{$tracts} and \verb{$sources}.}
\item{weights}{Weight matrix or NULL (opt-in via \code{keep}).}
\item{time_matrix}{Travel time matrix or NULL (opt-in via \code{keep}).}
\item{electoral_sf}{\code{sf} point object or NULL (opt-in via \code{keep}).}
\item{pop_raster}{Population raster or NULL (opt-in via \code{keep}).}
\item{rep_points}{Representative points or NULL (opt-in via \code{keep}).}
}
}
\description{
General-purpose wrapper that combines travel-time computation (optional),
alpha optimization, and interpolation into a single call. Accepts R
objects (sf data frames) directly. If no travel time matrix is provided,
OSM road network data is automatically downloaded and travel times are
computed via r5r.
}
\details{
For Brazilian elections, use \code{\link[=interpolate_election_br]{interpolate_election_br()}} which
auto-downloads all required data.
}
\examples{
\dontrun{
# Minimal: sf objects + column names (auto-downloads OSM)
result <- interpolate_election(
  tracts_sf    = census_tracts,
  electoral_sf = voting_stations,
  calib_tracts  = c("pop_18_24", "pop_25_34"),
  calib_sources = c("voters_18_24", "voters_25_34")
)

# With pre-computed travel times (skip r5r)
result <- interpolate_election(
  tracts_sf    = census_tracts,
  electoral_sf = voting_stations,
  calib_tracts  = c("pop_young", "pop_old"),
  calib_sources = c("voters_young", "voters_old"),
  time_matrix  = my_tt_matrix
)
}

}
\seealso{
\code{\link[=optimize_alpha]{optimize_alpha()}}, \code{\link[=compute_weight_matrix]{compute_weight_matrix()}},
\code{\link[=interpolate_election_br]{interpolate_election_br()}} for the Brazilian-specific wrapper,
\link{interpElections-passthrough} for advanced tuning via \code{...}.

Other wrappers: 
\code{\link{interpolate_election_br}()}
}
\concept{wrappers}
