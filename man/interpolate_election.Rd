% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interpolate-wrapper.R
\name{interpolate_election}
\alias{interpolate_election}
\title{One-step IDW interpolation from source points to census tracts}
\usage{
interpolate_election(
  tracts_sf,
  electoral_sf,
  tract_id,
  point_id,
  calib_tracts,
  calib_sources,
  interp_sources = NULL,
  time_matrix = NULL,
  network_path = NULL,
  elevation_path = NULL,
  osm_buffer_km = 10,
  min_pop = 1,
  alpha = NULL,
  offset = 1,
  keep = NULL,
  use_gpu = NULL,
  verbose = TRUE,
  ...,
  .step_offset = 0L,
  .step_total = NULL
)
}
\arguments{
\item{tracts_sf}{An \code{sf} polygon object. Target census tracts.}

\item{electoral_sf}{An \code{sf} point object. Source points (e.g., voting
locations).}

\item{tract_id}{Character. Name of the ID column in \code{tracts_sf}.}

\item{point_id}{Character. Name of the ID column in \code{electoral_sf}.}

\item{calib_tracts}{Character vector. Column names in \code{tracts_sf} to use
as the calibration population matrix. Must match \code{calib_sources} in
length.}

\item{calib_sources}{Character vector. Column names in \code{electoral_sf} to
use as the source calibration matrix. Must match \code{calib_tracts} in
length.}

\item{interp_sources}{Character vector or NULL. Column names in
\code{electoral_sf} to interpolate. Default NULL means all numeric columns
not in \code{calib_sources}.}

\item{time_matrix}{Numeric matrix [n x m] or NULL. Pre-computed travel
times. If provided, skips all travel time computation.}

\item{network_path}{Character or NULL. Path to directory with an OSM
\code{.pbf} file. If provided (and \code{time_matrix} is NULL), travel times
are computed directly without downloading OSM data.}

\item{elevation_path}{Character or NULL. Path to elevation \code{.tif} file
for r5r routing.}

\item{osm_buffer_km}{Numeric. Buffer in kilometers to expand the
bounding box when auto-downloading OSM data. Default: 10.}

\item{min_pop}{Numeric. Minimum total population in \code{calib_tracts} for a
census tract to be included. Default: 1.}

\item{alpha}{Numeric vector of length n, or NULL. Pre-computed decay
parameters. If provided, optimization is skipped.}

\item{offset}{Numeric. Travel time offset. Default: 1.}

\item{keep}{Character vector or NULL. Names of heavy intermediate
objects to include in the result. Default NULL (lightweight).
Options: \code{"weights"} (column-standardized weight matrix [n x m]),
\code{"time_matrix"} (travel time matrix [n x m]),
\code{"sources_sf"} (source points as \code{sf} object with geometry),
\code{"pop_raster"} (population density raster, when \code{point_method = "pop_weighted"}),
\code{"rep_points"} (representative points \code{sf} object used for routing).
These can be large for big municipalities. Travel times are
cached on disk and can be reloaded without keeping them in memory.}

\item{use_gpu}{Logical or NULL. Passed to \code{\link[=optimize_alpha]{optimize_alpha()}}.}

\item{verbose}{Logical. Print progress. Default: TRUE.}

\item{...}{Additional arguments forwarded to \code{\link[=optimize_alpha]{optimize_alpha()}},
\code{\link[=compute_travel_times]{compute_travel_times()}}, and/or \code{\link[=download_r5r_data]{download_r5r_data()}}.
Notable forwarded arguments: \code{point_method} (representative point
method), \code{pop_raster} (population density raster),
\code{pop_min_area} (area threshold for pop-weighted points).
See \code{\link[=compute_travel_times]{compute_travel_times()}} for details.}

\item{.step_offset}{Integer. Internal: offset added to step numbers
when called from \code{\link[=interpolate_election_br]{interpolate_election_br()}}. Do not set manually.}

\item{.step_total}{Integer or NULL. Internal: total step count for
unified progress display. Do not set manually.}
}
\value{
A list of class \code{"interpElections_result"} with components:
\describe{
\item{interpolated}{Numeric matrix [n x p]. Interpolated values.}
\item{alpha}{Numeric vector of length n. Decay parameters used.}
\item{tracts_sf}{\code{sf} object with interpolated columns joined to census tracts.}
\item{sources}{Data frame (no geometry) of source point data.}
\item{optimization}{\code{interpElections_optim} object, or NULL if \code{alpha} was
pre-supplied.}
\item{offset}{Numeric. Offset value used.}
\item{call}{The matched call.}
\item{tract_id}{Character. Name of the census tract ID column.}
\item{point_id}{Character. Name of the ID column in sources.}
\item{interp_cols}{Character vector. Names of interpolated columns.}
\item{calib_cols}{List with \verb{$tracts} and \verb{$sources} calibration columns.}
\item{weights}{Numeric matrix [n x m] or NULL. Present only when
\code{keep} includes \code{"weights"}.}
\item{time_matrix}{Numeric matrix [n x m] or NULL. Present only when
\code{keep} includes \code{"time_matrix"}.}
\item{sources_sf}{\code{sf} point object or NULL. Source points with
geometry. Present only when \code{keep} includes \code{"sources_sf"}.}
\item{pop_raster}{\link[terra:SpatRaster-class]{terra::SpatRaster} or NULL. Population density
raster (cropped to municipality). Present only when \code{keep} includes
\code{"pop_raster"} and \code{point_method = "pop_weighted"} was used.}
\item{rep_points}{\code{sf} POINT object or NULL. Representative points
used for travel time routing. Present only when \code{keep} includes
\code{"rep_points"}.}
}
}
\description{
High-level wrapper that combines travel-time computation (optional),
alpha optimization, and interpolation into a single call. If no travel
time matrix is provided, OSM road network data is automatically
downloaded and travel times are computed via r5r.
}
\examples{
\dontrun{
# Minimal: sf objects + column names (auto-downloads OSM)
result <- interpolate_election(
  tracts_sf    = census_tracts,
  electoral_sf = voting_stations,
  tract_id     = "code_tract",
  point_id     = "id",
  calib_tracts  = c("pop_18_24", "pop_25_34"),
  calib_sources = c("voters_18_24", "voters_25_34")
)

# With pre-computed travel times (skip r5r)
result <- interpolate_election(
  tracts_sf    = census_tracts,
  electoral_sf = voting_stations,
  tract_id     = "code_tract",
  point_id     = "id",
  calib_tracts  = c("pop_young", "pop_old"),
  calib_sources = c("voters_young", "voters_old"),
  time_matrix  = my_tt_matrix
)
}

}
\seealso{
\code{\link[=optimize_alpha]{optimize_alpha()}}, \code{\link[=sinkhorn_weights]{sinkhorn_weights()}},
\code{\link[=interpolate_election_br]{interpolate_election_br()}} for the Brazilian-specific wrapper.

Other wrappers: 
\code{\link{interpolate_election_br}()}
}
\concept{wrappers}
