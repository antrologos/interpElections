% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/objective.R
\name{idw_objective}
\alias{idw_objective}
\title{Compute the IDW interpolation objective value}
\usage{
idw_objective(alpha, time_matrix, pop_matrix, source_matrix)
}
\arguments{
\item{alpha}{Numeric vector of length n. Decay parameters per target zone.
Must be non-negative.}

\item{time_matrix}{Numeric matrix [n x m]. Adjusted travel times (with
offset already applied). Rows = target zones, columns = source points.}

\item{pop_matrix}{Numeric matrix [n x k]. Known population counts per
target zone, with k demographic groups as columns.}

\item{source_matrix}{Numeric matrix [m x k]. Known counts at source
points (e.g., registered voters by age group).}
}
\value{
Single numeric value: \code{sum((W_std \%*\% source_matrix - pop_matrix)^2)}
}
\description{
Calculates the sum of squared errors between the IDW-interpolated values
and the known population matrix. This is the loss function that
\code{\link[=optimize_alpha]{optimize_alpha()}} minimizes.
}
\details{
The weight matrix is computed as:
\deqn{W_{ij} = t_{ij}^{-\alpha_i}}
then column-standardized so each column sums to 1.
The interpolated values are \eqn{\hat{V} = W_{std} \times V}{V_hat = W_std \%*\% V},
and the objective is \eqn{\sum (\hat{V} - P)^2}{sum((V_hat - P)^2)}.
}
\examples{
tt <- matrix(c(2, 5, 3, 4, 6, 2), nrow = 2) # 2 zones x 3 sources
pop <- matrix(c(100, 200), nrow = 2)          # 2 zones x 1 group
src <- matrix(c(80, 120, 100), nrow = 3)      # 3 sources x 1 group
alpha <- c(1, 1.5)
idw_objective(alpha, tt, pop, src)

}
\seealso{
\code{\link[=idw_gradient]{idw_gradient()}} for the analytical gradient, \code{\link[=idw_weights]{idw_weights()}}
for the weight matrix, \code{\link[=optimize_alpha]{optimize_alpha()}} for the optimization wrapper.

Other IDW core: 
\code{\link{idw_gradient}()},
\code{\link{idw_interpolate}()},
\code{\link{idw_weights}()},
\code{\link{optimize_alpha}()}
}
\concept{IDW core}
