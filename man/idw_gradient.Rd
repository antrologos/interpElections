% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gradient.R
\name{idw_gradient}
\alias{idw_gradient}
\title{Compute the analytical gradient of the IDW objective}
\usage{
idw_gradient(alpha, time_matrix, pop_matrix, source_matrix)
}
\arguments{
\item{alpha}{Numeric vector of length n. Decay parameters per target zone.
Must be non-negative.}

\item{time_matrix}{Numeric matrix [n x m]. Adjusted travel times (with
offset already applied). Rows = target zones, columns = source points.}

\item{pop_matrix}{Numeric matrix [n x k]. Known population counts per
target zone, with k demographic groups as columns.}

\item{source_matrix}{Numeric matrix [m x k]. Known counts at source
points (e.g., registered voters by age group).}
}
\value{
Numeric vector of length n: the gradient of the objective with
respect to each element of alpha.
}
\description{
Computes the gradient of \code{\link[=idw_objective]{idw_objective()}} with respect to each element
of the alpha vector. Used by the CPU optimizer for faster convergence.
}
\details{
The gradient is computed analytically using the chain rule through the
column-standardized weight matrix. The computation is structured to avoid
forming any n x n intermediate matrices, keeping the per-evaluation cost
at O(n * m) rather than O(n^2 * m). This makes CPU optimization feasible
even for large municipalities with thousands of census tracts.

For k demographic groups, the total gradient is the sum of per-group
gradients.
}
\examples{
tt <- matrix(c(2, 5, 3, 4, 6, 2), nrow = 2)
pop <- matrix(c(100, 200), nrow = 2)
src <- matrix(c(80, 120, 100), nrow = 3)
alpha <- c(1, 1.5)
idw_gradient(alpha, tt, pop, src)

}
\seealso{
\code{\link[=idw_objective]{idw_objective()}} for the objective function,
\code{\link[=optimize_alpha]{optimize_alpha()}} for the optimization wrapper.

Other IDW core: 
\code{\link{idw_interpolate}()},
\code{\link{idw_objective}()},
\code{\link{idw_weights}()},
\code{\link{optimize_alpha}()}
}
\concept{IDW core}
