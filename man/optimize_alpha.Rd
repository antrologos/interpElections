% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/optimize.R
\name{optimize_alpha}
\alias{optimize_alpha}
\title{Find optimal decay parameters (alpha) for IDW interpolation}
\usage{
optimize_alpha(
  time_matrix,
  pop_matrix,
  source_matrix,
  alpha_init = NULL,
  use_gpu = NULL,
  device = NULL,
  dtype = "float64",
  gpu_iterations = 20L,
  gpu_lr_init = 0.1,
  gpu_lr_decay = 0.6,
  cpu_method = "auto",
  cpu_parallel = NULL,
  cpu_ncores = NULL,
  lower_bound = 0,
  upper_bound = 20,
  maxit = 10000L,
  offset = 1,
  verbose = TRUE
)
}
\arguments{
\item{time_matrix}{Numeric matrix [n x m]. Raw travel times.
Rows = target zones, columns = source points.}

\item{pop_matrix}{Numeric matrix [n x k]. Known population per zone,
with k demographic groups as columns.}

\item{source_matrix}{Numeric matrix [m x k]. Known counts at source
points (e.g., registered voters by age group).}

\item{alpha_init}{Numeric vector of length n, or a single value to be
recycled. Initial guess for alpha. Default: \code{rep(1, n)}.}

\item{use_gpu}{Logical or NULL. If \code{TRUE}, use torch ADAM optimizer. If
\code{FALSE}, use CPU optimization. If \code{NULL} (default), reads the package
option \code{interpElections.use_gpu} (set via \code{\link[=use_gpu]{use_gpu()}}).}

\item{device}{Character or NULL. Torch device: \code{"cuda"}, \code{"mps"}, or
\code{"cpu"}. Only used when GPU is enabled. Default: NULL (auto-detect).}

\item{dtype}{Character. Torch dtype: \code{"float32"} or \code{"float64"}. Default:
\code{"float64"}.}

\item{gpu_iterations}{Integer. Number of outer ADAM iterations. Default: 20.}

\item{gpu_lr_init}{Numeric. Initial ADAM learning rate. Default: 0.1.}

\item{gpu_lr_decay}{Numeric. Learning rate decay factor per outer iteration.
Default: 0.6.}

\item{cpu_method}{Character. CPU optimization method: \code{"L-BFGS-B"},
\code{"BFGS"}, or \code{"auto"}. \code{"auto"} tries parallel L-BFGS-B first, then
serial L-BFGS-B, then BFGS. Default: \code{"auto"}.}

\item{cpu_parallel}{Logical or NULL. Use \code{optimParallel} for CPU? Default:
NULL (auto-detect based on package availability).}

\item{cpu_ncores}{Integer or NULL. Number of cores for parallel optimization.
Default: NULL (auto = \code{max(1, detectCores() - 2)}).}

\item{lower_bound}{Numeric. Lower bound for alpha values. Default: 0.}

\item{upper_bound}{Numeric. Upper bound for alpha values. Values above
~10 produce nearly identical weights (the nearest source dominates),
so capping prevents meaningless divergence between methods. Default: 20.}

\item{maxit}{Integer. Maximum iterations for CPU optimizer. Default: 10000.}

\item{offset}{Numeric. Value added to travel times. Default: 1.}

\item{verbose}{Logical. Print progress messages? Default: TRUE.}
}
\value{
A list of class \code{"interpElections_optim"} with components:
\describe{
\item{alpha}{Numeric vector. Optimal alpha values.}
\item{value}{Numeric. Objective function value at optimum.}
\item{method}{Character. Optimization method used (e.g.,
\code{"gpu_adam"}, \code{"cpu_lbfgsb_parallel"}, \code{"cpu_lbfgsb"}, \code{"cpu_bfgs"}).}
\item{convergence}{Integer. 0 = success.}
\item{iterations}{Number of iterations/steps taken.}
\item{elapsed}{\code{difftime} object. Wall-clock time.}
\item{message}{Character. Additional information.}
\item{history}{Numeric vector. Objective values at each step (GPU only).}
}
}
\description{
Optimizes the per-zone decay parameters that minimize the squared error
between IDW-interpolated values and known population counts. Supports
GPU-accelerated optimization via torch (ADAM) and CPU optimization via
L-BFGS-B.
}
\examples{
tt <- matrix(c(2, 5, 3, 4, 6, 2), nrow = 2)
pop <- matrix(c(100, 200), nrow = 2)
src <- matrix(c(80, 120, 100), nrow = 3)
result <- optimize_alpha(tt, pop, src, verbose = FALSE)
result$alpha

}
\seealso{
\code{\link[=use_gpu]{use_gpu()}} to toggle GPU globally, \code{\link[=idw_interpolate]{idw_interpolate()}} to apply
the optimal alphas, \code{\link[=idw_objective]{idw_objective()}} and \code{\link[=idw_gradient]{idw_gradient()}} for the
underlying math.

Other IDW core: 
\code{\link{idw_gradient}()},
\code{\link{idw_interpolate}()},
\code{\link{idw_objective}()},
\code{\link{idw_weights}()}
}
\concept{IDW core}
