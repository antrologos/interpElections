% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/weight-matrix.R
\name{compute_weight_matrix}
\alias{compute_weight_matrix}
\title{Compute the Sinkhorn-balanced weight matrix}
\usage{
compute_weight_matrix(
  time_matrix,
  alpha,
  pop_matrix,
  source_matrix,
  offset = 1,
  method = c("colnorm", "sinkhorn"),
  sk_iter = 100L,
  sk_tol = 1e-06,
  use_gpu = NULL,
  verbose = FALSE
)
}
\arguments{
\item{time_matrix}{Numeric matrix [n x m]. Travel times or distances
from each zone (row) to each source point (column).}

\item{alpha}{Numeric scalar, vector of length n, or matrix [n x k].
Per-tract-per-bracket decay parameters. A scalar or n-vector is
recycled across all k brackets. Typically from \code{optimize_alpha()$alpha}.}

\item{pop_matrix}{Numeric matrix [n x k]. Known population counts
per zone and demographic bracket.}

\item{source_matrix}{Numeric matrix [m x k]. Known counts at source
points per demographic bracket.}

\item{offset}{Numeric scalar. Added to \code{time_matrix} before
exponentiation: \eqn{K^b_{ij} = (t_{ij} + \text{offset})^{-\alpha_{ib}}}.
Default: 1.}

\item{method}{Character. Normalization method: \code{"colnorm"} (column-only
normalization, default) or \code{"sinkhorn"} (3D Sinkhorn IPF). Should match
the method used during optimization.}

\item{sk_iter}{Integer. Maximum Sinkhorn iterations. Only used when
\code{method = "sinkhorn"}. Default: 100L.}

\item{sk_tol}{Numeric. Sinkhorn convergence tolerance. Default: 1e-6.}

\item{use_gpu}{Logical or NULL. If TRUE, use GPU; if FALSE, use CPU;
if NULL (default), respect the global setting from \code{\link[=use_gpu]{use_gpu()}}.}

\item{verbose}{Logical. Print progress? Default: FALSE.}
}
\value{
Numeric matrix [n x m]. Sinkhorn-balanced weight matrix where
each column sums to approximately 1. Use as \verb{W \\\%*\\\% data} to
interpolate any source-level variable into zones.
}
\description{
Builds a weight matrix \eqn{W} from per-tract-per-bracket decay parameters
using the same 3D Sinkhorn IPF as \code{\link[=optimize_alpha]{optimize_alpha()}}. Uses torch for
computation (CPU or GPU).
}
\details{
This function performs the same 3D Sinkhorn computation used internally
by \code{\link[=optimize_alpha]{optimize_alpha()}} during epoch evaluation. It is useful when you
have pre-computed alpha values and need to build the weight matrix
without running optimization.

The 3D Sinkhorn enforces two properties:
\itemize{
\item \strong{Property 1 (voter conservation)}: Each source-bracket
pair distributes its full count across zones.
\item \strong{Property 2 (population proportions)}: Each zone's total
inflow is proportional to its population.
}
}
\examples{
\dontrun{
# After optimization
result <- optimize_alpha(tt, pop, src)
W <- result$W   # weight matrix already computed

# Or build W from pre-existing alpha
W <- compute_weight_matrix(tt, alpha, pop, src)
interpolated <- W \%*\% electoral_data
}

}
\seealso{
\code{\link[=optimize_alpha]{optimize_alpha()}} which returns both alpha and W.
}
