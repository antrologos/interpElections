% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/weight-matrix.R
\name{compute_weight_matrix}
\alias{compute_weight_matrix}
\title{Compute the weight matrix}
\usage{
compute_weight_matrix(
  time_matrix,
  alpha,
  pop_matrix,
  source_matrix,
  offset = 1,
  kernel = "power",
  use_gpu = NULL,
  verbose = FALSE
)
}
\arguments{
\item{time_matrix}{Numeric matrix [n x m]. Travel times or distances
from each zone (row) to each source point (column).}

\item{alpha}{Numeric scalar, vector of length n, or matrix [n x k].
Per-tract-per-bracket decay parameters. A scalar or n-vector is
recycled across all k brackets. Typically from \code{optimize_alpha()$alpha}.}

\item{pop_matrix}{Numeric matrix [n x k]. Known population counts
per zone and demographic bracket.}

\item{source_matrix}{Numeric matrix [m x k]. Known counts at source
points per demographic bracket.}

\item{offset}{Numeric scalar. Added to \code{time_matrix} before
exponentiation for the power kernel:
\eqn{K^b_{ij} = (t_{ij} + \text{offset})^{-\alpha_{ib}}}.
Ignored when \code{kernel = "exponential"}. Default: 1.}

\item{kernel}{Character. \code{"power"} (default) or \code{"exponential"}.
See \code{\link[=optim_control]{optim_control()}} for details.}

\item{use_gpu}{Logical or NULL. If TRUE, use GPU; if FALSE, use CPU;
if NULL (default), respect the global setting from \code{\link[=use_gpu]{use_gpu()}}.}

\item{verbose}{Logical. Print progress? Default: FALSE.}
}
\value{
Numeric matrix [n x m]. Column-normalized weight matrix where
each column sums to approximately 1. Use as \verb{W \\\%*\\\% data} to
interpolate any source-level variable into zones.
}
\description{
Builds a weight matrix \eqn{W} from per-tract-per-bracket decay parameters
using column normalization. Uses torch for computation (CPU or GPU).
}
\details{
This function performs the same column normalization used internally
by \code{\link[=optimize_alpha]{optimize_alpha()}} during epoch evaluation. It is useful when you
have pre-computed alpha values and need to build the weight matrix
without running optimization.

Column normalization ensures voter conservation: each source-bracket
pair distributes its full count across zones.
}
\examples{
\dontrun{
# After optimization
result <- optimize_alpha(tt, pop, src)
W <- result$W   # weight matrix already computed

# Or build W from pre-existing alpha
W <- compute_weight_matrix(tt, alpha, pop, src)
interpolated <- W \%*\% electoral_data
}

}
\seealso{
\code{\link[=optimize_alpha]{optimize_alpha()}} which returns both alpha and W.
}
