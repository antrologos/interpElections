% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sinkhorn.R
\name{sinkhorn_weights}
\alias{sinkhorn_weights}
\title{Compute Sinkhorn-balanced IDW weights}
\usage{
sinkhorn_weights(
  time_matrix,
  alpha,
  offset = 1,
  row_targets = NULL,
  col_targets = NULL,
  pop_matrix = NULL,
  source_matrix = NULL,
  max_iter = 1000L,
  tol = 1e-10
)
}
\arguments{
\item{time_matrix}{Numeric matrix [n x m]. Raw travel times.
Rows = target zones, columns = source points.}

\item{alpha}{Numeric vector of length n. Decay parameters per target zone.}

\item{offset}{Numeric. Added to travel times before applying decay.
Default: 1.}

\item{row_targets}{Numeric vector of length n. Desired row sums.
For electoral interpolation, use \code{pop / sum(pop) * m} where \code{pop}
is the population vector and \code{m = ncol(time_matrix)}. Default: \code{NULL}
(uniform allocation).}

\item{col_targets}{Numeric vector of length m. Desired column sums.
Default: \code{NULL} (\code{rep(1, m)} for source conservation).}

\item{pop_matrix}{Numeric matrix [n x k] or NULL. Population per zone
per demographic bracket. When provided together with \code{source_matrix},
enables per-bracket Sinkhorn mode. Default: NULL.}

\item{source_matrix}{Numeric matrix [m x k] or NULL. Source counts per
demographic bracket. Must be provided together with \code{pop_matrix}.
Default: NULL.}

\item{max_iter}{Integer. Max Sinkhorn iterations. Default: 1000.}

\item{tol}{Numeric. Convergence tolerance. Default: 1e-10.}
}
\value{
Numeric matrix [n x m]. Sinkhorn-balanced weights with
\code{rowSums(W)} approximately equal to \code{row_targets} and \code{colSums(W)}
approximately equal to \code{col_targets}. Preserves dimnames from
\code{time_matrix}. Carries attributes from \code{\link[=sinkhorn_balance]{sinkhorn_balance()}}.
}
\description{
Builds inverse distance weights from a travel-time matrix and per-zone
decay parameters, then applies Sinkhorn balancing to enforce both row
and column marginal constraints.
}
\details{
When \code{pop_matrix} and \code{source_matrix} are provided, per-bracket Sinkhorn
balancing is used: each demographic column gets its own Sinkhorn transport
(with row targets rescaled to match source totals), then all bracket
contributions are summed and a final aggregate Sinkhorn enforces the
overall \code{row_targets} / \code{col_targets} constraints.
}
\examples{
tt <- matrix(c(2, 5, 3, 4, 6, 2), nrow = 2)
alpha <- c(1, 1.5)
pop <- c(100, 200)
m <- ncol(tt)
W <- sinkhorn_weights(tt, alpha, row_targets = pop / sum(pop) * m)
colSums(W)  # approx 1 (source conservation)
rowSums(W)  # proportional to population

}
\seealso{
\code{\link[=sinkhorn_balance]{sinkhorn_balance()}} for the core algorithm,
\code{\link[=optimize_alpha]{optimize_alpha()}} to find optimal alpha values.

Other Sinkhorn: 
\code{\link{sinkhorn_balance}()},
\code{\link{sinkhorn_objective}()}
}
\concept{Sinkhorn}
